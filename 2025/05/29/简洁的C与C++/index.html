<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">





<title>clear C and C++ | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Bentham&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Bentham&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">clear C and C++</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 29, 2025&nbsp;&nbsp;10:56:44</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="简洁的C及C"><a href="#简洁的C及C" class="headerlink" title="简洁的C及C++"></a>简洁的C及C++</h1><p><a target="_blank" rel="noopener" href="https://codelearn.club/">海洋饼干叔叔</a>		发布于：2020年9月13日		<a target="_blank" rel="noopener" href="http://codelearn.club/2020/09/C-CppBook/">C&#x2F;C++</a></p>
<hr>
<p>新冠病毒肆虐，困在宜昌，不知道做什么好，那就开始写书吧。</p>
<p>―――　2020年1月31日星期五</p>
<blockquote>
<p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 海洋饼干叔叔&#x2F;陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>本文不允许转载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
</blockquote>
<p>配套B站在线MOOC, 重庆大学2020秋随堂录制，每周更新两次。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1it411d7zx/">https://www.bilibili.com/video/BV1it411d7zx/</a></p>
<h2 id="1-学习准备"><a href="#1-学习准备" class="headerlink" title="1. 学习准备"></a>1. 学习准备</h2><p> 我觉得每个人都应该学习一门编程语言。学习编程教你如何思考，就像学习法律一样。学习法律并不一定是为了成为律师，而是教你一种思考方式。学习编程也是一样，我把计算机科学看作基础教育，每个人都应该花至少一年的时间学习编程。</p>
<p> ———— Steve Jobs</p>
<hr>
<p> 科学技术正以令人吃惊的加速度前进，任何踌躇不前者都将被时代所抛弃。在埋头做了20年程序员、电气工程师和大学讲师之后，作者惊讶地发现：<br>​ 编程正在成为一项基本的人生技能！</p>
<p> 20年前，作者还热衷于跟小伙伴在火车上用英语对女孩子的长相品头论足。彼时，英语的普及程度还不太高，虽然中学开了英语课，但大部分人还不能够流利地听说读写。所以，这种不礼貌的用英文品头论足的行为风险还不太高。但在20年后的今天，作者已经不敢做这样的事了，凡是年轻人，鲜有不懂、不会英语者。</p>
<p> 作者深信，与英语一样，编程正在成为一项基本技能！ 一二十年后，完全不会编程的年轻人将会是稀有品种！ 这不是耸人听闻，作者8岁的女儿正在上小学，小学三年级已经开始编程教育了。</p>
<p> <strong>历史学家</strong>借助程序设计，能更好地研究历史上的气温变化和雪线南移对历史进程的影响，这种对历史进行量化研究的学科现已成为显学，我们称之为“计量历史学” 。<strong>经济学家</strong>借助程序设计，可对宏观经济数据进行分析和预测，通过发电量、网络支付的活跃状况等大数据来评估经济的热度和走向。<strong>工业自动化工程师</strong>借助程序设计，可更快更好地识别传送带上的零件的位置和方向，规划机器人的工作节拍和顺序。<strong>艺术工作者</strong>借助编程工具，可更快更<br>好地批量“生成”平面乃至立体艺术作品。<strong>靠码字为生的文化人</strong>借助编程工具设计一个信息爬虫程序，将网络上与指定话题相关的全部信息下载并自动归类整理，撰写文章的效率将大大提高，文章的支持证据将充分而又翔实。<strong>建筑设计师</strong>借助程序设计在将来成功保住了饭碗，因为自动化的建筑设计工具软件将在不远的将来替换大多数的绘图工人。<strong>会计师、银行家、记者、教师</strong>更需要学习编程，因为人工智能正跃跃欲试，试图在工作环境中替代这些从业者。</p>
<p> 即便读者将来就是一个平凡的普通人，那么本书带给你的编程体验可以帮助你更好地理解人工智能和信息安全，以及网络商店里的商品推荐、甚至机票订购网站的价格策略，让你更加从容地面对未来世界。</p>
<p> 无论是早起吃虫的鸟儿，还是跃跃欲试希望有一番作为的年轻人或者正在探索人类知识边界的科学家，甚至在家带孩子的全职太太，都应该了解和学习编程。</p>
<h3 id="1-1-C及C-简史"><a href="#1-1-C及C-简史" class="headerlink" title="1.1 C及C++简史"></a>1.1 C及C++简史</h3><p> 1972年，<strong>Dennis M. Ritchie</strong>（1941-2011）在贝尔实验室以B语言为基础设计了一种新的语言，他取了BCPL语言的第二个字母作为这种语言的名字，即C语言。</p>
<p> 1973年初，C语言的主体完成。<strong>Ken Thompson</strong>和Dennis M. Ritchie用C语言重写了UNIX操作系统。Linux以及苹果的Mac OS，均脱胎于UNIX。当代手机上运行的Android系统，则运行在Linux操作系统内核之上。</p>
<p> 1979年，<strong>Bjame Sgoustrup</strong>到贝尔实验室从事将C语言改良为带类的C（C with classes）的工作。改进后的语言在1983年被正式命名为C++。</p>
<p> 粗略地，可以认为C语言是C++语言的子集，即C++ ≈ C + 类语法。在过去的数十年中，C&#x2F;C++语言演化了多个标准版本，如表1-1所示。</p>
<p> 表1-1 C及C++语言标准版本演化</p>
<table>
<thead>
<tr>
<th align="left">版本</th>
<th>年份</th>
<th>标准号</th>
<th>版本</th>
<th>年份</th>
<th>标准号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C89&#x2F;ANSI C</td>
<td>1989</td>
<td>ANSI X3.159-1989</td>
<td>C++ 98</td>
<td>1998</td>
<td>ISO&#x2F;IEC 14882:1998</td>
</tr>
<tr>
<td align="left">C90</td>
<td>1990</td>
<td>ISO&#x2F;IEC 9899: 1990</td>
<td>C++ 03</td>
<td>2003</td>
<td>ISO&#x2F;IEC 14882:2003</td>
</tr>
<tr>
<td align="left">C99</td>
<td>1999</td>
<td>ISO&#x2F;IEC 9899: 1999</td>
<td>C++ 11</td>
<td>2011</td>
<td>ISO&#x2F;IEC 14882:2011</td>
</tr>
<tr>
<td align="left">C11</td>
<td>2011</td>
<td>ISO&#x2F;IEC 9899:2011</td>
<td>C++ 14</td>
<td>2014</td>
<td>ISO&#x2F;IEC 14882:2014</td>
</tr>
<tr>
<td align="left">C18</td>
<td>2018</td>
<td>ISO&#x2F;IEC 9899:2018</td>
<td>C++ 17</td>
<td>2017</td>
<td>ISO&#x2F;IEC 14882:2017</td>
</tr>
</tbody></table>
<p> 2020年8月新发布的TOIBE的编程语言排行榜中，C语言以16.98%的市场占有率力挫Java重回第1名，C++语言则以6.84%的市场占有率排名第4。要知道，C语言已经是接近50高龄的老人家了，而C++语言也差不多40岁了。</p>
<p> 表1-2 TOIBE的编程语言排行榜（前5位，2020年8月）</p>
<table>
<thead>
<tr>
<th>2020年8月</th>
<th>2019年8月</th>
<th>排名变化</th>
<th>编程语言</th>
<th>占有率</th>
<th>变化率</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>↑</td>
<td>C</td>
<td>16.98%</td>
<td>+1.83%</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>↓</td>
<td>Java</td>
<td>14.43%</td>
<td>-1.60%</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td></td>
<td>Python</td>
<td>9.69%</td>
<td>-0.33%</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td></td>
<td>C++</td>
<td>6.84%</td>
<td>+0.78%</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td></td>
<td>C#</td>
<td>4.68%</td>
<td>+0.83%</td>
</tr>
</tbody></table>
<p> C&#x2F;C++是执行效率最高的程序设计语言，C语言的执行速度甚至十分逼近汇编语言。然而天下武功，唯快不破，至少在下述领域，C&#x2F;C++语言发挥着舍我其谁的不可替代的重要作用：</p>
<ul>
<li>编写操作系统：无论是Windows、Linux、UNIX还是Mac OS，其内核均由C语言混合汇编语言编写，非内核部分则会部分使用C++语言。对于运行于底层的操作系统而言，运行速度以及与硬件打交道的便捷性均是最重要的考量因素，而这些，正是C&#x2F;C++语言之所长。</li>
<li>编写其他高级语言的解释器、虚拟机：Java语言虚拟机是由C+汇编语法编写的；Python语言解释器（特指CPython）是由C语言编写的。可以说，C语言是各种程序设计语言之母。</li>
<li>高性能的系统软件：关系数据库系统mysql是用C及C++语言编写而成；高性能Web服务器软件nginx则由C语言编写。</li>
<li>资源耗费巨大、对速度要求高的大型工具软件：计算机辅助设计软件AutoCAD、集成电路设计软件Cadence等都是用C&#x2F;C++语言为主编写的。</li>
<li>单片机程序：受限于单片机有限的计算资源和能力，目前单片机片上程序的编写仍以C语言为主。最近几年，以 5G及物联网为基础，大量的低功耗可编程器件被广泛使用， 受限于有限的计算资源和能力，这些器件上的程序编写以C语言为主。</li>
</ul>
<p> C&#x2F;C++语言比很多读者的父辈还要年长。在数十年的发展历程中，不断丰富和发展。在语言变得更加强大和健壮的同时，其语法也变得异常复杂。同一行代码，一个有经验的程序员很容易给出5种以上不同的写法。从软件工程角度，这种复杂性不必要而且有害。但考虑到对遗留代码的兼容，C++不得不背负这些历史包袱。作者并不试图全面介绍C&#x2F;C++的全部语法特性，而只是介绍那些常用的，必须的语法特性。作者认为，对于大多数的工程实践而言，掌握这些必要特性就足够应付了。</p>
<p> 本书使用下述符号来标识C&#x2F;C++不同版本之间的差异。</p>
<p> 表1-3 表示语言版本差异的符号</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>【C】</strong></td>
<td>该特性仅在C语言中得到支持</td>
</tr>
<tr>
<td><strong>【C++】</strong></td>
<td>该特性仅在C++语言中得到支持</td>
</tr>
<tr>
<td><strong>【C++ 11】</strong></td>
<td>该特性在C++ 11及其以后版本中得到支持</td>
</tr>
<tr>
<td><strong>【C++ 14】</strong></td>
<td>该特性在C++ 14及其以后版本中得到支持</td>
</tr>
<tr>
<td><strong>【C++ 17】</strong></td>
<td>该特性在C++ 17及其以后版本中得到支持</td>
</tr>
</tbody></table>
<h3 id="1-2-计算机原理"><a href="#1-2-计算机原理" class="headerlink" title="1.2 计算机原理"></a>1.2 计算机原理</h3><p>现代电子计算机仍然没有超出由匈牙利科学家冯·诺依曼（von Neumann）于1945年提出的冯·诺依曼体系结构。在该结构中，计算机被认为由5大部件组成，如图1-1所示。</p>
<p><img src="http://codelearn.club/images/image-20200907163502448.png" alt="image-20200907163502"></p>
<p> 图1-1 冯 · 诺依曼体系结构</p>
<p>其中，典型的<strong>输入设备</strong>包括键盘、鼠标、网卡等，它们负责从计算机外部输入数据到计算机；典型的<strong>输出设备</strong>包括显示器、打印机、网卡等，它们负责将计算机内部的数据输出到计算机外部。读者可能注意到了，网卡既是输入，也是输出设备。</p>
<p>中央处理单元（<strong>C</strong>entral <strong>P</strong>rocessing <strong>U</strong>nit），简称<strong>CPU</strong>，是计算机的核心。它由<strong>运算器</strong>和<strong>控制器</strong>组成。其中，运算器负责加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、比较、传送等操作。控制器则是计算机中指令的解释和执行机构，它控制运算器、存储器、输入输出设备等部件的协调动作。</p>
<p><strong>存储器</strong>又分为内部存储器及外部存储器两个部分。其中，内部存储器简称<strong>内存</strong>，通常是易失的，容量相对较小，但存取速度显著快于外部存储器。所谓易失，是指计算机断电后，内存中的数据会自动丢失。外部存储器通常指硬盘、固态硬盘、U盘等存储设备，相对于内存，其数据可以在断电后<strong>永久</strong>保存，容量通常也更大，但数据存取速度通常显著慢于内存。如果把计算机看作一个完成计算任务的计算员的话，内存可以理解为计算员的草稿纸，它存储计算步骤以及临时的中间结果，而外存，则用于存储计算任务的输入以及计算的最终结果。</p>
<p>冯 · 诺依曼计算机是所谓<strong>存储程序计算机</strong>，计算机处理的数据和指令（程序）一律用二进制表示，并存储于存储器中。在CPU内部控制器的控制下，CPU从存储器逐条读入并执行程序的每条指令。每条指令执行一个单一的任务：比如将寄存器R0与整数3相加，并将计算结果存储到指定地址的内存单元中。借助于跳转、逻辑判断等指令，程序员可以将各种简单的计算操作进行组合，从而让计算机完成诸如从一大堆图片中找出加菲猫等复杂任务。</p>
<p>计算机可以执行的原始指令的集合称之为指令集。当代的计算机，最主要的指令集分为两类，一类是Intel的<strong>x86</strong>指令集，主要用在笔记本及台式计算机上；另一类则是ARM的<strong>ARM</strong>指令集，主要使用在手机等移动终端，以及大量的嵌入式低功耗计算机上。上述两类指令集均是商业指令集，任何公司如果期望生产使用上述指令集的计算机，需需要获得相应的授权。为了实现更美好的共享的全球化的世界，另一种开源的指令集RISC-V，近年来异军突起，得到工业界相当多的关注和支持。</p>
<blockquote>
<p><strong>注意📢</strong> 本节所描述的计算机结构是一个极简化的版本，真实的情况要复杂得多。广义地说，一台笔记本电脑、一部手机、一张使用IC的银行卡上的IC，都属于计算机的范畴，其具体结构差异非常大。</p>
</blockquote>
<h3 id="1-3-内存模型"><a href="#1-3-内存模型" class="headerlink" title="1.3 内存模型"></a>1.3 内存模型</h3><p><img src="http://codelearn.club/images/image-20200907153816772.png" alt="image-20200907153816772"></p>
<p> 图1-2 内存模型</p>
<p>计算机的内存在逻辑上可以用图1-2表示。存储器的最小单位为<strong>比特（bit）</strong>,一个比特可以存储0和1两种状态，对应一个二进制数的1位。每8个比特被组织成一个单元，称为一个<strong>字节（byte）</strong>，其比特位按位权从低到高编号为第0位至第7位。一个字节的8个比特可以表示28，即256种组合，当视为无符号数时，其储值范围为0 ~ 255；当视为有符号数时，符号位要占掉1位，只余7位表示有效值，其储值范围为 -128 ~ +127。如果要表示更大的数，则可以将2个、4个或8个字节联合使用，其可以表达的组合数分别为216、232以及264。</p>
<p>表1-4总结了常用的存储容量单位及其换算关系。</p>
<p> 表1-4 常用存储容量单位</p>
<table>
<thead>
<tr>
<th>单位符号</th>
<th>名称</th>
<th align="left">换算</th>
<th>单位符号</th>
<th>名称</th>
<th>换算</th>
</tr>
</thead>
<tbody><tr>
<td>bit</td>
<td>比特</td>
<td align="left">最小存储单位</td>
<td>byte</td>
<td>字节</td>
<td>1 byte &#x3D; 8 bit</td>
</tr>
<tr>
<td>kB</td>
<td>千字节</td>
<td align="left">1 kB &#x3D; 1024 byte &#x3D; 210 byte</td>
<td>MB</td>
<td>兆字节</td>
<td>1 MB &#x3D; 1024 kB &#x3D; 220 byte</td>
</tr>
<tr>
<td>GB</td>
<td>吉字节</td>
<td align="left">1 GB &#x3D; 1024 MB &#x3D; 230 byte</td>
<td>TB</td>
<td>太字节</td>
<td>1 TB＝ 1024 GB &#x3D; 240 byte</td>
</tr>
</tbody></table>
<p>当一台计算机总共拥有N个字节容量的内存时，通常情况下，其每个字节存储单元的地址依次为1 ~ N。假设你的计算机安装了一根4 GB容量的内存条，其内存容量为232字节，每个字节存储单元的地址依次为1 ~ 232。</p>
<blockquote>
<p><strong>要点🎯</strong> 内存地址以字节为单位编排。CPU从内存存取数据的最小单位为1个字节。如果期望对1字节存储单元的特定比特位进行修改，只能先读出整个字节，然后使用按位操作指令对特定位进行操作，再将整个字节作为整体写回内存。</p>
</blockquote>
<h3 id="1-4-编译器"><a href="#1-4-编译器" class="headerlink" title="1.4 编译器"></a>1.4 编译器</h3><h3 id="1-5-Qt集成开发环境"><a href="#1-5-Qt集成开发环境" class="headerlink" title="1.5 Qt集成开发环境"></a>1.5 Qt集成开发环境</h3><p>Qt集成开发环境的下载与安装</p>
<p><a target="_blank" rel="noopener" href="http://codelearn.club/2022/03/qt_onlineinstall_win/">http://codelearn.club/2022/03/qt_onlineinstall_win/</a></p>
<p>Qt Creator操作入门</p>
<p><a target="_blank" rel="noopener" href="http://codelearn.club/2020/02/simpleqtuse/">http://codelearn.club/2020/02/simpleqtuse/</a></p>
<h3 id="1-6-学习方法"><a href="#1-6-学习方法" class="headerlink" title="1.6 学习方法"></a>1.6 学习方法</h3><h2 id="2-变量及简单数据类型"><a href="#2-变量及简单数据类型" class="headerlink" title="2. 变量及简单数据类型"></a>2. 变量及简单数据类型</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="2-1-Hello-World"><a href="#2-1-Hello-World" class="headerlink" title="2.1 Hello World"></a>2.1 Hello World</h3><p>编程教材的民俗是先打印输出一个“Hello World”向世界问好，这里我们先赞美一下美好的生活。按照?1.2节介绍的方法在Qt Creator中创建一个Non-Qt Project&#x2F;Plain C Application，可在其项目主程序文件main.c中看到下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单击Qt Creator左下角的运行（run）按钮（或使用Ctrl+R组合键），构建（build）并运行，可得如图2- 所示的运行结果：</p>
<p><img src="http://codelearn.club/images/image-20200203103209637.png" alt="image-20200203103209637"></p>
<p>图2- Hello World运行结果</p>
<p>按Enter键或者单击该窗口右上角的X按钮，可关闭上述结果窗口。</p>
<blockquote>
<p><strong>说明：</strong>按照Windows操作系统的通常设置，该运行窗口为黑底白字，为阅读方便，本书的后续部分将以白底黑字形式展现运行结果。</p>
</blockquote>
<p>第3 ~ 6行：main( )是一个标准C&#x2F;C++程序的入口<strong>函数（function）</strong>，即程序启动后会从main( )函数开始执行。main为其函数名，( )里提供的是这个函数的**参数(parameter)**，函数收到参数并执行特定任务后返回一个整数(int)。这个返回的整数可以帮助操作系统判断程序的执行过程是否正常。图2- 描绘了该函数的结构。</p>
<p><img src="http://codelearn.club/images/image-20200203113557480.png" alt="image-20200203113557480"></p>
<p>图2- main( )函数的结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br></pre></td></tr></table></figure>

<p>第1行：这是一行预处理指令（preprocessor directive），该行代码将标准输入输出头文件（header file）stdio.h<strong>包含</strong>至main.c程序文件内。对于上述代码而言，该头文件引入了printf( )函数。换言之，如果期望在代码中使用printf( )函数，必须包含stdio.h头文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello World!\n&quot;);</span><br></pre></td></tr></table></figure>

<p>第4行：printf( )函数将参数<strong>字符串（string）</strong>格式化输出至控制台（console）。字符串以双引号包裹，上述代码中的”\n“是转义字符，表示接下来的输出另起一行。在C&#x2F;C++里，每一个完整的指令称为一个<strong>语句（statement）</strong>，语句总是以”;”号分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>第5行：return语句返回整数0作为main( )函数的执行结果。在操作系统看来，0值表示该程序的执行没有发生异常。</p>
<p>操作系统以及诸如Qt Creator这样的集成开发环境（<strong>I</strong>ntegrated <strong>D</strong>evelopment <strong>E</strong>nvironment）通过文件的扩展名来识别文件的类型。表2- 总结了C&#x2F;C++开发过程中常用的文件类型。</p>
<p>表2- 常用的文件类型</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>.h</td>
<td>C&#x2F;C++的头文件</td>
</tr>
<tr>
<td>.hpp</td>
<td>C++的头文件</td>
</tr>
<tr>
<td>.c</td>
<td>C语言程序文件</td>
</tr>
<tr>
<td>.cpp</td>
<td>C++语言程序文件</td>
</tr>
<tr>
<td>.o</td>
<td>编译过程中生成的目标文件▲</td>
</tr>
<tr>
<td>.exe</td>
<td>Windows操作系统下的可执行文件</td>
</tr>
<tr>
<td>.pro</td>
<td>Qt Creator项目文件</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>▲：</strong>同时兼顾初学者的学习曲线和知识内容的结构是一件不太容易的事，读者在阅读过程中有时会遇到一些暂时无法理解的内容，比如上述表格中的目标文件。不用担心， 随着内容的逐步展开，我们会在后续章节中进行讨论。我们给此类内容加上▲符号，便于读者在恰当时间进行回顾。</p>
</blockquote>
<h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><p>新建一个Plain C Application，将main.c修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Project - Variable</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n = 3;</span><br><span class="line">    float fPrice = 3.6;</span><br><span class="line">    float fAmount = n * fPrice;</span><br><span class="line">    float fMoney = 20;</span><br><span class="line">    fMoney = fMoney - fAmount;</span><br><span class="line">    printf(&quot;%d apples, %.1f for each, %.2f in total.\n&quot;,n,fPrice,fAmount);</span><br><span class="line">    printf(&quot;20 - %.2f = %.2f.&quot;,fAmount,fMoney);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 apples, 3.6 for each, 10.80 in total.</span><br><span class="line">20 - 10.80 = 9.20.</span><br></pre></td></tr></table></figure>

<p>上述代码的第1行以”&#x2F;&#x2F;“开头，为<strong>注释（comment）</strong>。注释是程序员写给自己或者同事看的，编译器编译过程中会自动忽略注释。</p>
<blockquote>
<p><strong>约定：</strong>示例代码的首行注释提示了该代码文件在随书代码目录中的位置。本例中的Project - Variable提示该代码文件位于随书代码第2章中的名为Variable的项目（Project）中。</p>
</blockquote>
<p>上述代码中的n、fPrice、fAmount和fMoney都是变量（variable），每个变量都存储一个值。其中，n为整数类型（int），fPrice, fAmount, fMoney为浮点数类型（float）。在程序运行过程中，变量的值可以随时修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int n = 3;</span><br></pre></td></tr></table></figure>

<p>第5行：代码完成了两个任务。</p>
<ul>
<li>声明并定义了一个名为n的变量，其类型为整数（int）。</li>
<li>将这个变量的值初始化为3。</li>
</ul>
<p>后续fPrice、fMoney等变量的定义和初始化过程与此类似。请注意，变量必须先定义，后使用。</p>
<blockquote>
<p>注意：提醒那些先前学习过Python语言的读者，n &#x3D; 3与Python里的名字绑定完全不同。C&#x2F;C++里，读者可以认为n就是一块内存空间，n &#x3D; 3就是把整数3存入名称为n的内存空间中。</p>
</blockquote>
<p>上述代码还使用了几个<strong>操作符（operator）</strong>，表2- 列出了几个最常用的C&#x2F;C++操作符及其使用示例。</p>
<p>表2- 常用操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值（assignment），通常用于将右方的值传递给左方的变量。</td>
<td>n &#x3D; 3</td>
</tr>
<tr>
<td>+</td>
<td>加（add）</td>
<td>b + c</td>
</tr>
<tr>
<td>-</td>
<td>减（substract）</td>
<td>fMoney - fAmount</td>
</tr>
<tr>
<td>*</td>
<td>乘（multiply）</td>
<td>n * fPrice</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除（divide）</td>
<td>30 &#x2F; 2.3</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d apples, %.1f for each, %.2f in total.\n&quot;,n,fPrice,fAmount);</span><br></pre></td></tr></table></figure>

<p>第10行：printf( )函数共有4个参数，其中，第1个参数由双引号包裹，是一个字符串。该字符串中包含了三个占位符（place holder），在格式化输出过程中，这些占位符将依次由后续参数的值替换。图2- 展示了该行的各占位符、参数与输出文本之间的对应关系，表2- 列出了几个最常用的C&#x2F;C++占位符。</p>
<p><img src="http://codelearn.club/images/image-20200203204702603.png" alt="image-20200203204702603"></p>
<p>图2- 占位符对应关系</p>
<p>表2- 常用占位符</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>整数</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数（小数）， %.1f表示精确到小数点后一位的浮点数， 依次类推</td>
</tr>
<tr>
<td>%s</td>
<td>字符串</td>
</tr>
<tr>
<td>%p</td>
<td>指针（地址）▲</td>
</tr>
<tr>
<td>%c</td>
<td>字符</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
</tbody></table>
<p>printf( )函数可以接受多个参数，其第1个参数预期为一个字符串，该字符串中的占位符个数以及要求的类型应与后续其他参数相匹配，否则会产生错误。</p>
<h3 id="2-3-简单数据类型"><a href="#2-3-简单数据类型" class="headerlink" title="2.3 简单数据类型"></a>2.3 简单数据类型</h3><p>新建一个Plain C++ Application，将main.cpp修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Project - DataType</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char c = &#x27;z&#x27;;</span><br><span class="line">    cout &lt;&lt; &quot;char c = &quot; &lt;&lt; c &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    short si = 2194;</span><br><span class="line">    cout &lt;&lt; &quot;short si = &quot; &lt;&lt; si &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(si) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int i = int(12);</span><br><span class="line">    cout &lt;&lt; &quot;int i = &quot; &lt;&lt; i &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(i) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    long li = 298289282;</span><br><span class="line">    cout &lt;&lt; &quot;long li = &quot; &lt;&lt; li &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(li) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    long long ll = 28929829982892;</span><br><span class="line">    cout &lt;&lt; &quot;long long ll = &quot; &lt;&lt; ll &lt;&lt; &quot;, size = &quot;</span><br><span class="line">         &lt;&lt; sizeof(long long) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    bool b = 3 &gt; 2;</span><br><span class="line">    cout &lt;&lt; &quot;bool b = &quot; &lt;&lt; b &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    float f &#123;79.23&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;float f = &quot; &lt;&lt; f &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(float) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    double d &#123;&#125;;</span><br><span class="line">    cout &lt;&lt; &quot;double d = &quot; &lt;&lt; d &lt;&lt; &quot;, size = &quot; &lt;&lt; sizeof(d) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char c = z, size = 1 bytes.</span><br><span class="line">short si = 2194, size = 2 bytes.</span><br><span class="line">int i = 12, size = 4 bytes.</span><br><span class="line">long li = 298289282, size = 4 bytes.</span><br><span class="line">long long ll = 28929829982892, size = 8 bytes.</span><br><span class="line">bool b = 1, size = 1 bytes.</span><br><span class="line">float f = 79.23, size = 4 bytes.</span><br><span class="line">double d = 0, size = 8 bytes.</span><br></pre></td></tr></table></figure>

<p>上述代码定义并使用了多个类型的变量。从面向对象程序设计的观点来看，<strong>变量（variable）</strong>也称为<strong>对象（Object）</strong>，每个对象都有特定的<strong>数据类型（Type）</strong>，数据类型有时也称为<strong>类（class）</strong>。在本书的后续部分，变量、对象等术语将会混用。</p>
<p>C&#x2F;C++是所谓强类型语言，即每个对象都须先通过定义给予确定的数据类型。在类型确定的情况下，编译器可以方便地安排对象的存储空间，以便于生成高效率的执行代码。每个对象，都需要占用计算机的存储器空间，相同类型的对象，占据相同大小的存储空间，该空间以<strong>字节（byte）</strong>为单位。上述代码中的sizeof( )在使用形式上很象函数，但它事实上是一个操作符，用于计算一个特定类型的对象所占据的存储器字节数。在该操作符的括号，既可以提供对象，如sizeof(i)，也可以提供数据类型，如sizeof(float)。由于编译器“知道”每个对象的类型，所以，当编译器遇到代码sizeof(i)时，会自动推断出实际需要被计算的是sizeof(float)。表2- 列出了常用的简单数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br></pre></td></tr></table></figure>

<p>第2行：包含了iostream<strong>【C++】</strong>，这是C++中的”输入输出流“（input &amp; output stream）头文件，它负责基本的输入输出操作。上述程序中的cout就是由iostream引入的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

<p>第3行：引入了std名字空间（namespace）<strong>【C++】</strong>，为了避免变量&#x2F;对象的重名，C++通过名字空间来区分同名的变量。严格地说，cout的全名应为std::cout，由于第3行代码引入了std名字空间，所以我们可以在后续代码中直接使用cout变量。关于名字空间▲，我们将在后续章节进一步讨论。</p>
<p>上述代码还多次使用cout对象以及&lt;&lt;操作符向控制台输出信息，其功能类似于printf( )函数。以下述代码为例，我们简述通过cout进行打印输出的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;char c= &quot; &lt;&lt; c &lt;&lt; &quot;, size= &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; bytes.&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第7行：cout是一个定义在iostream头文件中的变量，作为控制台输出流（console output stream）使用，其类型为ostream（输出流）; endl也由iostream定义，表示一个换行符，即控制台输出另起一行。上述&lt;&lt;操作符可以连着使用，此处我们总共使用了6个&lt;&lt;操作符，向控制台输出了6个值，这6个值中，有的是字符串，有的是整数（sizeof操作符的返回值），还可以是其它类型。事实上，该行代码的执行过程及其工作原理十分复杂，其中的部分内容需要到本书的后半部分才能彻底解释清楚。当前阶段，读者依照上述格式直接使用即可。</p>
<p>上述程序中的下述代码展现了几种不同的变量初始化的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short si = 2194;</span><br><span class="line">int i = int(12);</span><br><span class="line">float f &#123;79.23&#125;;</span><br><span class="line">double d &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，第1行使用了赋值操作符来初始化si变量；第2行使用了面向对象程序设计中的构造函数▲语法，在类型名之后的括号里提供变量的初始值；第3，4行<strong>【C++ 11】</strong>使用一对花括号来包含变量的初始值，同时省略了赋值操作符，当花括号内为空时，表明初始化变量为0。</p>
<blockquote>
<p>注意：按照软件工程规范，程序员应在定义变量时给变量赋以确定的初始值。未作初始化的变量极可能导致软件缺陷。</p>
</blockquote>
<p>表2- 常用简单数据类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字符</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>短整数，也可以写作short int</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>整数</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>整数（注意，与直觉相反，在多数编译器下，long跟int相同，占据4个字节）</td>
<td>4</td>
</tr>
<tr>
<td>long long</td>
<td>长整数</td>
<td>8</td>
</tr>
<tr>
<td>bool</td>
<td>布尔型<strong>【C++】</strong></td>
<td>1</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点数</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点数</td>
<td>8</td>
</tr>
<tr>
<td>long double</td>
<td>更长的双精度浮点数</td>
<td>16</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：表2- 中的各类型字节数代表了大多数编译器的情况，在部分编译器下，长度可能会不同。</p>
</blockquote>
<h4 id="2-3-1-字符类型"><a href="#2-3-1-字符类型" class="headerlink" title="2.3.1 字符类型"></a>2.3.1 字符类型</h4><p>每个字符类型的对象占据1个字节的存储空间。如图2- 所示，1个字节由8个比特（bit）构成，这8个比特人为编上序号，分别为第0位至第7位，其中第7位为最高位。每个比特可以存储一个为0或者为1的二进制位，故1个字节总共可以表达28共256种不同的状态。</p>
<p><img src="http://codelearn.club/images/image-20200209170639949.png" alt="image-20200209170639949"></p>
<p>图2- 一个字节的存储结构</p>
<p>为便于解释，我们创建一个Plain C++ Application，将main.cpp修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - CharType</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Number of bits: &quot; &lt;&lt; CHAR_BIT &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Range of signed char: &quot; &lt;&lt; CHAR_MIN &lt;&lt; &quot; ~ &quot; &lt;&lt; CHAR_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Range of unsigned char: &quot; &lt;&lt; 0 &lt;&lt; &quot; ~ &quot; &lt;&lt; UCHAR_MAX &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    char c = &#x27;c&#x27;;</span><br><span class="line">    cout &lt;&lt; &quot;ASCII code of &#x27;c&#x27;: &quot; &lt;&lt; (int)c &lt;&lt; endl;</span><br><span class="line">    c += 1;</span><br><span class="line">    cout &lt;&lt; &quot;&#x27;c&#x27; + 1 = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = 250;</span><br><span class="line">    cout &lt;&lt; &quot;signed char with value 250: &quot; &lt;&lt; int(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    unsigned char uc = 250;</span><br><span class="line">    cout &lt;&lt; &quot;unsigned char with value 250: &quot; &lt;&lt; int(uc) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Number of bits: 8</span><br><span class="line">Range of signed char: -128 ~ 127</span><br><span class="line">Range of unsigned char: 0 ~ 255</span><br><span class="line">ASCII code of &#x27;c&#x27;: 99</span><br><span class="line">&#x27;c&#x27; + 1 = d</span><br><span class="line">signed char with value 250: -6</span><br><span class="line">unsigned char with value 250: 250</span><br></pre></td></tr></table></figure>

<p>上述代码中的char类型，事实上是<strong>signed char（有符号字符）</strong>的简写形式，由于需要大约1个比特来表示值的正负，所以只余下7个比特来表示值的大小。因此，signed char的取值范围为 -27 ~ 27-1，即-128 ~ +127。<strong>无符号字符（unsigned char）</strong>类型只表达非负值，故能充分利用8个比特的全部256种状态，其取值范围为0 ~ 28-1，即0 ~ 255。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;climits&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：climits头文件引入了一系列通过#define预处理指令▲定义的符号常量（symbolic constant），这些常量可以帮助我们确定各种类型的取值范围及存储比特数，详情请见表2- 。由于计算机内的存储空间分配是以字节为单位的，所以各类型的存储比特数均为8的倍数。区别于变量，常量（constant）的值不可以在程序执行过程中发生变化，即不可以被赋值。</p>
<p>表2- climits上定义的符号常量</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
<th>值</th>
<th>名称</th>
<th>用途</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR_BIT</td>
<td>char类型比特数</td>
<td>8</td>
<td>CHAR_MAX</td>
<td>char类型最大值</td>
<td>+27-1</td>
</tr>
<tr>
<td>CHAR_MIN</td>
<td>char类型最小值</td>
<td>-27</td>
<td>UCHAR_MAX</td>
<td>unsigned char类型最大值</td>
<td>+28-1</td>
</tr>
<tr>
<td>SHRT_MAX</td>
<td>short类型最大值</td>
<td>+215-1</td>
<td>SHRT_MIN</td>
<td>short类型最小值</td>
<td>-215</td>
</tr>
<tr>
<td>USHRT_MAX</td>
<td>unsigned short类型最大值</td>
<td>+216-1</td>
<td>INT_MAX</td>
<td>int类型最大值</td>
<td>+231-1</td>
</tr>
<tr>
<td>INT_MIN</td>
<td>int类型最小值</td>
<td>-231</td>
<td>UINT_MAX</td>
<td>unsigned int类型最大值</td>
<td>+232-1</td>
</tr>
<tr>
<td>LONG_MAX</td>
<td>long类型最大值</td>
<td>+231-1</td>
<td>LONG_MIN</td>
<td>long类型最小值</td>
<td>-231</td>
</tr>
<tr>
<td>ULONG_MAX</td>
<td>unsigned long类型最大值</td>
<td>+232-1</td>
<td>LLONG_MAX</td>
<td>long long类型最大值</td>
<td>+263-1</td>
</tr>
<tr>
<td>LLONG_MIN</td>
<td>long long类型最小值</td>
<td>-263</td>
<td>ULLONG_MAX</td>
<td>unsigned long long类型最大值</td>
<td>+264-1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：表2- 中给出的范围值代表了大多数编译器的情况，在部分编译器下，范围值可能会不同。</p>
</blockquote>
<p>上述代码中7 ~ 9行的输出结果与上表相符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;c&#x27;;</span><br></pre></td></tr></table></figure>

<p>第11行：将小写的英文字符’c’赋值给了变量c，请注意，单个的字符应使用单引号包裹。根据<strong>美国标准信息交换代码（ASCII）</strong>，char类型取值的正值部分与英文字符可以一一对应。表2- 即为ASCII码表。查表可知，小写字母c对应码值99。</p>
<p>关于ASCII码表，请读者注意如下事实：</p>
<blockquote>
<p>1). 英文字母a-z、A-Z以及数字0 - 9的编码是连续的。b的编码比a大1，c比b大1，依次类推。这种英文字符编码的连续性构成了对字符串进行比较运算▲的数学基础。</p>
<p>2). 字符’0’的ASCII码值为48，即，如果一个char类型变量，其存储空间所存值等于48时，说明这个变量存储的是字符‘0’。</p>
<p>3). ASCII码值0表示空字符（NULL）。如果一个char类型变量，其存储空间所存值为数值0时，并不意味着这个变量存储着字符’0’。相反，0值的char被C&#x2F;C++用于表示一个字符串的结尾。▲</p>
</blockquote>
<p>char类型事实上就是8比特的有符号整数。它有如下特性：</p>
<ul>
<li>当把一个字符赋值比如’c’赋值给一个char类型变量时，事实上存入该变量的是’c’字符的ASCII码值。</li>
<li>可以直接把整数赋值给char类型变量，也可以把一个char类型变量直接赋值给一个整数类型变量。</li>
<li>char类型变量可以作为一个整数参与加减乘除等数学运算。</li>
<li>当把char类型变量输出给cout或者替换printf( )中的占位符%c时，计算机会输出与变量内所存整数对应的ASCII码字符。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;ASCII code of &#x27;c&#x27;: &quot; &lt;&lt; (int)c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第12行：（int)c是C语言进行类型转换的格式，转换的目标类型置于对象&#x2F;值前方的括号中。这种转换形式存在错误转换的风险，较新的C++标准不建议这种转换形式。在Qt Creator中，我们可以看到IDE环境对该行代码给出了警告信息。此处，我们先将char类型的变量c转换为int，然后再交给cout进行输出得到’c’的ASCII码值99。如果直接把c输出给cout，则会在屏幕上得到输出字符c。</p>
<blockquote>
<p>注意：变量的类型转换并不会改变变量本身的类型。通常，编译器会创建一个用完即弃的目标类型的临时对象，并尽量让这个临时对象的值与原变量的值一致。第12行代码中的(int)c被执行后，c的类型仍为char，其值未变。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c += 1;</span><br></pre></td></tr></table></figure>

<p>第13行：c +&#x3D; 1使用了复合操作符（compound operator）+&#x3D;，其语法含义等价于c &#x3D; c + 1。该行执行后，c变量的“整数”值由99变为了100，第14行将c变量输出给cout，cout按照ASCII码对c变量进行解释输出，得到字符d。</p>
<p>表2- 美国标准信息交换代码表（ASCII）</p>
<p>【？缺表】</p>
<p>变量c的类型为char，实为signed char，其取值范围为-128 ~ +127。第16行试图给c赋值250，这显然超出了signed char类型的储值范围，这种情况我们称之为<strong>溢出</strong>。当溢出发生时，程序会错误解读变量的值，从17行代码的输出结果看，250的正值被解读为-6。程序员在编程时，应注意避免溢出。庆幸的是，现代计算机的内存资源已相对宽松，本书的读者大概用不着跟二十年前的前辈一样在内存的使用上锱铢必较了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;signed char with value 250: &quot; &lt;&lt; int(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第17行：int(c)达成了与第12行类似的变量类型转换效果，这种语法形式类似于面向对象中的构造函数▲。类似地，如果要把变量c转换为浮点数，相应代码为float(c)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char uc = 250;</span><br><span class="line">cout &lt;&lt; &quot;unsigned char with value 250: &quot; &lt;&lt; int(uc) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 20行：代码及其输出结果证明了一个unsigned char类型的对象，能够存储和正确处理整数250。</p>
<h4 id="2-3-2-整数类型"><a href="#2-3-2-整数类型" class="headerlink" title="2.3.2 整数类型"></a>2.3.2 整数类型</h4><p>short, int, long, long long都是整数类型，其区别仅在于存储空间的字节数，以及由此导致的储值范围的差异。详情请回顾表2- 及表2- 。</p>
<p>下面以int类型为例，说明全部整数类型的存储结构。如图2- 所示，一个int类型的对象由相邻的4个字节组成，每个字节8比特，共32比特。其中，第0位为最低位，第31位为最高位。这32比特以二进制补码▲形式存储一个整数。由于需要使用大约1个比特来表示整数的正负，有符号整数（signed int）的储值范围为-231 ~ +231-1；无符号整数（unsigned int）的储值范围为0 ~ 232-1。</p>
<p><img src="http://codelearn.club/images/image-20200210152654710.png" alt="image-20200210152654710"></p>
<p>图2- int类型的存储结构</p>
<p>类似地，short, long, long long类型默认为有符号类型，可以存储正整数及负整数；在类型名前加一个unsigned，如unsigned short，即为对应的无符号类型，仅可存储非负值。</p>
<p>【？选哪种整型】</p>
<blockquote>
<p><strong>扩展阅读📕</strong> 要彻底理解有符号类型与无符号类型在储值范围上的差异，以及当溢出发生时，到底发生了什么，需要首先弄明白整数的二进制编码，特别是补码的编码格式。【？缺】</p>
</blockquote>
<h4 id="2-3-3-浮点数类型"><a href="#2-3-3-浮点数类型" class="headerlink" title="2.3.3 浮点数类型"></a>2.3.3 浮点数类型</h4><p>浮点数就是所谓的小数，一个float类型的对象占据4个字节共32比特。这32个比特以类似于科学计数法的形式来表达一个浮点数，按照IEEE 754标准，其数学表示为：<br>±M×2E±M×2E<br>如图2- 所示，最高的1位(第31位）用做符号位，接着的 8 位(第23-30位）是指数E，剩下的 23 位（第0-22位）为有效数字 M。</p>
<p><img src="http://codelearn.club/images/image-20200210192421748.png" alt="image-20200210192421748"></p>
<p>图2- float的存储结构</p>
<p>相对于float，double类型使用8个字节来存储一个浮点数，它的储值范围以及精度都会高一些。习惯上，我们称float为<strong>单精度浮点数</strong>，double为<strong>双精度浮点数</strong>。所有的浮点数类型都是有符号的。</p>
<p>受限于有效数字的位数，浮点数的精度受到限制，会存在微小的误差。为了观察float与double的精度差异及其存储误差，我们创建一个Plain C Application，并修改main.c如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - FloatError</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float f = 0.00001;</span><br><span class="line">    printf(&quot;The stored value of 0.00001 with float:   %.30f\n&quot;,f);</span><br><span class="line"></span><br><span class="line">    double d = 0.00001;</span><br><span class="line">    printf(&quot;The stored value of 0.00001 with double:   %.30f\n&quot;,d);</span><br><span class="line"></span><br><span class="line">    if (f==0.00001)</span><br><span class="line">        printf(&quot;f == 0.00001&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;f &lt;&gt; 0.00001&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The stored value of 0.00001 with float:   0.000009999999747378751600000000</span><br><span class="line">The stored value of 0.00001 with double:   0.000010000000000000001000000000</span><br><span class="line">f &lt;&gt; 0.00001</span><br></pre></td></tr></table></figure>

<p>代码第6，9行的输出结果表明，0.00001存储至浮点数内，均有微弱误差，但double双精度浮点数的误差显然比float要小。</p>
<p>第11~14行是后面章节要讨论的条件分支语句▲，可以简单理解为如果… 则… 否则… 。当11行括号内的条件判断成立时，执行第12行，否则，执行第14行。（f&#x3D;&#x3D;0.00001）中的&#x3D;&#x3D;号用于判断两端的值是否相等，如果相等，表示逻辑真，否则为逻辑假。从执行结果可以看出，由于存储误差的原因，上述相等判断被认为是假的，第14行代码被执行。</p>
<blockquote>
<p>注意：一般不要对浮点数进行逻辑相等判断，误差的存在会导致意料之外的结果。</p>
</blockquote>
<h4 id="2-3-4-布尔类型"><a href="#2-3-4-布尔类型" class="headerlink" title="2.3.4 布尔类型"></a>2.3.4 布尔类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool b = 3 &lt; 2;</span><br></pre></td></tr></table></figure>

<p>3 &lt; 2显然不成立，这种不成立的结果逻辑上称为假(false)。这个值被赋值给了变量b， b的类型为布尔型<strong>【C++】</strong>，值为false。相对于假，表示一个命题成立或者正确的值称为真(true)。布尔型只有true和false两个取值。一个布尔类型的对象仅占据1个字节的空间。</p>
<p>C语言没有提供bool类型。在一些C语言开发包里，常见于各种单片机的C语言开发包，可以看到如下代码▲，这些代码通过int类型来模拟布尔型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef int BOOL;</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br></pre></td></tr></table></figure>

<p>为更好地理解bool型，我们创建一个Plain C++ Application，并将main.cpp修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - BoolType</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    bool a = 3 &gt; 2;</span><br><span class="line">    bool b = false;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;value of a: &quot; &lt;&lt; a &lt;&lt; &quot;,value of b: &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;int(true): &quot; &lt;&lt; int(true) &lt;&lt; &quot;,int(false): &quot; &lt;&lt; int(false) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (-0.00000012)</span><br><span class="line">        cout &lt;&lt; &quot;-0.00000012 is true.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    if (2*2-4)</span><br><span class="line">        cout &lt;&lt; &quot;2*2-4 is true.&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;2*2-4 is false.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value of a: 1,value of b: 0</span><br><span class="line">int(true): 1,int(false): 0</span><br><span class="line">-0.00000012 is true.</span><br><span class="line">2*2-4 is false.</span><br></pre></td></tr></table></figure>

<p>显而易见，a被赋值为true，b为false。从第9行代码的输出结果可以看到，当a被输出给cout时，得到1，b被输出给cout时，得到0。第10行代码中的int(true)将bool型的true值转换成整数，int(false)则将bool型的false值转换成整数，同样，从输出结果可以看到，true对应整数1， false对应整数0。</p>
<p>第12，15行分别将一个浮点数和一个整数当成布尔型看待，从输出结果看，-0.00000012作为逻辑判断其结果为真，2*2-4作为逻辑判断其结果为假。事实上，绝大多数编程语言都执行<strong>非零即真</strong>的原则，当一个值被视作布尔型时，只要该值不是0，就视为逻辑真。此处，-0.00000012不是0为真，2*2-4的计算结果是0为假。</p>
<h3 id="2-4-变量命名"><a href="#2-4-变量命名" class="headerlink" title="2.4 变量命名"></a>2.4 变量命名</h3><p>前述示例中的变量取名都是程序员决定的，当程序员给变量取名时，应符合下述规则：</p>
<table>
<thead>
<tr>
<th>变量的命名规则</th>
</tr>
</thead>
<tbody><tr>
<td>- 变量名只能包含字母、数字和下划线，且不能以数字打头；</td>
</tr>
<tr>
<td>- 变量名不能包括空格；</td>
</tr>
<tr>
<td>- 不能将C&#x2F;C++关键字和函数名用作变量名；</td>
</tr>
<tr>
<td>- 慎用小写字母l和大写字母O, 容易看成数字1和数字0；</td>
</tr>
<tr>
<td>- C&#x2F;C++的命名是大小写敏感的，也就是说cat跟Cat对于编译器而言，是两个不同的名字。</td>
</tr>
</tbody></table>
<p>下表列举了一示变量命名的示例：</p>
<table>
<thead>
<tr>
<th>娈量名举例</th>
<th>评价</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>iCount，sStudentNo, fPrice</td>
<td>正确并且好的命名</td>
<td>√</td>
</tr>
<tr>
<td>A9, _a678, U2_1</td>
<td>正确但不好的命名，不具备恰当的描述性</td>
<td>×</td>
</tr>
<tr>
<td>9B</td>
<td>错误，不能以数字开头</td>
<td>×</td>
</tr>
<tr>
<td>$y7</td>
<td>错误，以特殊符号开头</td>
<td>×</td>
</tr>
<tr>
<td>for, printf</td>
<td>错误，与关键字或者函数名冲突</td>
<td>×</td>
</tr>
<tr>
<td>MA U2</td>
<td>错误，包含空格</td>
<td>×</td>
</tr>
<tr>
<td>lO2</td>
<td>正确但不好的命名，字母l及字母O易被错误看成数字1和0</td>
<td>×</td>
</tr>
</tbody></table>
<p>符合语言命名规则的命名都是正确的，但正确并不等于好。本书配套网站总结了本书程序中的命名规则，读者可以在阅读完本书的大部分内容后再阅读。零基础的初学者，现在还无法理解其中的内容。</p>
<p>[To 编辑: 网络提供 <a target="_blank" rel="noopener" href="http://codelearn.club/2019/06/namemethod/]">http://codelearn.club/2019/06/namemethod/]</a></p>
<h3 id="2-5-字面量"><a href="#2-5-字面量" class="headerlink" title="2.5 字面量"></a>2.5 字面量</h3><p>所谓字面量（literal），就是在程序代码中显示给出的值，比如199，0.127，’c’等。</p>
<h4 id="2-5-1-整数"><a href="#2-5-1-整数" class="headerlink" title="2.5.1 整数"></a>2.5.1 整数</h4><p>整数字面量默认以十进制方式提供，程序员也可以使用十六进制、八进制和二进制方式提供整数字面量。请见下述C++代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - HexOct</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int b = 0x17;          //十六进制 hexadecimal</span><br><span class="line">    int c = 017;           //八进制   octal</span><br><span class="line">    int d = 0b01111110;    //二进制   binary</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;0x17 = &quot; &lt;&lt; b &lt;&lt; &quot;, 017 = &quot; &lt;&lt; c &lt;&lt; &quot;, 0b01111110 = &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    printf(&quot;17: %x, %d, %o\n&quot;, 17, 17, 17);</span><br><span class="line">    cout &lt;&lt; &quot;17: &quot; &lt;&lt; hex &lt;&lt; 17 &lt;&lt; &quot;, &quot; &lt;&lt; dec &lt;&lt; 17 &lt;&lt; &quot;, &quot; &lt;&lt; oct &lt;&lt; 17 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x17 = 23, 017 = 15, 0b01111110 = 126</span><br><span class="line">17: 11, 17, 21</span><br><span class="line">17: 11, 17, 21</span><br></pre></td></tr></table></figure>

<p>0x17表示十六进制的17，以数字0打头的017表示八进制的17，以0b开头的是二进制字面量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;0x17 = &quot; &lt;&lt; b &lt;&lt; &quot;, 017 = &quot; &lt;&lt; c &lt;&lt; &quot;, 0b01111110 = &quot; &lt;&lt; d &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第11行：输出结果证实，0x17对应十进制的23， 017对应十进制的15，0b01111110<strong>【C++ 14】</strong>对应十进制的126。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;17: %x, %d, %o\n&quot;, 17, 17, 17);</span><br></pre></td></tr></table></figure>

<p>第12行：通过占位符，将十进制的整数17分别以十六进制、十进制、八进制形式输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;17: &quot; &lt;&lt; hex &lt;&lt; 17 &lt;&lt; &quot;, &quot; &lt;&lt; dec &lt;&lt; 17 &lt;&lt; &quot;, &quot; &lt;&lt; oct &lt;&lt; 17 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第13行通过cout实现与第12行类似的功能。下述代码并不会在屏幕上显示任何内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; hex;</span><br></pre></td></tr></table></figure>

<p>事实上，标识符（identifier）hex在iostream头文件中定义，上述代码相当于改变了cout的内部状态，使得cout在接下来的整数输出当中会使用十六进制格式。同理，dec指示cout以十进制形式输出整数，oct指示cout以八进制形式输出整数。</p>
<blockquote>
<p>注意：代码以及输出内容中的进制，只是一种表达和解释数据的方式。事实上，数据在计算机存储器中的存储，永远是二进制的。</p>
</blockquote>
<p><strong>调整C++版本</strong></p>
<hr>
<p>需要注意的是，二进制形式的整数字面量是C++ 14版本引入的新特性，而默认创建的Qt Creator项目默认执行C++ 11标准。所以，读者可能会在Qt Creator中看到对第9行代码的警告甚至是报错。此处，可以点开HexOct.pro项目文件，将其第2行中的c++11改为c++17即可解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE = app</span><br><span class="line">CONFIG += console c++17</span><br><span class="line">CONFIG -= app_bundle</span><br><span class="line">CONFIG -= qt</span><br><span class="line"></span><br><span class="line">SOURCES += \</span><br><span class="line">        main.cpp</span><br></pre></td></tr></table></figure>

<p>对于整数字面量，还可以在末尾添加下述后缀来表明其类型，见下表：</p>
<p>表2- 整数字面量的后缀</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>l, L</td>
<td>long类型</td>
<td>512l, 512L</td>
</tr>
<tr>
<td>u, U</td>
<td>unsigned int类型</td>
<td>1230u, 82882U</td>
</tr>
<tr>
<td>ul, UL</td>
<td>unsigned long类型</td>
<td>1230ul， 82882UL</td>
</tr>
<tr>
<td>ll, LL<strong>【C++ 11】</strong></td>
<td>long long类型</td>
<td>8282ll, 2828LL</td>
</tr>
<tr>
<td>ull, Ull, uLL, ULL<strong>【C++ 11】</strong></td>
<td>unsigned long long类型</td>
<td>9272733ULL</td>
</tr>
</tbody></table>
<p>正如读者看到的那样，小写字母l很容易与整数1混淆。我们建议在使用后缀标识整数字面量类型时，使用大写字母L。</p>
<h4 id="2-5-2-字符及字符串"><a href="#2-5-2-字符及字符串" class="headerlink" title="2.5.2 字符及字符串"></a>2.5.2 字符及字符串</h4><p>单个字符的字面量用单引号包裹（示例如下），由多个字符所构成的字符串字面量用双引号包裹。</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>ASCII码值</th>
<th>含义</th>
<th>字面量</th>
<th>ASCII码值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>‘D’</td>
<td>68</td>
<td>大写字母D</td>
<td>‘d’</td>
<td>100</td>
<td>小写字母d</td>
</tr>
<tr>
<td>‘0’</td>
<td>48</td>
<td>阿拉伯数字0</td>
<td>‘ ’</td>
<td>32</td>
<td>空格</td>
</tr>
<tr>
<td>‘?’</td>
<td>63</td>
<td>问号?</td>
<td>‘@’</td>
<td>64</td>
<td>@符号</td>
</tr>
</tbody></table>
<p>但计算机里存在这样一符特殊符号，难以在字面量中表达。比如下述单引号和双引号，由于其同时具备语法意义，编译器在编译时无法区分它是语法符号还是字面量的构成部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;                       //单引号字符，存在语法歧义</span><br><span class="line">&quot;&quot;C/C++ is terrible.&quot;&quot;    //包含双引号的字符串，存在语法歧义</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题，C&#x2F;C++引入了转义字符（escape sequence），如下表所示：</p>
<p>表2- C&#x2F;C++转义字符</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>ASCII码</th>
<th>说明</th>
<th>转义字符</th>
<th>ASCII码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>10</td>
<td>换行符</td>
<td>\t</td>
<td>9</td>
<td>水平制表符Tab</td>
</tr>
<tr>
<td>\v</td>
<td>11</td>
<td>垂直制表符</td>
<td>\b</td>
<td>8</td>
<td>回退删除符（backspace）</td>
</tr>
<tr>
<td>\r</td>
<td>13</td>
<td>返回行首</td>
<td>\a</td>
<td>7</td>
<td>发生警告声</td>
</tr>
<tr>
<td>\</td>
<td>92</td>
<td>右斜杠</td>
<td>\‘</td>
<td>39</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>34</td>
<td>双引号</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下述C++程序部分展示了上述转义字符的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Project - CharLiteral</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;I told you, \&quot;C/C++ is hard to learn\&quot;.&quot; &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    cout &lt;&lt; &quot;When you need a \\ in string, put \\\\ in your code.&quot; &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;Popular languages:\n\tJavaScript\n\tPython\n\tJava\n\tC\n\tC++\n\tRuby&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I told you, &quot;C/C++ is hard to learn&quot;.</span><br><span class="line">When you need a \ in string, put \\ in your code.</span><br><span class="line">Popular languages:</span><br><span class="line">        JavaScript</span><br><span class="line">        Python</span><br><span class="line">        Java</span><br><span class="line">        C</span><br><span class="line">        C++</span><br><span class="line">        Ruby</span><br></pre></td></tr></table></figure>

<p>上述代码及其输出结果证实，\“生成了字面量内部的一个双引号；\ 生成了字面量内部的一个右斜杠；’\n’以及“\n”输出给cout都可以获得类似于endl相同的换行效果； \t构成了大概8个空格（部分平台上可能是4个空格）的间距，直观上达到了将输出内容象表格一样对齐的目的，故得名“制表符”。</p>
<p>下述代码中的前缀R表明字符串字面量是<strong>生字符串（raw string）【C++ 11】</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = R&quot;(I told you, &quot;C/C++&quot; is hard to learn, \n means a new line.)&quot;;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>将上述代码置入一个C++的main( )函数中，其输出结果应为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I told you, &quot;C/C++&quot; is hard to learn, \n means a new line.</span><br></pre></td></tr></table></figure>

<p>可以看出，一个生字符串以R”(开头，以)”结尾。两者之中的部分全部为字符串的直接构成部分，其中的转义字符不转义。上述字符串s，等价于下述字面量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;I told you, \&quot;C/C++\&quot; is hard to learn, \\n means a new line.&quot;;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-浮点数"><a href="#2-5-3-浮点数" class="headerlink" title="2.5.3 浮点数"></a>2.5.3 浮点数</h4><p>除了3.14这种形式的传统小数写法外，也可以使用科学计数法来表达浮点数。此外，通过给浮点数字面量增加恰当的后缀，可以指定字面量的类型。请见下述C++代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - FloatIteral</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    auto a = 3;            //int</span><br><span class="line">    auto b &#123;3.0&#125;;          //double</span><br><span class="line">    auto c = 1.2E-5;       //double</span><br><span class="line">    auto d = 1.2E+5L;      //long double</span><br><span class="line">    auto e = -3.01e+12f;   //float</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Name:\ta\tb\tc\td\te\n&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;Type:\t&quot; &lt;&lt; typeid(a).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(b).name() &lt;&lt; &quot;\t&quot;</span><br><span class="line">         &lt;&lt; typeid(c).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(d).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(e).name();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name:   a       b       c       d       e</span><br><span class="line">Type:   i       d       d       e       f</span><br></pre></td></tr></table></figure>

<p>auto【C++ 11】指示编译器根据后方初始值的类型来推断变量的类型，即上述变量a，b，c，d，e的类型均与后方字面量的类型相同。</p>
<p>同sizeof( )一样，typeid( )也是一个操作符。typeid(a)返回一个类型为type_info▲的对象，该对象包含了变量a的类型信息。执行该对象的name( )成员函数▲可以获得a的类型名称字符串（简写形式）。</p>
<p>从输出结果可以看出，第6行的字面量3被编译器认为是int类型（简写为i）。第7行的3.0被编译器认为是double类型（简写为d）。 第8~10行使用了科学计数法，1.2E-5等价于1.2 x 10-5，-3.01e+12等价于-3.01x1012。当使用科学计数法时，e和E通用。此外，还可以通过在浮点数字面量后添加后缀来指明浮点数类型，其中，f或F为float类型（简写为f），l或L为long double类型（简写为e），当没有后缀时，为double类型。上述程序所用到的字面量列表如下。</p>
<p>表2- 浮点数字面量示例</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>说明</th>
<th>字面量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>int类型，简写为i</td>
<td>3.0</td>
<td>double类型，简写为d</td>
</tr>
<tr>
<td>1.2E-5</td>
<td>double类型，简写为d，等价于1.2x10-5</td>
<td>1.2E+5L</td>
<td>long double类型，简写为e，等价于1.2x105</td>
</tr>
<tr>
<td>-3.01e+12f</td>
<td>float类型，简写为f，等价于-3.01x1012</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>由于小写字母l不易正确识别，当使用long double类型的字面量时，作者总是使用L。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;Type:\t&quot; &lt;&lt; typeid(a).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(b).name() &lt;&lt; &quot;\t&quot;</span><br><span class="line">     &lt;&lt; typeid(c).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(d).name() &lt;&lt; &quot;\t&quot; &lt;&lt; typeid(e).name();</span><br></pre></td></tr></table></figure>

<p>第14行：事实上是第13行的后半部分，为了阅读和印刷方便分成了两行，在语法意义上与合为一行没有区别。</p>
<h3 id="微实践-鸡兔同笼"><a href="#微实践-鸡兔同笼" class="headerlink" title="微实践 - 鸡兔同笼"></a>微实践 - 鸡兔同笼</h3><p>鸡兔同笼是中国古代的数学名题之一。大约在1500年前，《孙子算经》中就记载了这个有趣的问题。书中是这样叙述的：<br>​ 今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何？<br>这四句话的意思是：有若干只鸡兔同在一个笼子里，从上面数，有35个头，从下面数，有94只脚。问笼中各有多少只鸡和兔？</p>
<p>首先分析下鸡兔同笼问题，一只鸡有一个头和两只脚，一只兔有一个头和四只脚。假定笼中全部是鸡，每个头对应两只脚，35个头对应70只脚。但总共有94只脚，多出脚的原因是因为有一部分是兔子，多余的脚就是兔子的另外两只脚，只需要将剩余的脚除以2就可以得到兔子的数量。有了兔子的数量就可以计算得到鸡的数量。</p>
<p>解决本问题的C语言代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Project - ChickenRabbit</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int iHeads = 35;            //变量 - 头的数量</span><br><span class="line">    int iFeet = 94;             //变量 - 脚的数量</span><br><span class="line">    int a = iFeet - 2 * iHeads; //假设全部是鸡，余下的脚的数量</span><br><span class="line">    int iRabbits = a / 2;       //免的数量等于余下的脚数/2</span><br><span class="line">    int iChicken = iHeads - iRabbits; //鸡的数量等于 头的数量 - 兔的数量</span><br><span class="line">    printf(&quot;Number of chicken = %d, Number of rabbits = %d.\n&quot;, iChicken, iRabbits);</span><br><span class="line"></span><br><span class="line">    if (iFeet == iChicken*2+iRabbits*4)  //验证脚数 = 鸡数*2 + 兔数*4</span><br><span class="line">        printf(&quot;The answer is right.&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;The answer is wrong.&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number of chicken = 23, Number of rabbits = 12.</span><br><span class="line">The answer is right.</span><br></pre></td></tr></table></figure>

<p>第8行的&#x2F;号是除法运算符，将整数a除以整数2，虽然理论上有除不尽的可能，但除法运算的结果仍然是整数，这跟Python语言不同。所以，第8行等号左端的变量与右端的运算结果的类型都是int。C&#x2F;C++的这种处理方式有助于提高目标代码的执行效率。这里的目标代码可理解为编译器编译出来的二进制机器指令。</p>
<p>第12行代码进行验算, &#x3D;&#x3D;操作符判断两边的数字是否相等，返回一个布尔型。从输出结果可以看到，验算通过，答案是正确的。</p>
<h2 id="3-语法基础"><a href="#3-语法基础" class="headerlink" title="3. 语法基础"></a>3. 语法基础</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="3-1-源代码格式"><a href="#3-1-源代码格式" class="headerlink" title="3.1 源代码格式"></a>3.1 源代码格式</h3><p>下述C&#x2F;C++代码完全”正确“：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  int</span><br><span class="line">      main</span><br><span class="line">() &#123; printf(&quot;Working codes, but in chaos.&quot;); return 0</span><br><span class="line">                  ;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>

<p>区别于Python的严格缩进语法，C&#x2F;C++对语法格式的要求极低。上述程序虽然能够得到正确的执行结果，但在视觉上十分丑陋，不利于代码的维护和阅读。因此，强烈建议读者在程序设计过程中使用与本书代码类似的组织风格，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    printf(&quot;Working codes, but in chaos.&quot;); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，为了节约纸张，作者经常会把第4行的{上移至main()的后方。同时，为了在视觉上更好地分隔代码块，比如将一个工作过程的几个步骤分隔开，作者会添加一些空行。调整后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line"></span><br><span class="line">int main() &#123; </span><br><span class="line">    printf(&quot;Working codes, but in chaos.&quot;); </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的第4行向右缩进了4个空格。书写代码时，如果需要向右缩进行，按Tab键比空格键更高效。幸运的是，大多数现代的集成开发环境都会帮助编码者缩进和优化代码显示，编码者只要不”主动“破坏，代码排列不太可能很差。</p>
<h3 id="3-2-源代码符号"><a href="#3-2-源代码符号" class="headerlink" title="3.2 源代码符号"></a>3.2 源代码符号</h3><p>请找出下述C语言代码的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iNumber = 3;</span><br><span class="line">    printf(&quot;There are %d stars surrounding three body planet.”, inumber）;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述错误有至少三个错误：</p>
<ul>
<li>第5行的变量名inumber与第4行的变量名iNumber不一致；</li>
<li>第5行最右端的括号是中文全角的括号，不是英文括号；</li>
<li>printf( )的参数字符中右方的双引号是中文的双引号，不是英文双引号。</li>
</ul>
<p>为了让读者看得更清楚，作者把修改正确的代码列在下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iNumber = 3;   //&quot; vs ”     )  vs ）</span><br><span class="line">    printf(&quot;There are %d stars surrounding three body planet.&quot;, iNumber);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意第4行的注释，在某些特定字体下，中文符号与英文符号很难用肉眼区分。除了注释和字符串字面量内容内部，C&#x2F;C++代码不允许使用中文以及中文符号，对于初学者，建议刚开始练习时关闭中文输入法，以免意外录入中文符号。</p>
<blockquote>
<p>提示： 程序设计是严谨的科学，任何微小的错误或者疏忽都可能导致失败。</p>
</blockquote>
<h3 id="3-3-操作符"><a href="#3-3-操作符" class="headerlink" title="3.3 操作符"></a>3.3 操作符</h3><h4 id="3-3-1-复合操作符"><a href="#3-3-1-复合操作符" class="headerlink" title="3.3.1 复合操作符"></a>3.3.1 复合操作符</h4><p>在编程中，我们常用+、-、<em>、&#x2F;来分别执行加、减、乘、除数学运算，用&#x3D;来执行赋值操作。下述C++示例中的第6~7行代码运用了+及&#x3D;运算符。若期望在进行数学运算的同时也进行赋值操作，可用复合运算符+&#x3D;、-&#x3D;、</em>&#x3D;、&#x2F;&#x3D;来实现，如下述示例中的第11行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - CompoundOperator</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 3;</span><br><span class="line">    a = a + 2;</span><br><span class="line">    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int b = 3;</span><br><span class="line">    b += 2;       //复合运算符，等价于b = b + 2</span><br><span class="line">    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">b = 5</span><br></pre></td></tr></table></figure>

<p>不难看出，b +&#x3D; 2 就是b &#x3D; b + 2的简写形式；该行执行前，b值为3，b +&#x3D; 2先从b取得值3，然后把3与2相加，结果为5，接下来把5赋值给b。</p>
<p>同理，b -&#x3D; 2等价于b &#x3D; b - 2；b *&#x3D; 2等价于b &#x3D; b * 2; b &#x2F;&#x3D; 2等价于b &#x3D; b &#x2F; 2。</p>
<h4 id="3-3-2-求模操作符"><a href="#3-3-2-求模操作符" class="headerlink" title="3.3.2 求模操作符"></a>3.3.2 求模操作符</h4><p>a % b称为a对b求模（modulus），简言之就是求a除以b的余数。下述C程序演示了求模操作符的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Project - Modulus</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = a % 7;</span><br><span class="line">    printf(&quot;%d is an %s number.&quot;, b, b%2==0?&quot;even&quot;:&quot;odd&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 is an odd number.</span><br></pre></td></tr></table></figure>

<p>可以看到，10 % 7，即10除以7的余数为3。通过求模运算，可以判断一个数是否能被另一个数整除。b % 2的结果如果是0，说明b能被2整数，它是一个偶数，否则为奇数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b%2==0?&quot;even&quot;:&quot;odd&quot;</span><br></pre></td></tr></table></figure>

<p>这是一个条件表达式（conditional expression），其格式为a?b:c，其中，a一般为一个逻辑判断。当a为真时，表达式返回b做为结果，否则返回c。在上述程序中，b%2&#x3D;&#x3D;0为假，故该条件表达式的结果为”odd”，该结果字符串在输出结果中替换了占位符%s。</p>
<p>下述代码中的retired变量将被赋值为1，因为a &gt;&#x3D; 60成立，条件表达式取冒号左边的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age = 63;</span><br><span class="line">int retired = age &gt;= 60 ? 1: 0;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-比较与逻辑"><a href="#3-3-3-比较与逻辑" class="headerlink" title="3.3.3 比较与逻辑"></a>3.3.3 比较与逻辑</h4><p>下述C++程序展示了C&#x2F;C++中的比较及逻辑运算符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - CompLogic</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    cout &lt;&lt; &quot;a&gt;5: &quot; &lt;&lt; (a&gt;5) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a&lt;20 and a&gt;=10: &quot; &lt;&lt; (a&lt;20 &amp;&amp; a&gt;=10) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a==9: &quot; &lt;&lt; (a==9) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a!=3: &quot; &lt;&lt; (a!=3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a&gt;100 or a&lt;20: &quot; &lt;&lt; (a&gt;100 || a&lt;20) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;not a&gt;=10: &quot; &lt;&lt; (!(a&gt;=10)) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&gt;5: 1</span><br><span class="line">a&lt;20 and a&gt;=10: 1</span><br><span class="line">a==9: 0</span><br><span class="line">a!=3: 1</span><br><span class="line">a&gt;100 or a&lt;20: 1</span><br><span class="line">not a&gt;=10: 0</span><br></pre></td></tr></table></figure>

<p>上述代码中的&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;与我们在小学数学中所学的用法相同。a&gt;5成立时，该表达式的值为true，否则为false。!&#x3D;是&#x3D;&#x3D;的反操作符，用于判断左右两端的值是否相等，不相等时返回true，否则返回false。第10行中的a!&#x3D;3成立，返回true。当把布尔型的值输出给cout时，true被转换成1，false被转换成0。所以，输出结果中的1表示true，0表示false。</p>
<p>上述代码中的逻辑表达式，例如a&#x3D;&#x3D;9，都用( )括号包裹起来了，括号用于确保括号内的表达式先进行计算，得到结果后再通过&lt;&lt;操作符输出给cout。</p>
<p>上述代码中还应用到下述逻辑运算符，列表如下：</p>
<p>表3- 逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑与，第8行中a&lt;20为真，a&gt;&#x3D;10也为真，逻辑与的结果为真</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或，第11行中a&gt;100为假，a&lt;20为真，逻辑或的结果为真</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非，第12行中，a&gt;&#x3D;10为真，逻辑非的结果为假</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：逻辑与是&amp;&amp;，逻辑或是||，不是&amp;或者|。单个的&amp;和|符号在C&#x2F;C++语言中具有完全不同的用途。</p>
</blockquote>
<p>【? 缺 布尔运算的短路】</p>
<h4 id="3-3-5-赋值操作符"><a href="#3-3-5-赋值操作符" class="headerlink" title="3.3.5 赋值操作符"></a>3.3.5 赋值操作符</h4><p>a &#x3D; 3中的赋值（assignment）操作符除了将3传递给变量a之外，还有其它额外功能。请先看下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - Assignment</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    a = b = 3;</span><br><span class="line">    printf(&quot;a = %d, b = %d.\n&quot;,a,b);</span><br><span class="line"></span><br><span class="line">    if (a=4)</span><br><span class="line">        printf(&quot;a is equal to 4.&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;a is not equal to 4.&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 3, b = 3.</span><br><span class="line">a is equal to 4.</span><br></pre></td></tr></table></figure>

<p>第6行a &#x3D; b &#x3D; 3的执行过程如下：</p>
<ul>
<li>b &#x3D; 3是一个表达式，该表达式中的赋值操作符将3赋值给变量b，同时返回整数3作为表达式的值。</li>
<li>a &#x3D; b &#x3D; 3也是一个表达式，子表达式 b &#x3D; 3 的值作为右值（right value）被第1个赋值操作符赋值给变量a。</li>
</ul>
<p>第9 ~ 12行代码的本意是判断变量b是否等于4。显然，b的值为3，代码预期应输出”a is not equal to 4.”，但实际的输出结果却是”a is equal to 4.”。问题出现在第9行，判断两个值是否相等，应使用双等号，即(a &#x3D;&#x3D; 4)。(a&#x3D;4)对于编译器而言，是完全正确的表达。这个表达式除了将4赋值给变量a之外，还会返回整数4作为表达式的值。对于if条件语句，非零即真，因此，（a&#x3D;4）被视为逻辑真，第10行代码被执行。</p>
<blockquote>
<p>说明：类似于上述代码第9行的错误很多初学者都犯过。在早期的编译器里，上述代码被“愉快”接受。可能是意识到第9行的写法多半是个错误，作者注意到mingw编译器会在第9行代码处给出一个警告。</p>
</blockquote>
<h4 id="3-3-6-递增与递减"><a href="#3-3-6-递增与递减" class="headerlink" title="3.3.6 递增与递减"></a>3.3.6 递增与递减</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br></pre></td></tr></table></figure>

<p>此行代码中的++称为递增操作符，它完成两项任务（假设该行执行前a值为10）：</p>
<ul>
<li>将变量a的值增加1，该行代码执行后，a值变为11；</li>
<li>作为一个表达式，它返回a被递增之前的值，即10，作为表达式的值。</li>
</ul>
<p>这种置于变量之后的++操作符的执行过程可以总结为：<strong>先取值，后递增</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++a;</span><br></pre></td></tr></table></figure>

<p>此行代码中的++也是递增操作符，区别是它位于变量名之前。它也完成两项任务（假设该行执行前a值为10）：</p>
<ul>
<li>将变量a的值增加1，该行代码执行后，a值变为11；</li>
<li>作为一个表达式，它返回a被递增之后的值，即11，作为表达式的值。</li>
</ul>
<p>这种置于变量之前的++操作符的执行过程可以总结为：<strong>先递增，后取值</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a--;  --a;</span><br></pre></td></tr></table></figure>

<p>同理，上述代码中的–为递减操作符，它们都将a的值减1，同时作为表达式返回一个值。区别在于，前者是<strong>先取值，后递减</strong>，后者是<strong>先递减，后取值</strong>。</p>
<p>下述C程序演示了递增及递减操作符的应用，请留意代码中的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - IncDec</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 10, b, c;</span><br><span class="line">    b = a++;    //先取值，后递增，a改为11，b得递增之前的值10</span><br><span class="line">    c = ++a;    //先递增，后取值，a改为12，c得递增之后的值12</span><br><span class="line">    printf(&quot;a = %d, b = %d, c = %d.\n&quot;,a,b,c);</span><br><span class="line"></span><br><span class="line">    float f = 10.1f, g, h;</span><br><span class="line">    g = f--;    //先取值，后递减</span><br><span class="line">    h = --f;    //先递减，后取值</span><br><span class="line">    printf(&quot;f = %f, g = %f, h = %f.&quot;,f,g,h);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 12, b = 10, c = 12.</span><br><span class="line">f = 8.100000, g = 10.100000, h = 8.100000.</span><br></pre></td></tr></table></figure>

<p>上述代码及执行结果证实，除整数外，浮点数也可以进行递增及递减操作，效果相同。</p>
<blockquote>
<p>注意：当对一个指针▲类型的对象使用递增或递减操作符时，其含义与本节的描述有显著差异。细节在后续章节中讨论。</p>
</blockquote>
<p>多年的实践证明，递增和递减操作符的不恰当使用是诸多软件缺陷的来源。在那些新的编程语言比如Python里，不提供递增及递减操作符。下述C语言代码在不同的编译器里可能会有不同的执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Project - AmbiguousIncDec</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n = 4;</span><br><span class="line">    printf(&quot;%d - %d\n&quot;,n,n*n++);</span><br><span class="line"></span><br><span class="line">    n = 5;</span><br><span class="line">    printf(&quot;%d&quot;,n/2+5*(1+n++));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码在作者机器（Qt Creator 4.11.0, mingw 7.3.0 64 bit）上的运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 - 20</span><br><span class="line">32</span><br><span class="line">printf(&quot;%d - %d\n&quot;,n,n*n++);</span><br></pre></td></tr></table></figure>

<p>第6行：printf( )函数有三个参数，其中，参数2和参数3都使用到了n。由于C语言标准并没有规定先从参数2还是先从参数3取值，所以，不同编译器允许有不同的实现。显而易见， 先从参数3取值，再从参数2取值时，得到的n将会是加1递增之后的，反之则不同。此外，n * n++ 以<em>号作分隔，可以分成两个部分。对a * b的乘法运算本身而言，先算a还是先算b是没有区别的。本例中，编译器可以先取*号的左操作数n，也可以先取</em>号的右操作数n++，如果先取后者，则前者将取得n加1递增之后的值，反之则不同。</p>
<p>在作者的机器上，第6行代码中printf( )函数先从参数3取值。n * n++的表达式里，先取<em>号的右操作数n++，由于是先取值，后递增，故得值4；然后，再取</em>号的左操作数n，由于此时n已经递增，故得值5；5 * 4得到结果20。接下来，printf( )函数从参数2取值，此时n已经递增，故得值5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d&quot;,n/2+5*(1+n++));</span><br></pre></td></tr></table></figure>

<p>第9行：同理，表达式n&#x2F;2+5*(1+n++)以+号作分隔，也可以分成两个部分。+号的左操作数先取值，还是右操作数先取值，取决于编译器的具体实现。现在请读者根据输出结果32反推一下该表达式的计算顺序。</p>
<p>上述程序的执行结果的不确定使得程序不能容易地移植。而且，编译器版本的升级也可能会改变程序的执行结果。毕竟，编译器只要符合C&#x2F;C++的标准，就是“合法”的，而C&#x2F;C++的标准没有对上述计算顺序作出确切规定。</p>
<p>请读者遵从如下规则以避免上述问题：</p>
<ul>
<li>一次函数调用的多个参数中出现了同一个变量，则不要对该变量应用递增或递减操作符；</li>
<li>一个表达式中同一个变量出现多于一次，则不要对该变量应用递增或递减操作符。</li>
</ul>
<blockquote>
<p><strong>⚠</strong> 即便读者对C&#x2F;C++的标准烂熟于胸，也要尽量避免在实际编程中不必要地使用“技巧”。因为避免掉下悬崖的最好办法不是练习高超的平衡术，而是远离悬崖。</p>
</blockquote>
<h4 id="3-3-7-逗号操作符"><a href="#3-3-7-逗号操作符" class="headerlink" title="3.3.7 逗号操作符"></a>3.3.7 逗号操作符</h4><p>现在讨论逗号操作符为时尚早，详见4.3.1节。</p>
<h3 id="3-4-运算优先级"><a href="#3-4-运算优先级" class="headerlink" title="3.4 运算优先级"></a>3.4 运算优先级</h3><p>在同一个表达式里，经常存在多个运算符。此时，运算的最终结果与运算符的顺序有关。请看如下C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - Precedence</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n = 3 + 2 * 6 / 3;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line"></span><br><span class="line">    n = (3 + 2) * 6 / 3;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>C&#x2F;C++中四则混合运算依然遵循<strong>先乘除，后加减</strong>的规则，对于相同的优先级，例如乘法和除法，按从左往右的顺序执行。如果期望某些运算先执行，与数学中的方法类似，将这些运算用括号括起来即可，如上述代码中的第8行。</p>
<p>再考虑如下C语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - ChangePrecedence</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int r = 3 + 2 &amp;&amp; 0;</span><br><span class="line">    printf(&quot;3 + 2 &amp;&amp; 0 = %d\n&quot;,r);</span><br><span class="line"></span><br><span class="line">    r = (3 + 2) &amp;&amp; 0;</span><br><span class="line">    printf(&quot;(3 + 2) &amp;&amp; 0 = %d\n&quot;,r);</span><br><span class="line"></span><br><span class="line">    r = 3 + (2 &amp;&amp; 0);</span><br><span class="line">    printf(&quot;3 + (2 &amp;&amp; 0) = %d\n&quot;,r);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 + 2 &amp;&amp; 0 = 0</span><br><span class="line">(3 + 2) &amp;&amp; 0 = 0</span><br><span class="line">3 + (2 &amp;&amp; 0) = 3</span><br></pre></td></tr></table></figure>

<p>对于表达式 3 + 2 &amp;&amp; 0，其中有+及&amp;&amp;两个操作符。根据规定，+的优先级高于&amp;&amp;（逻辑与），故该表达式事实上等价于(3 + 2) &amp;&amp; 0。因此，第6行与第9行的输出结果相同。在该表达式中，3+2等5，逻辑与操作符将5和0作为左操作数及右操作数，5为真，0为假，结果为逻辑假。逻辑假替换printf( )中的占位符”%d”，被转换成整数输出，故结果为0。</p>
<p>对于表达式3 + (2 &amp;&amp; 0)，由于括号的存在， 2 &amp;&amp; 0先计算，2为真，0为假，2 &amp;&amp; 0为假。显然，编译器无法把整数3与逻辑假相加，所以编译器选择先将逻辑假转换成整数，其值为0，3 + 0等于3，故第12行的输出结果为3。</p>
<p>当读者读到3 + 2 &amp;&amp; 0时，多半是不知道+的优先级是高于&amp;&amp;的，作者也不知道。C&#x2F;C++有着数量众多的操作符，全部的操作符及其优先级可以列出一个长长的表格。试图记忆这些操作符的优先级是徒劳的，因为会忘。所以，本书选择不提供这个优先级列表，而是慎重建议：<strong>在凡是存在优先级疑惑的表达式里，使用括号消除疑惑</strong>。如上述代码的第8行及第11行。这样做，无论是写代码的还是读代码的，都放心。</p>
<h3 id="3-5-隐式类型转换"><a href="#3-5-隐式类型转换" class="headerlink" title="3.5 隐式类型转换"></a>3.5 隐式类型转换</h3><p>在下述三种情况下，C&#x2F;C++会进行隐式类型转换（implicit type cast）：</p>
<ul>
<li>变量初始化或者赋值时，值与变量的类型不同；</li>
<li>表达式中不同类型的变量&#x2F;值进行运算时；</li>
<li>函数参数传递▲时。</li>
</ul>
<h4 id="3-5-1-赋值-变量初始化"><a href="#3-5-1-赋值-变量初始化" class="headerlink" title="3.5.1 赋值&#x2F;变量初始化"></a>3.5.1 赋值&#x2F;变量初始化</h4><p>我们通过对下述C++程序及其执行结果的分析来解释赋值&#x2F;变量初始化时的隐式类型转换及其影响：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - AssignType</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    bool a = 3.0;            //转换为bool类型：0为false，非0为true</span><br><span class="line">    float b = -99999.2301;   //double转float，精度降低，可能超出储值范围</span><br><span class="line">    int c = b;               //float转int, 小数部分丢失，可能超出储值范围</span><br><span class="line">    unsigned int d = c;      //int转unsigned int，负值被错误解释</span><br><span class="line">    short e = d;             //unsigned int转short，可能超出储值范围</span><br><span class="line">    double f = b;            //float转double，安全</span><br><span class="line"></span><br><span class="line">    cout.setf(ios_base::fixed, ios_base::floatfield);</span><br><span class="line">    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;\nb = &quot; &lt;&lt; b &lt;&lt; &quot;\nc = &quot; &lt;&lt; c</span><br><span class="line">         &lt;&lt; &quot;\nd = &quot; &lt;&lt; d &lt;&lt; &quot;\ne = &quot; &lt;&lt; e &lt;&lt; &quot;\nf = &quot; &lt;&lt; f;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = -99999.226562</span><br><span class="line">c = -99999</span><br><span class="line">d = 4294867297</span><br><span class="line">e = 31073</span><br><span class="line">f = -99999.226562</span><br><span class="line">bool a = 3.0;            //转换为bool类型：0为false，非0为true</span><br></pre></td></tr></table></figure>

<p>第6行：任意值赋值给布尔型变量，按非零即真原则，0值转换为false, 非零转换为true。double类型的字面量3.0赋值给布尔类型的变量a，被转换成true。true输出给cout，结果为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float b = -99999.2301;   //double转float，精度降低，可能超出储值范围</span><br></pre></td></tr></table></figure>

<p>第7行：double转换为float时，可能发生精度损失。因为double类型对象由64个比特组成，而float类型只有32个比特。如果double类型的值超过float的储值范围，转换结果将是不确定的。本行进行了此类转换，可以看到转换后的float类型变量b丢失了精度（值不等于-99999.2301）。如果把b的类型改为double，将更可能保持精度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int c = b;               //float转int, 小数部分丢失，可能超出储值范围</span><br></pre></td></tr></table></figure>

<p>第8行：float转换为int时，小数部分丢失。当储值范围超出时，结果不确定。输出结果证实，这种转换只保留了整数部分-99999。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int d = c;      //int转unsigned int，负值被错误解释</span><br></pre></td></tr></table></figure>

<p>第9行：int（有符号）转换为unsigned int时，如果原值为负数，则结果不确定，因为无符号整数只能存储非负值。输出结果中，可以看到c值-99999被错误转换成了4294867297。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">short e = d;             //unsigned int转short，可能超出储值范围</span><br></pre></td></tr></table></figure>

<p>第10行：unsigned int转成short（有符号），是从32位无符号整数到16位有符号整数的转换，如果超出储值范围，则结果不确定。输出结果中，可以看到无符号整数d值4294867297被错误转换成了有符号短整数31073。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double f = b;            //float转double，安全</span><br></pre></td></tr></table></figure>

<p>第11行：float转换为double则是安全的，因为double的储值范围更大，精度也更高。输出结果证实，double类型变量f完美了float类型变量b的值。同理，short到int，int到long long也是安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.setf(ios_base::fixed, ios_base::floatfield);</span><br></pre></td></tr></table></figure>

<p>第13行：对cout输出浮点数的格式进行了设置：按定点小数（相对于科学计算法）输出，保留6位小数。具体细节本书略过不提，因为实践中的应用程序，较少使用cout以及相关的控制台界面。</p>
<p><strong>将储值范围和精度较低的对象赋值给储值范围更大，精度更高的对象是安全的，反之则不然</strong>。程序员应尽量避免将储值范围大&#x2F;精度高的对象赋值给储值范围小&#x2F;精度低的对象。如果因为某些原因不得不这么做，则需要反复确认两件事：</p>
<ul>
<li>精度的损失在可接受范围内；</li>
<li>源对象的值不会超过目标对象的储值范围。</li>
</ul>
<p>使用<strong>列表初始化（list initialization）</strong> <strong>【C++ 11】</strong>可以避免变量初始化过程中不恰当的隐式类型转换所带来的差错。如下述C++代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Project - ListInit</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char c = 712;         //允许，但会溢出</span><br><span class="line">    char d &#123;66&#125;;          //允许，66在char的储值范围内</span><br><span class="line">    char e &#123;712&#125;;         //不允许，712超过char的储值范围</span><br><span class="line">    unsigned int f &#123;-1&#125;;  //不允许，unsigned int只能存非负整数</span><br><span class="line">    int g &#123;3.12&#125;;         //不允许，收窄会导致精度丢失</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与传统的赋值初始化不同，列表初始化不允许收窄（narrowing）,即：当被初始化的变量无法准确表达{ }内的字面量或者常量▲时，编译器会报错，拒绝编译。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c = 712;         //允许，但会溢出</span><br></pre></td></tr></table></figure>

<p>第6行：char类型对象c只有8个比特的存储空间，由于是有符号字符，其储值范围为-128 ~ +127。显然，字面量712超过了c的储值范围。但由于这是传统的赋值初始化，编译器将放任这种情况的发生，至多给出一个警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char d &#123;66&#125;;          //允许，66在char的储值范围内</span><br></pre></td></tr></table></figure>

<p>第7行：字面量66在d的储值范围内，该行代码会被编译器所接受。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char e &#123;712&#125;;         //不允许，712超过char的储值范围</span><br><span class="line">unsigned int f &#123;-1&#125;;  //不允许，unsigned int只能存非负整数</span><br><span class="line">int g &#123;3.12&#125;;         //不允许，收窄会导致精度丢失</span><br></pre></td></tr></table></figure>

<p>第8 ~ 10行的变量不能准确表达{ }内的字面量，编译器将报错拒绝。</p>
<h4 id="3-5-2-表达式"><a href="#3-5-2-表达式" class="headerlink" title="3.5.2 表达式"></a>3.5.2 表达式</h4><p>在表达式a&#x2F;b中，a，b称为操作数（operand），&#x2F;称为操作符（operator）。当算术运算发生时，如果参与运算的操作符具有不同的类型，则编译器会生成额外的代码将其转变成相同的类型后再进行运算。因为，绝大多数的CPU指令集均只支持同类型对象之间的算术运算，比如两个有符号32位整数之间的运算。显然，算术运算的结果类型也受上述操作数类型转换的影响。</p>
<p>下述C++代码以除法运算为例，研究算术运算过程中的类型转换过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - DivisionOperator</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i = 3;                     //有符号整数</span><br><span class="line"></span><br><span class="line">    auto a = 10 / i;               //整数 / 整数 = 整数</span><br><span class="line">    cout &lt;&lt; &quot;10/3 = &quot; &lt;&lt; a &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto b = double(10.0) / i;     //浮点数 / 整数 = 浮点数</span><br><span class="line">    cout &lt;&lt; &quot;10.0/3 = &quot; &lt;&lt; b &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto c = i / double(10.0);     //整数 / 浮点数 = 浮点数</span><br><span class="line">    cout &lt;&lt; &quot;3/10.0 = &quot; &lt;&lt; c &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(c).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto d = double(10.0) / 3.0f;  //双精度浮点数 / 单精度浮点数 = 双精度浮点数</span><br><span class="line">    cout &lt;&lt; &quot;10.0/3.0f = &quot; &lt;&lt; d &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(d).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto e = (unsigned int)10 / i; //无符号整数 / 有符号整数 = 无符号整数</span><br><span class="line">    cout &lt;&lt; &quot;unsigned 10/3 = &quot; &lt;&lt; e &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(e).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto f = 10 / (unsigned int)3; //有符号整数 / 无符号整数 = 无符号整数</span><br><span class="line">    cout &lt;&lt; &quot;10/unsigned 3 = &quot; &lt;&lt; f &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(f).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10/3 = 3, type = i</span><br><span class="line">10.0/3 = 3.33333, type = d</span><br><span class="line">3/10.0 = 0.3, type = d</span><br><span class="line">10.0/3.0f = 3.33333, type = d</span><br><span class="line">unsigned 10/3 = 3, type = j</span><br><span class="line">10/unsigned 3 = 3, type = j</span><br><span class="line">int i = 3;                     //有符号整数</span><br></pre></td></tr></table></figure>

<p>第6行：为了便于解释， 此处显式定义了一个值为3的整数i，根据前述章节的描述，它事实上是一个有符号整数 （signed int）。接下来的代码里，我们使用auto<strong>【C++ 11】</strong>来推断商的结果类型，并使用typeid( )操作符及其name成员函数▲将商的类型打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto a = 10 / i;               //整数 / 整数 = 整数</span><br><span class="line">cout &lt;&lt; &quot;10/3 = &quot; &lt;&lt; a &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(a).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第8 ~ 9行：输出结果证实，整数&#x2F;整数的结果类型为整数，商的小数部分被舍弃。请学习过Python语言的读者注意，这与Python语言不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto b = double(10.0) / i;     //浮点数 / 整数 = 浮点数</span><br><span class="line">cout &lt;&lt; &quot;10.0/3 = &quot; &lt;&lt; b &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(b).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 12行：输出结果证实，浮点数&#x2F;整数的结果类型为浮点数，此处的浮点数类型为double。请读者注意，字面量10.0的类型也是double。作者在这里有意写成double(10.0)，通过一个显式的double类型构造函数▲将10.0“转换”成一个double，是因为担心读者无法正确识别10.0字面量的类型而产生疑惑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto c = i / double(10.0);     //整数 / 浮点数 = 浮点数</span><br><span class="line">cout &lt;&lt; &quot;3/10.0 = &quot; &lt;&lt; c &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(c).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第14行：输出结果证实，整数&#x2F;浮点数的结果类型为浮点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto d = double(10.0) / 3.0f;  //双精度浮点数 / 单精度浮点数 = 双精度浮点数</span><br><span class="line">cout &lt;&lt; &quot;10.0/3.0f = &quot; &lt;&lt; d &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(d).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第17 ~ 18行：输出结果证实，双精度浮点数&#x2F;单精度浮点数的结果类型为双精度浮点数。3.0f中的后缀f表明该字面量为float类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto e = (unsigned int)10 / i; //无符号整数 / 有符号整数 = 无符号整数</span><br><span class="line">cout &lt;&lt; &quot;unsigned 10/3 = &quot; &lt;&lt; e &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(e).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">auto f = 10 / (unsigned int)3; //有符号整数 / 无符号整数 = 无符号整数</span><br><span class="line">cout &lt;&lt; &quot;10/unsigned 3 = &quot; &lt;&lt; f &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(f).name() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第20 ~ 24行：输出结果证实，有符号整数与无符号整数进行除法运算的结果为无符号整数。输出结果type &#x3D; j中的j指无符号整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto b = double(10.0) / i;     //浮点数 / 整数 = 浮点数</span><br></pre></td></tr></table></figure>

<p><strong>当表达式中两种不同类型的对象进行算术运算时，编译器总是将较小的类型转换为较大的类型再进行计算</strong>。第11行中，一个double除以一个int，编译器会先将整数i转换成double，再进行除法运算。两个double相除，其结果自然是double。</p>
<p>需要注意的是，这种形式的隐式类型转换只是创建一个被转换对象的副本，不会改变被转换对象自身。比如第11行的i被转成double，编译器只是创建了一个double类型的用完即弃的临时对象，其值与i相同。第11行代码执行完后，对象i不会有任何变化。</p>
<h3 id="3-6-显式类型转换"><a href="#3-6-显式类型转换" class="headerlink" title="3.6 显式类型转换"></a>3.6 显式类型转换</h3><p>有的编译器会对有风险的隐式类型转换给出警告。程序员可以通过显示类型转换（explicit type cast）告知编译器，这些转换是有意为之且经过复核的。请阅读下述C++代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Project - TypeCast</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    char c = &#x27;K&#x27;;</span><br><span class="line">    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; (int)c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; int(c) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = K</span><br><span class="line">ASCII code for &#x27;K&#x27;: 75</span><br><span class="line">ASCII code for &#x27;K&#x27;: 75</span><br><span class="line">ASCII code for &#x27;K&#x27;: 75</span><br><span class="line">cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第7行：直接把char c输出给cout，会得到字符K。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; (int)c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第8行：(int)c将c对象显示类型转换为int，然后再输出给cout，得到K的ASCII码值75。这种转换形式是C语言的语法，其通用格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(目标类型名)值</span><br><span class="line">cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; int(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第9行：int(c)是C++的类型转换格式。从面向对象的观点看来，它像是执行int类型的构造函数▲，从参数创建一个int类型的对象。其通用格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标类型名(值)</span><br><span class="line">cout &lt;&lt; &quot;ASCII code for &#x27;K&#x27;: &quot; &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第10行：C++认为C语言形式的类型转换没有进行恰当的合法性检查，存在较大风险。因此，C++额外定义了4种强制类型转换操作符，代码中的static_cast<int>(c)是其中一种。另外三种将在后续章节中详细讨论。static_cast操作符的通用格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static_cast&lt;目标类型名&gt;(值)</span><br></pre></td></tr></table></figure>

<h3 id="3-7-使用函数"><a href="#3-7-使用函数" class="headerlink" title="3.7 使用函数"></a>3.7 使用函数</h3><p>前述章节中我们多次用到的printf( )就是一个函数。函数接受用户提供的0个或多个参数，执行特定任务后返回运行结果。除了printf()函数之外，C&#x2F;C++的标准库提供了数量众多的函数供我们使用。请阅读下述C语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - UseFunc</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double x = 2, y = 8;</span><br><span class="line">    printf(&quot;2^8 = %f\n&quot;, pow(x,y));              //x的y次方</span><br><span class="line">    printf(&quot;round(25.51) = %f\n&quot;, round(25.51)); //四舍五入</span><br><span class="line">    printf(&quot;floor(25.997) = %f\n&quot;,floor(25.997));//下取整</span><br><span class="line">    printf(&quot;ceil(25.01) = %f\n&quot;, ceil(25.01));   //上取整</span><br><span class="line">    printf(&quot;sqrt(5) = %f\n&quot;,sqrt(5));            //平方根</span><br><span class="line"></span><br><span class="line">    int r0 = rand();                             //0 ~ RAND_MAX之间的随机整数</span><br><span class="line">    int r1 = rand() % 100;                       //0 ~ 99之间的随机数</span><br><span class="line">    double r2 = 0.1 + 0.1*rand()/RAND_MAX;       //0.1 ~ 0.2之间的随机浮点数</span><br><span class="line">    printf(&quot;r0 - %d, r1 - %d, r2 - %f\n&quot;,r0,r1,r2);</span><br><span class="line">    printf(&quot;RAND_MAX = %x&quot;,RAND_MAX);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2^8 = 256.000000</span><br><span class="line">round(25.51) = 26.000000</span><br><span class="line">floor(25.997) = 25.000000</span><br><span class="line">ceil(25.01) = 26.000000</span><br><span class="line">sqrt(5) = 2.236068</span><br><span class="line">r0 - 41, r1 - 67, r2 - 0.119330</span><br><span class="line">RAND_MAX = 7fff</span><br></pre></td></tr></table></figure>

<p>说明：因为随机数的存在以及开发环境的差异，读者机器上的运行结果的第6 ~ 7行可能与作者的结果不同。</p>
<p>第3 ~ 4行：math.h头文件引入了C语言的数学函数库，stdlib.h头文件引入了rand( )函数及其相关的RAND_MAX常量。下表总结了本例中使用到的库函数。</p>
<p>表3- UseFunc项目中的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pow(x,y)</td>
<td>计算x的y次方，x,y以及返回值都是double类型。</td>
</tr>
<tr>
<td>round(x)</td>
<td>计算x的四舍五入值，x以及返回值都是double类型。如果期望获得int类型的结果，则需要进行类型转换。</td>
</tr>
<tr>
<td>floor(x)</td>
<td>计算x的下取整，x以及返回值都是double类型。同上，如果期望获得整型结果，需要类型转换。注意25.997的下取整结果是25.0。</td>
</tr>
<tr>
<td>ceil(x)</td>
<td>计算x的上取整，x以及返回值都是double类型。同上，可以通过类型转换获得整型结果。注意25.01的上取整结果是26.0。</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td>计算x的平方根。x以及返回值都是double类型。</td>
</tr>
<tr>
<td>rand( )</td>
<td>生成0 ~ RAND_MAX之间的伪随机整数（pseudo-random integral number）。RAND_MAX是由stdlib.h头文件引入的常量▲，在作者的开发环境中，其值为0x7fff，即短整型（signed short）所能存储的最大正数。</td>
</tr>
</tbody></table>
<p>说明：在C++的标准库里，上述函数可能存在多个函数名重载▲版本。对C++而言，表中关函数的参数及返回值类型可能不够准确。</p>
<p>读者可能期望round( )、floor( )、ceil( )等函数返回一个整数类型的结果，但事实上不是。在多数集成开发环境里，都会给出函数的原型以提示函数的参数个数，类型以及返回值类型。在图3- 中可以看到round( )函数接受一个double类型的参数，返回一个double。数学上，读者会期望四舍五入的结果是整数，为达到该目的，可以通过下述格式进行类型转换：(int)round(25.51)。</p>
<p><img src="http://codelearn.club/images/image-20200215173632625.png" alt="image-20200215173632625"></p>
<p>图3- 集成开发环境的提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int r1 = rand() % 100;                       //0 ~ 99之间的随机数</span><br></pre></td></tr></table></figure>

<p>第15行：将rand( )函数的返回值对100求模，即可得取值范围为0 ~ 99的随机整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double r2 = 0.1 + 0.1*rand()/RAND_MAX;       //0.1 ~ 0.2之间的随机浮点数</span><br></pre></td></tr></table></figure>

<p>第16行：将rand( )函数的返回值 &#x2F; RAND_MAX，可得取值范围为 0 ~ 1的随机浮点数，该浮点数乘以0.1，可得取值范围为0 ~ 0.1的随机浮点数，再加上0.1，即得取值范围为0.1 ~ 0.2的随机浮点数。</p>
<p>简单地总结，使用C&#x2F;C++的某些库函数或者第三方库函数，需要这样几个步骤：</p>
<ul>
<li>查询文档及资料，了解函数的定义及包含它的头文件的名称。</li>
<li>通过#include预处理指令包含相应的头文件，有些时候，还需要在编译时链接相应的库文件（扩展名可能为lib、DLL或者so）▲。</li>
<li>在代码中调用该函数。</li>
</ul>
<h3 id="微实践-地球时间"><a href="#微实践-地球时间" class="headerlink" title="微实践 - 地球时间"></a>微实践 - 地球时间</h3><p>现代计算机内部均安装有RTC(Real Time Clock)芯片或者其CPU具备RTC功能。 RTC芯片内部有一个计数器，通常用于记录从GMT时间（格林尼治时间）1970年1月1日零时起，总共流逝的Tick(滴答)个数。RTC芯片会按照固定的节拍增加这个计数器的值，以达到计时的目的。至于一个Tick是何种精度，则取决于计算机的工作频率及RTC的能力，大部分都在微秒级。RTC芯片工作是需要消耗电能的，那么计算机断电时计时会停止吗？ 不会，读者可以在自己的计算机主板甚至手机主板上找到用于给RTC供电的纽扣锂电池。</p>
<p>有的读者可能还会想到，北京和东京分处不同时区，计算机显示日期时间时是否还需进行时区转换呢？是的，在操作系统中可以设置时区，设置完成后，操作系统会自动完成从RTC内部计数器计数值到特定时区的时间转换。顺便提一句，现代计算机大部分会连网，在连上Internet时，操作系统很可能会自动从网上刷新时间，以消除RTC的计时误差。</p>
<p>下述C程序获取并打印了系统当前的格林尼治时间，以及自1970年1月1日零时起至现在，总共流逝的秒数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Project - EarthTime</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    time_t t;</span><br><span class="line">    time(&amp;t); //获取当前时间,从1970年1月1日零时起经过的秒数</span><br><span class="line"></span><br><span class="line">    long long totalSeconds = (long long)t;      //总秒数转换为long long类型</span><br><span class="line">    long long curSecond = totalSeconds % 60;    //当前秒数 = 总秒数对60取余</span><br><span class="line">    long long totalMinutes = totalSeconds / 60; //总分钟 = 总秒数除60</span><br><span class="line">    long long curMinute = totalMinutes % 60;    //当前分钟 = 总分钟对60取余</span><br><span class="line">    long long totalHours = totalMinutes / 60;   //总小时 = 总分钟除60</span><br><span class="line">    long long curHour = totalHours % 24;        //当前小时 = 总小时对24取余</span><br><span class="line"></span><br><span class="line">    printf(&quot;格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.&quot;,</span><br><span class="line">           curHour,curMinute,curSecond,totalSeconds);</span><br><span class="line"></span><br><span class="line">    /* printf的英文版本</span><br><span class="line">    printf(&quot;%lld:%lld:%lld, %lld seconds after 1970/1/1 00:00::00&quot;,</span><br><span class="line">           curHour,curMinute,curSecond,totalSeconds);</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格林尼治时间 6 时 50 分 54 秒,1970年1月1日零时到现在经过了 1581835854 秒.</span><br></pre></td></tr></table></figure>

<p>第3行：time.h引入了time( )函数及time_t类型。在作者的开发环境里，time_t事实上是long long类型，表示自1970年1月1日零时起到现在经过了多少秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time(&amp;t)</span><br></pre></td></tr></table></figure>

<p>这行代码涉及以后要学习的知识。可简单理解为：将t的地址传递给函数，让time( )函数的执行部分把从RTC获取的值存在t变量里。</p>
<p>获得t之后，我们先将其转换成long long类型的总数秒（totalSeconds），然后借助于求模和整数除法，计算出当前的小时、分钟和秒数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;格林尼治时间 %lld 时 %lld 分 %lld 秒,1970年1月1日零时到现在经过了 %lld 秒.&quot;,</span><br><span class="line">       curHour,curMinute,curSecond,totalSeconds);</span><br></pre></td></tr></table></figure>

<p>第16 ~ 17行：%lld表示输出long long类型的整数，如果写成%d，则该行代码需要隐式地将long long类的值转换成int型，再输出，可能因超范围而出错。</p>
<blockquote>
<p>中文输出问题：第16行的输出使用了中文，在某些开发环境的默认配置下，控制台输出中文可能会乱码。此时，读者可以使用第20行的英文输出版本。</p>
<p><strong>扩展阅读📕</strong> Windows控制台环境下Qt Creator的中文输出。</p>
<p><a target="_blank" rel="noopener" href="http://codelearn.club/2020/02/qtconsolechinese/">http://codelearn.club/2020/02/qtconsolechinese/</a></p>
</blockquote>
<p>读者可能觉得上述计算过程非常麻烦。事实上，这只是为了找一个题目给读者练习取模及除法操作符。对这些常见的问题，C&#x2F;C++肯定有更快更好的解决方案，该问题也可用下述C程序解决▲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - LocalTime</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    time_t t;</span><br><span class="line">    struct tm * timeInfo;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    timeInfo = localtime(&amp;t); //从t转换出本地日期时间</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d-%d-%d %d:%d:%d&quot;,1900+timeInfo-&gt;tm_year,timeInfo-&gt;tm_mon,</span><br><span class="line">           timeInfo-&gt;tm_mday,timeInfo-&gt;tm_hour,timeInfo-&gt;tm_min,timeInfo-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-1-16 15:3:29</span><br></pre></td></tr></table></figure>

<p>这段程序超出读者当前的知识背景。跟这段程序有关的知识会在后续章节中逐步讨论。</p>
<h3 id="3-8-自定义函数"><a href="#3-8-自定义函数" class="headerlink" title="3.8 自定义函数"></a>3.8 自定义函数</h3><p>C&#x2F;C++提供的库函数并不能满足我们的全部需要。此时，我们可以自定义函数。请先阅读下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - DefFunc</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//电费计算: (期末读数 - 期初读数) * 单价</span><br><span class="line">float costCompute(int iStart, int iEnd)</span><br><span class="line">&#123;</span><br><span class="line">    int iConsume = iEnd - iStart;</span><br><span class="line">    return iConsume * 0.85f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float fElecFee1 = costCompute(1201,1786);</span><br><span class="line">    printf(&quot;Electronic Power Cost of Mr Zhang: %.2f\n&quot;, fElecFee1);</span><br><span class="line"></span><br><span class="line">    float fElecFee2 = costCompute(1322,1423);</span><br><span class="line">    printf(&quot;Electronic Power Cost of Mr Lee: %.2f&quot;, fElecFee2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Electronic Power Cost of Mr Zhang: 497.25</span><br><span class="line">Electronic Power Cost of Mr Lee: 85.85</span><br></pre></td></tr></table></figure>

<p>第5 ~ 9行定义了一个名为costCompute的电费计算函数。由于是用户自己定义的，故称为自定义函数（user defined function）。该函数结构如下图所示。</p>
<p><img src="http://codelearn.club/images/image-20200215214455349.png" alt="image-20200215214455349"></p>
<p>图3- costCompute函数的结构</p>
<p>costCompute是函数名，函数名后的括号里是以逗号分隔的<strong>形式参数</strong>列表。函数接受0至多个形式参数作为输入，当形参的数量为0时，包含形参列表的括号可以为空。{ }内的部分为函数体（function body），函数体内的代码为函数的实际执行部分。这个部分通常会使用形参进行一些计算或者处理，然后通过return语句返回一个值。</p>
<p>costCompute函数的返回值类型为float，这意味着，该函数的函数体必须使用return语句返回一个float类型的对象。当一个函数没有返回值时，其返回值类型用void代替。此时，其函数体内的如果有return语句的话，只能是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return;</span><br></pre></td></tr></table></figure>

<p>这表示不带返回值的”返回“。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int iConsume = iEnd - iStart;</span><br></pre></td></tr></table></figure>

<p>第7行：用期末读数（iEnd）减去期初读数（iStart），得到当月用电度数（iConsume）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return iConsume * 0.85f;</span><br></pre></td></tr></table></figure>

<p>第8行：用电度数与0.85f的单价相乘，然后用return语句返回。</p>
<p><strong>函数的定义起到向编译器介绍函数的作用，它并不会导致函数的执行</strong>。上述代码中的第12行、第15行两次调用执行了该函数。</p>
<p><img src="http://codelearn.club/images/image-20200215223339373.png" alt="image-20200215223339373"></p>
<p>图3- 函数调用</p>
<p>我们借助于图3- 来解释函数调用过程。</p>
<table>
<thead>
<tr>
<th>①</th>
<th>CPU依次执行函数调用前的代码。</th>
</tr>
</thead>
<tbody><tr>
<td>②</td>
<td>函数调用点，跳转至函数执行。本例中，跳转过程伴随参数传递，1322传递给了iStart，1423传递给了iEnd。</td>
</tr>
<tr>
<td>③</td>
<td>函数体内的代码依次执行。</td>
</tr>
<tr>
<td>④</td>
<td>执行到函数体内的return语句，从函数跳转回调用点。本例中，跳转过程”携带“着函数的返回值，该值作为赋值操作符的右值被传递给了fElecFee2变量。</td>
</tr>
<tr>
<td>⑤</td>
<td>CPU继续执行函数调用后的代码。</td>
</tr>
</tbody></table>
<p>可以看出，一个函数可以一次定义，多次执行，每次执行时可传递不同的参数。本例中出现在函数定义中的参数iStart，iEnd称为<strong>形式参数</strong>，简称形参，函数调用过程中实际提供的参数，如1322，称为<strong>实际参数</strong>，简称实参。</p>
<blockquote>
<p><strong>为什么要定义这么一个简单的函数</strong><br>直接用fElecFee &#x3D; (1786-1201)*0.85难道不是更简单么？ 不，适时的舍简求繁实际是删繁就简！<br>- costCompute被抽象成函数以后，读者一看便知这个函数是在计算费用，程序可读性好。<br>- 如果有一天要实施阶梯电价或者电价变更，用户只需修改costCompute函数即可完成升级；如果使用直接计算的方案，假设在程序当中有n处电费计算的话，就需要修改n处，如果遗漏了一处，就是程序缺陷，即我们所熟知的Bug。</p>
</blockquote>
<h3 id="3-9-地址"><a href="#3-9-地址" class="headerlink" title="3.9 地址"></a>3.9 地址</h3><p>程序中的每个变量&#x2F;对象，都会占据存储空间。而存储空间，是有地址（address）的。下述C语言程序演示了如何获得并打印对象的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - GetAddr</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i = 1, j = 2;</span><br><span class="line">    char c = &#x27;c&#x27;;</span><br><span class="line">    long double ld = 0.0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;i=%p, &amp;j=%p, &amp;c=%p, &amp;ld=%p&quot;,&amp;i,&amp;j,&amp;c,&amp;ld);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;i=000000000061FE1C, &amp;j=000000000061FE18, &amp;c=000000000061FE17, &amp;ld=000000000061FE00</span><br></pre></td></tr></table></figure>

<p>注意：读者在自己计算机上的运行结果不太可能与上述结果相同。计算机上的内存分配是一个受诸多因素影响的复杂过程，这些因素包括硬件差异、操作系统与编译器版本、当前计算机的内存占用情况等。</p>
<p>表达式&amp;a表示获取a对象在内存中的存储地址。该表达式中的&amp;操作符仅有一个操作数（operand），即对象a。printf( )中的占符符%p表示输出一个指针▲，也就是地址。显然，这个被输出的地址是以十六进制显示的。</p>
<p>上述输出结果中，i的地址是0x000000000061FE1C，这说明变对象i存储在地址0x000000000061FE1C开始的连续4个字节的存储空间内。</p>
<p>根据上述输出，作者绘制了如下的内存地图。</p>
<p><img src="http://codelearn.club/images/image-20200216091058092.png" alt="image-20200216091058092"></p>
<p>图3- 内存地图</p>
<p>从图中可以看到，对象i，j，c，ld按定义顺序从高地址往低地址顺序分配存储空间。其中，i,j各占4个字节，ld占16个字节。比较令人费解是字符c，它事实上只占据地址为0x000000000061FE17的1个字节的空间，程序却事实上为其留出了8个字节的连续空间，并将其余7个字节的空间空置。这是编译器数据对齐（data alignment）的结果，作者的计算机是64位，即计算机一个指令可以处理的的最大数据量是8个字节。编译器在分配空间时，会“尽量”以8个字节为”单位”。</p>
<p>再次说明，最终的内存分配结果与编译器、计算机、操作系统紧密相关。在读者的实际计算机上，所看到的情况不太可能与上述内存地图完全一致。</p>
<h3 id="3-10-获取用户输入"><a href="#3-10-获取用户输入" class="headerlink" title="3.10 获取用户输入"></a>3.10 获取用户输入</h3><h4 id="3-10-1-C"><a href="#3-10-1-C" class="headerlink" title="3.10.1 C"></a>3.10.1 C</h4><p>C语言控制台应用中获取用户输入主要靠scanf( )函数，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - CInput</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iAge = 0,iHeight = 0;</span><br><span class="line">    float fWeight = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Please input your age, weight(kg):\n&quot;);</span><br><span class="line">    scanf(&quot;%d,%f&quot;,&amp;iAge,&amp;fWeight);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Please input your height(cm):\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;iHeight);</span><br><span class="line"></span><br><span class="line">    float fBMI = fWeight / pow((iHeight/100.0),2);</span><br><span class="line">    printf(&quot;Age = %d, Weight(kg) = %.2f, Height(cm) = %d, BMI = %.2f&quot;,</span><br><span class="line">           iAge,fWeight,iHeight,fBMI);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please input your age, weight(kg):</span><br><span class="line">17,52.53</span><br><span class="line">Please input your height(cm):</span><br><span class="line">170</span><br><span class="line">Age = 17, Weight(kg) = 52.53, Height(cm) = 170, BMI = 18.18</span><br></pre></td></tr></table></figure>

<p>说明：执行结果中的第2行，第4行需要操作者输入。输入时请注意格式，输入值不同，输出结果也会不同。</p>
<p>scanf( )函数用于从控制台读取操作者的键盘输入，其格式与printf( )有相似之处。它可以接受多个参数，其中第1个预期为字符串，字符串中可包含1个或者多个占位符。占位符的个数、类型以及顺序应与后续其它参数相匹配。请注意，后续其它参数通过&amp;符号取地址，事实上传递给scanf( )函数的是变量的地址。其中，占位符指定了期望获得的输入的类型和格式，地址参数则用于说明获得输入后将值传递给哪个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d,%f&quot;,&amp;iAge,&amp;fWeight);</span><br></pre></td></tr></table></figure>

<p>第10行：一种形象解释是，老板，订两份外卖，一份卤肉饭（%d），一份鸡汤面（%f）。送过来后，卤肉饭放2号楼门口（&amp;iAge），鸡汤面交给小区门岗（&amp;fWeight）。需要注意的是，本行代码的格式字符串中包含了一个逗号，意即整数和浮点数之间用逗号作分隔。输入时必须录入上述逗号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float fBMI = fWeight / pow((iHeight/100.0),2);</span><br><span class="line">printf(&quot;Age = %d, Weight(kg) = %.2f, Height(cm) = %d, BMI = %.2f&quot;,</span><br><span class="line">       iAge,fWeight,iHeight,fBMI);</span><br></pre></td></tr></table></figure>

<p>第15 ~ 17行：计算并打印了人体质量指数（<strong>B</strong>ody <strong>M</strong>ass <strong>I</strong>ndex），其值为体重（千克）除以身高（米）的平方。</p>
<h4 id="3-10-2-C"><a href="#3-10-2-C" class="headerlink" title="3.10.2 C++"></a>3.10.2 C++</h4><p>C++语言控制台应用中获取用户输入主要靠cin对象来进行。cin由iostream头文件引入，指控制台输入流（console input stream）,其类型为istream。我们使用cin和cout实现了与上节程序功能相同的C++代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - CppInput</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iAge &#123;&#125;, iHeight &#123;&#125;;</span><br><span class="line">    float fWeight &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Please input your age, weight(kg):&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; iAge &gt;&gt; fWeight;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Please input your height(cm):\n&quot;;</span><br><span class="line">    cin &gt;&gt; iHeight;</span><br><span class="line"></span><br><span class="line">    float fBMI = fWeight / pow((iHeight/100.0),2);</span><br><span class="line">    cout &lt;&lt; &quot;Age = &quot; &lt;&lt; iAge &lt;&lt; &quot;, Weight(kg) = &quot; &lt;&lt; fWeight</span><br><span class="line">         &lt;&lt; &quot;, Height(cm) = &quot; &lt;&lt; iHeight &lt;&lt; &quot;, BMI = &quot; &lt;&lt; fBMI;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Please input your age, weight(kg):</span><br><span class="line">52 102.24</span><br><span class="line">Please input your height(cm):</span><br><span class="line">168</span><br><span class="line">Age = 52, Weight(kg) = 102.24, Height(cm) = 168, BMI = 36.2245</span><br></pre></td></tr></table></figure>

<p>说明：执行结果中的第2行，第4行需要操作者输入。请注意第2行的两个数之间用空格作分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; iAge &gt;&gt; fWeight;</span><br></pre></td></tr></table></figure>

<p>这行代码从控制台依次接受两个变量输入，默认以空格作分隔。请注意与cin配用的&gt;&gt;操作符和与cout配用的&lt;&lt;操作符方向相反。关于这行代码背后的工作原理，我们要到本书的后半部分才能讲得清楚。当前阶段，读者参照使用即可。</p>
<h3 id="3-11-常量"><a href="#3-11-常量" class="headerlink" title="3.11 常量"></a>3.11 常量</h3><p>常量（constant）是相对于变量而言的。变量的值可以在程序运行过程中反复修改，但常量不允许修改，为固定值。C&#x2F;C++中，有两种定义常量的方法，请见下述C语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Program - Constant</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define PI 3.1415926</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float r = 2;</span><br><span class="line">    const float CPI = 3.1415926f;</span><br><span class="line">    //CPI = 4;      //常量不能修改</span><br><span class="line"></span><br><span class="line">    printf(&quot;Area of circle = %.2f\n&quot;, PI*r*r);</span><br><span class="line">    printf(&quot;Area of circle = %.2f&quot;, CPI*r*r);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Area of circle = 12.57</span><br><span class="line">Area of circle = 12.57</span><br><span class="line">#define PI 3.1415926</span><br></pre></td></tr></table></figure>

<p>第4行：使用预处理指令#define定义了常量PI, 其值为3.1415926。在编译器开始编译前，预处理器▲会将程序中的PI替换为3.1415926。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const float CPI = 3.1415926f;</span><br></pre></td></tr></table></figure>

<p>第8行：在类型名前加上const修饰，表明CPI是类型为float的常量，其值为3.1415926。常量定义时，可以提供初始值，但定义之后，便不可修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//CPI = 4;      //常量不能修改</span><br></pre></td></tr></table></figure>

<p>第9行：如果试图修改常量，编译器会拒绝。</p>
<p>相对于预处理指令定义的PI，作者更建议使用const修饰符来定义常量，因为后者定义的常量有明确的类型。除非必要，编译器不会为常量分配存储空间以节约资源。</p>
<h3 id="3-12-注释"><a href="#3-12-注释" class="headerlink" title="3.12 注释"></a>3.12 注释</h3><p>注释是程序员写给明天的自己或者同事看的，解释器执行时会自动忽略注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">The following program was written by Alex, all rights reserved.</span><br><span class="line">I hope that this book can lead you into the fantastic world of programming.</span><br><span class="line"></span><br><span class="line">Loving Alex  chenbo@cqu.edu.cn</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//stdio.h introduced printf function to this file</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单行注释以&#x2F;&#x2F;打头；多行注释则用&#x2F;* *&#x2F;包裹。在代码中书写<strong>简洁、有意义的注释</strong>十分重要</p>
<h3 id="微实践-哈利波特之心灵感应"><a href="#微实践-哈利波特之心灵感应" class="headerlink" title="微实践 - 哈利波特之心灵感应"></a>微实践 - 哈利波特之心灵感应</h3><p>哈利波特之心灵感应魔法是一种常见的儿童益智游戏。表演者首先会要求观众在心中默想一个60以内的整数，然后依次将下述卡片1到卡片6出示给观众看，并询问观众他所默想的数字是否在卡片上。在卡片出示的过程中，卡片是背对表演者的，即表演者是看不到卡片的。在听完观众的6个回答之后，表演者即可＂猜＂出观众默想的数字，仿佛掌握了＂读心术＂。</p>
<p><img src="http://codelearn.club/images/1561649322531.png" alt="1561649322531"></p>
<p>表演者显然没有＂读心术＂, 他依赖于观众关于数字在不在卡片上的6个回答来计算答案。解题思路与二进制有关。一个6位的二进制数，其可以表达的最大数字是26 - 1 &#x3D; 63。所以，任意60以内的整数，都可以用不超过6位的二进制数来表达。比如，41，其二进制值如下表所示：</p>
<p><img src="http://codelearn.club/images/1561653300110.png" alt="1561653300110"></p>
<p>表3- 41的二进制表示</p>
<p>我们以十进制整数(4321)₁₀来说明表3- 中的位号、位值及位权。位值1、2、3、4从低到高，分别处于位号1（个位）到位号4（千位）。而(4321)₁₀ &#x3D; 4 ⅹ10³ + 3ⅹ10²+2ⅹ10¹+1ⅹ10⁰，这里的10³为位号4的位权，10⁰为位号1的位权。同理，(41)₁₀&#x3D;(101001)₂中，位号6处的位值为1，其对应的位权为2⁵&#x3D;32；位号2处的位值为0，其对应的位权为2¹&#x3D;2。</p>
<p>每一个60以内的整数，均可转换成一个6位二进制数。如果对应的二进制数的第1位（最低位）为1，该数包括在卡片1中，同理，二进制第2位为1的数包括在卡片2中，… 二进制第6位为1的数包括在卡片6中。上述数字41，其二进制的第1， 4， 6位为1。读者可以看到，41只出现在卡片1，4，6中，卡片2，3，5里没有41。所以，观众每回答一个按顺序给出的问题，其实就告诉了表演者该数字6位二进制数中的其中一位是0还是1。</p>
<p>我们用数字58来模拟一下。卡片1，3里没有58，卡片2，4，5，6里有58。所以表演者从观众那里得到的6个回答依次是：无，有，无，有，有 ，有。将上述回答换成二进制就是111010。按照对应的位权把0b111010换成十进制就是32+16+8+2 &#x3D; 58。</p>
<p>现在我们知道表演者是如何表演的了。他一直在做加法，从0值开始。如果卡片1的回答是有，加1，卡片2的回答是有，加2，卡片3有，加4，… ， 卡片6有，加32。最后直接报出和数即可。</p>
<p>读者可以运行下述C++程序才模拟执行上述游戏过程：心里先默想一个数，然后运行程序，通过输入y或者n来回答6个问题。看看计算机能否猜出你默想的数，是否跟你有心灵感应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//Project - NumMagic</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string sCard1 = &quot;Card 1:\n \</span><br><span class="line">    1 11 21 31 41 51\n \</span><br><span class="line">    3 13 23 33 43 53\n \</span><br><span class="line">    5 15 25 35 45 55\n \</span><br><span class="line">    7 17 27 37 47 57\n \</span><br><span class="line">    9 19 29 39 49 59\n&quot;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    string sCard6 = &quot;Card 6:\n \</span><br><span class="line">    32 37 42 47 52 57\n \</span><br><span class="line">    33 38 43 48 53 58\n \</span><br><span class="line">    34 39 44 49 54 59\n \</span><br><span class="line">    35 40 45 50 55 60\n \</span><br><span class="line">    36 41 46 51 56 *\n&quot;;</span><br><span class="line"></span><br><span class="line">    string sQuestion = &quot;Is your number in this card? y for yes, n for no:&quot;;</span><br><span class="line">    string sInput &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; sCard1 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b1 = sInput == &quot;y&quot;?1:0;</span><br><span class="line">    cout &lt;&lt; sCard2 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b2 = sInput == &quot;y&quot;?1:0;</span><br><span class="line">    cout &lt;&lt; sCard3 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b3 = sInput == &quot;y&quot;?1:0;</span><br><span class="line">    cout &lt;&lt; sCard4 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b4 = sInput == &quot;y&quot;?1:0;</span><br><span class="line">    cout &lt;&lt; sCard5 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b5 = sInput == &quot;y&quot;?1:0;</span><br><span class="line">    cout &lt;&lt; sCard6 &lt;&lt; sQuestion;</span><br><span class="line">    cin &gt;&gt; sInput;</span><br><span class="line">    int b6 = sInput == &quot;y&quot;?1:0;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Binary answer: &quot; &lt;&lt;b6&lt;&lt;b5&lt;&lt;b4&lt;&lt;b3&lt;&lt;b2&lt;&lt;b1&lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;The number is: &quot; &lt;&lt; b6*32 + b5*16 + b4*8 + b3*4 + b2*2 + b1*1;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为（输入依次为n,n,n,y,y,n）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Card 6:</span><br><span class="line">     32 37 42 47 52 57</span><br><span class="line">     33 38 43 48 53 58</span><br><span class="line">     34 39 44 49 54 59</span><br><span class="line">     35 40 45 50 55 60</span><br><span class="line">     36 41 46 51 56 *</span><br><span class="line">Is your number in this card? y for yes, n for no:n</span><br><span class="line">Binary answer: 011000</span><br><span class="line">The number is: 24</span><br></pre></td></tr></table></figure>

<p>注意：上述输入y, n要小写，且不要有多余空格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：string头文件引入了string类型<strong>【C++】</strong>，该类型可以存储一个字符串。其工作原理在本书的后续部分逐步讨论。</p>
<p>第7 ~ 21行：定义了sCard1 ~ 6共6个多行字符串。第14行的省略号代表此处有删节（节省篇幅），具体代码以网络下载的随书代码为准。在这些由双引号包裹的多行字符串里，\n表示换行，每行末尾的\称之为<strong>续行符</strong>，它表明下行代码的内容是本行字符串的后续部分。</p>
<p>在输出了卡片字符串之后，程序向用户提问：数字是否在卡片中。用户的回答保存在sInput字符串中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int b1 = sInput == &quot;y&quot;?1:0;</span><br></pre></td></tr></table></figure>

<p>第28行：条件语句， 如果sInput的值为”y”，b1赋值为1，否则赋值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;Binary answer: &quot; &lt;&lt;b6&lt;&lt;b5&lt;&lt;b4&lt;&lt;b3&lt;&lt;b2&lt;&lt;b1&lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第45行：上述提问重复6次后，b6,b5,b4,b3,b2,b1分别对应数字的6个二进制位，使用printf( )将数字的二进制形式打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;The number is: &quot; &lt;&lt; b6*32 + b5*16 + b4*8 + b3*4 + b2*2 + b1*1;</span><br></pre></td></tr></table></figure>

<p>第46行：通过对各二进制位的加权求和，得到猜测数，并输出给cout。</p>
<h2 id="4-分支与循环"><a href="#4-分支与循环" class="headerlink" title="4. 分支与循环"></a>4. 分支与循环</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>分支语句根据条件的不同作出选择；循环则适用于处理重复的工作。</p>
<h3 id="4-1-if-else语句"><a href="#4-1-if-else语句" class="headerlink" title="4.1 if else语句"></a>4.1 if else语句</h3><p>if语句的通用语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (表达式)</span><br><span class="line">	语句;</span><br><span class="line">	</span><br><span class="line">if (表达式) &#123;</span><br><span class="line">	语句; </span><br><span class="line">    ...</span><br><span class="line">	语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if关键字后的<strong>括号</strong>内包含一个表达式，这个包裹表达式的括号是必须的。当该表达式的结果为真时，if语句的下层代码会被执行。当下层代码的语句多于1条时，需要用{ }包裹。如上述格式中的第4 ~ 8行所示。</p>
<p>下述C语言代码演示了if语句的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Project - IfStatement</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int iAge = 0;</span><br><span class="line">    printf(&quot;Hey, how old are you ? boy.\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;iAge);</span><br><span class="line"></span><br><span class="line">    if (iAge&gt;=18)   //括号()必须</span><br><span class="line">        printf(&quot;You are legally an adult.\n&quot;);</span><br><span class="line"></span><br><span class="line">    if (iAge&gt;=22)&#123;</span><br><span class="line">        printf(&quot;Congratulations, son!\n&quot;);</span><br><span class="line">        printf(&quot;You are of legal age for marriage.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为（输入为23）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hey, how old are you ? boy.</span><br><span class="line">23</span><br><span class="line">You are legally an adult.</span><br><span class="line">Congratulations, son!</span><br><span class="line">You are of legal age for marriage.</span><br></pre></td></tr></table></figure>

<p>第9行：根据输入iAge的值为23，if后括号内的表达式成立，第10行被执行。</p>
<p>第12行：同理，if中括号内的表达式成立，{ }内的第13 ~ 14行被顺序执行。</p>
<p>相较于if语句，if else语句增加了当表达式&#x2F;条件不成立时的选项。其通用语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (表达式)</span><br><span class="line">	语句；</span><br><span class="line">else</span><br><span class="line">	语句；</span><br><span class="line">	</span><br><span class="line">if (表达式) &#123;</span><br><span class="line">	语句；</span><br><span class="line">    ...</span><br><span class="line">	语句；</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	语句；</span><br><span class="line">    ...</span><br><span class="line">	语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当if关键字后括号内的表达式&#x2F;条件成立时，执行if语句的下层代码，否则执行else语句的下层代码。同样地，当下层代码多于1行时，需要用{ }包裹。</p>
<p>接下来我们借助闰年（leap year）判断问题来解释if else语句的使用方法。一般年份的2月只有28天，闰年的2月则多一天，为29天。公历里，闰年的判断口决如下：四年一闰，百年不闰，四百年再闰。具体地，年份满足下述条件之一，即为闰年：</p>
<ul>
<li>能被4整除且不能被100整除；</li>
<li>能够400整除。</li>
</ul>
<p>根据上述条件，我们书写了下述C++程序来进行闰年判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - IfElseStatement</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iYear &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Please enter the year:&quot; &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; iYear;</span><br><span class="line"></span><br><span class="line">    if ((iYear%4==0 &amp;&amp; iYear%100!=0) || (iYear%400==0))&#123;</span><br><span class="line">        cout &lt;&lt; iYear &lt;&lt; &quot; is leap year.&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;There are 29 days in February of &quot; &lt;&lt; iYear &lt;&lt; &quot;.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; iYear &lt;&lt; &quot; is not leap year.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为（输入为2021）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please enter the year:</span><br><span class="line">2021</span><br><span class="line">2021 is not leap year.</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为（输入2020）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Please enter the year:</span><br><span class="line">2020</span><br><span class="line">2020 is leap year.</span><br><span class="line">There are 29 days in February of 2020.</span><br></pre></td></tr></table></figure>

<p>可以看出，当if语句后的表达式成立时，if的下层代码第12 ~ 13行被执行；当if语句后的表达式不成立时，else的下层代码第16行被执行。下图解释了if语句之后的表达式的结构。</p>
<p><img src="http://codelearn.club/images/image-20200217134609686.png" alt="image-20200217134609686"></p>
<p>图4- 闰年判定表达式</p>
<p>下图称为<strong>流程图</strong>（flow chart），它解释了上述代码的执行过程。其中，菱形框表示条件判断，箭头表明程序执行的顺序。根据条件判断的结果不同，程序走向两个不同的分支。</p>
<p><img src="http://codelearn.club/images/image-20200217142933303.png" alt="image-20200217142933303"></p>
<p>图4- 闰年判断流程图</p>
<h3 id="4-2-多分支选择"><a href="#4-2-多分支选择" class="headerlink" title="4.2 多分支选择"></a>4.2 多分支选择</h3><p>else if语句可以帮助我们实现程序的多分支结构。我们通过下述示例来解释多分支结构的实现。</p>
<p>为鼓励节约用电，某地制定了如下的阶梯电价政策：以家庭为计价单位，每位家庭成员享有50度&#x2F;月的基准用电量。</p>
<ul>
<li>人均月用电量 ≤ 50度，电价按0.7元&#x2F;度执行；</li>
<li>50度 &lt; 人均月用电量 ≤ 100度，基准用电量部分按0.7元&#x2F;度执行， 超出部分按1.0元&#x2F;度执行；</li>
<li>100度 &lt; 人均月用电量 ≤ 200度，基准用电量部分按0.7元&#x2F;度执行， 超出部分按1.5元&#x2F;度执行；</li>
<li>人均月用电量 &gt; 200度，基准用电量部分按0.7元&#x2F;度执行， 超出部分按2.0元&#x2F;度执行；</li>
</ul>
<p>显然，上述计价规则涉及多个分支。下述C语言程序给出了解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Project - ElseIfStatement</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">float feeCompute(float fAmount, int iPersonCount)&#123;</span><br><span class="line">    float fAverage = fAmount / iPersonCount;     //人均用电量</span><br><span class="line">    float fFamilyBaseAmt = iPersonCount * 50.0F; //家庭基准用电量</span><br><span class="line">    float fFee = 0;                              //家庭电费</span><br><span class="line"></span><br><span class="line">    if (fAverage &lt;=50.0F)</span><br><span class="line">        fFee = fAmount * 0.7F;</span><br><span class="line">    else if (fAverage &lt;= 100.0F)</span><br><span class="line">        fFee = (fAmount - fFamilyBaseAmt) * 1.0F + fFamilyBaseAmt * 0.7F;</span><br><span class="line">    else if (fAverage &lt;= 200.0F) &#123;</span><br><span class="line">        printf(&quot;Inside function feeCompute: 100 &lt; Average &lt;= 200.\n&quot;);</span><br><span class="line">        fFee = (fAmount - fFamilyBaseAmt) * 1.5F + fFamilyBaseAmt * 0.7F;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        fFee = (fAmount - fFamilyBaseAmt) * 2.0F + fFamilyBaseAmt * 0.7F;</span><br><span class="line"></span><br><span class="line">    return fFee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float fFee =feeCompute(768.1F, 4);</span><br><span class="line">    printf(&quot;Energed used: %.2f kWh, Person count: %d, Electricity bill: %.2f\n&quot;,</span><br><span class="line">           768.1F,4,fFee);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Inside function feeCompute: 100 &lt; Average &lt;= 200.</span><br><span class="line">Energed used: 768.10 kWh, Person count: 4, Electricity bill: 992.15</span><br></pre></td></tr></table></figure>

<p>为了<strong>简化</strong>代码的结构，我们定义了一个名为feeCompute的函数。该函数接受用电量（fAmout）及家庭人数（iPersonCount）两个参数，然后根据阶梯计费规则计算并返回该户的电费总额。</p>
<p>在该函数内部，使用了else if语句来实现多分支结构。如流程图4- 所示，如果第9行的条件成立，执行第10行（然后第20行）；如果第9行的条件不成立，则检查第11行的条件，如果成立，执行第12行（然后第20行）；如果第11行的条件不成立，则检查第13行的条件，如果成立，执行第14 ~ 15行（然后第20行），否则执行第18行（然后第20行）。</p>
<p>综上所述，流程图4- 中的4个方框（分别对应1个if语句的下层代码，2个else if语句的下层代码，1个else语句的下层代码），依据依次进行的条件检查，有且只有一个方框内的代码会被执行。</p>
<p><img src="http://codelearn.club/images/image-20200218000031952.png" alt="image-20200218000031952"></p>
<p>图4- 阶梯电费计算的多分支流程图</p>
<p>有必要重提一下上述代码的第7行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float fFee = 0;</span><br></pre></td></tr></table></figure>

<p>fFee的初始值被设定为0。从程序逻辑上看，这个值在后续if else if else语句肯定会被覆盖（再次赋值），定义fFee变量时如果不赋初值，也不会有什么影响。但从软件工程的角度看，一个变量如果定义时不赋初值，其值是不确定的，有带来软件缺陷的风险。我们的建议是：总是在变量定义时给其赋一个确定的初始值。初学者在当前阶段很难理解这是为什么，所谓老马识途，请照做即可。</p>
<h3 id="4-3-for循环"><a href="#4-3-for循环" class="headerlink" title="4.3 for循环"></a>4.3 for循环</h3><p>天下武功，唯快不破。相对于人脑，计算机最大的优势是速度快而且几乎不犯错。</p>
<p>工作与生活中，经常要进行一些重复的工作，比如生产口罩的口罩机需要不停地将无纺布分段切割，群发垃圾邮件的“机器人”将邮件一封一封地发往一个又一个的收件人邮箱。从事这些重复的工作，是计算机的优势，而计算机做这些重复工作的方法，就是<strong>循环</strong>。C&#x2F;C++里有for循环、while循环及do while循环语句。本节讨论for循环。</p>
<h4 id="4-3-1-传统for循环"><a href="#4-3-1-传统for循环" class="headerlink" title="4.3.1 传统for循环"></a>4.3.1 传统for循环</h4><p>for循环的基本语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (初始化；测试；更新)</span><br><span class="line">	语句;</span><br><span class="line">	</span><br><span class="line">for (初始化；测试；更新) &#123;</span><br><span class="line">	语句;</span><br><span class="line">	...</span><br><span class="line">	语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for关键字后面的括号里包括三个部分，依次是：</p>
<ul>
<li>初始化语句（initialization）： 初始化用于循环控制的变量；</li>
<li>测试表达式（test expression）：进行循环测试，一般为一个逻辑判断表达式；</li>
<li>更新表达式（update expression）: 修改用于循环测试的变量。注意该表达式尾部没有分号。</li>
</ul>
<p>for语句的下层语句称为循环体（loop body），当构成循环体的语句多于1行时，需要使用{ }括起来。如上述语法格式的第4 ~ 8行所示。</p>
<p>请阅读下述用C语言编写的for循环示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - SimplestFor</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iSum = 0;</span><br><span class="line"></span><br><span class="line">    for (int i=0;i&lt;3;i++)&#123;</span><br><span class="line">        printf(&quot;loop i = %d\n&quot;,i);</span><br><span class="line">        iSum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;sum = %d&quot;,iSum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop i = 0</span><br><span class="line">loop i = 1</span><br><span class="line">loop i = 2</span><br><span class="line">sum = 3</span><br></pre></td></tr></table></figure>

<p><img src="http://codelearn.club/images/image-20200218001115683.png" alt="image-20200218001115683"></p>
<p>图4- for循环流程图1</p>
<p>我们借助于流程图4- 来说明上述程序main( )函数的执行过程及其用途。</p>
<table>
<thead>
<tr>
<th>步号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>执行第5行，iSum &#x3D; 0。</td>
</tr>
<tr>
<td>2</td>
<td>执行循环的初始化语句，i &#x3D; 0。</td>
</tr>
<tr>
<td>3</td>
<td>检查循环测试表达式i &lt; 3，此时i值为0，故该表达式为真，允许执行循环体。</td>
</tr>
<tr>
<td>4</td>
<td>顺序执行循环体，即第8 ~ 9行：打印当前i值（0），把当前i值累加进iSum。</td>
</tr>
<tr>
<td>5</td>
<td>执行循环更新表达式i++，i值变为1。</td>
</tr>
<tr>
<td>6</td>
<td>检查循环测试表达式i &lt; 3，此时i值为1，故该表达式为真，允许执行循环体。</td>
</tr>
<tr>
<td>7</td>
<td>顺序执行循环体，即第8 ~ 9行：打印当前i值（1），把当前i值累加进iSum。</td>
</tr>
<tr>
<td>8</td>
<td>执行循环更新表达式i++，i值变为2。</td>
</tr>
<tr>
<td>9</td>
<td>检查循环测试表达式i &lt; 3，此时i值为2，故该表达式为真，允许执行循环体。</td>
</tr>
<tr>
<td>10</td>
<td>顺序执行循环体，即第8 ~ 9行：打印当前i值（2），把当前i值累加进iSum。</td>
</tr>
<tr>
<td>11</td>
<td>执行循环更新表达式i++，i值变为3。</td>
</tr>
<tr>
<td>12</td>
<td>检查循环测试表达式i &lt; 3，此时i值为3，故该表达式为假，结束并跳出循环。</td>
</tr>
<tr>
<td>13</td>
<td>执行第12行，打印iSum的值; 接下来继续执行其它后续代码。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;3;i++)&#123;</span><br><span class="line">    printf(&quot;loop i = %d\n&quot;,i);</span><br><span class="line">    iSum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7 ~ 10行：变量i是在for关键字后面的括号内定义的，这提示i是该for循环内部的局部变量（local variable）▲，它只能在for循环内部被使用，也就是上述程序的第 7 ~ 10行。</p>
<p>请读者务必按照上述流程图4- 人工模拟一遍程序的执行。流程图4- 更简洁地描述了for循环的执行过程。</p>
<p><img src="http://codelearn.club/images/image-20200218130545940.png" alt="image-20200218130545940"></p>
<p>图4- for循环流程图2</p>
<blockquote>
<p>程序调试：借助于程序调试可以帮助读者更好地理解上述for循环执行过程，请扫描阅读。 【? 缺链接】</p>
</blockquote>
<p>下述C程序试图计算1 + 2 + … + 99 + 100的和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - Sum100</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int iSum = 0, i = 0;</span><br><span class="line">    for (i=1;i&lt;100;i++)</span><br><span class="line">        iSum += i;</span><br><span class="line"></span><br><span class="line">    printf(&quot;sum = %d, i = %d.&quot;,iSum,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = 4950, i = 100.</span><br></pre></td></tr></table></figure>

<p>从输出结果看，它失败了，1加到100的和应为5050，而答案是4950，差了100。原因在于该for循环的测试表达式为 i &lt; 100，当i因为更新表达式i++的执行变成100后，for循环要先测试，后执行循环体，显然，100 &lt; 100不成立，第100次的循环未能执行。第9行的输出结果证实，循环结束后，i值确为100。</p>
<p>如果希望上述循环能从1到100（包含100）执行100次，其测试表达式应改为i &lt;&#x3D; 100或者i &lt; 101。</p>
<p>请注意，上述程序中的变量i是在for循环之外，即第5行中定义的，这说明i是main( )函数内的局部变量▲，这使得我们可以在整个main( )函数内部使用变量i（第9行）。</p>
<p>实践中，上述for循环的初始化语句、测试及更新表达式可以是任意合法的语句&#x2F;表达式，甚至可以空缺。当初始化语句及测试表达式空缺时，需要用一个分号占位。灵活运行上述特性，可以写出很”复杂“的for循环。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - ASCII</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char c = 0;</span><br><span class="line"></span><br><span class="line">    for (; c = getch(), c!=13 &amp;&amp; c!=10;) &#123; //初始化语句为空，更新表达式空缺</span><br><span class="line">        putch(c);</span><br><span class="line">        printf(&quot; %d &quot;,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\nProgram exited!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为（在英文输入法下依次输入字符a, b, A, B, 1, 2以及回车）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a 97 b 98 A 65 B 66 1 49 2 50</span><br><span class="line">Program exited!</span><br></pre></td></tr></table></figure>

<p>conio.h头文件是C语言中控制台输入输出（console input &amp; output）头文件，在本程序中，它引入了getch( )及putch( )函数。其中，getch( )负责从控制台读入一个输入字符，返回表示该字符对应ASCII码的int整数；putch( )函数预期接收一个int整数，然后向控制台输出该整数按ASCII码表对应的字符。</p>
<p>第8行：for循环中，初始化语句为空（分号占位），更新表达式空缺，仅提供了循环测试表达式。该for循环执行过程中， 初始化和更新两步将被省略。测试表达式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = getch(), c!=13 &amp;&amp; c!=10;</span><br></pre></td></tr></table></figure>

<p>这个测试表达式以逗号为界，分成了两个表达式。这个<strong>逗号（comma）</strong>其实是一个操作符，它保证了如下两点：</p>
<ul>
<li>逗号左边的表达式c &#x3D; getch( )比逗号右边的表达式先执行；这样，当逗号右边的表达式c!&#x3D;13 &amp;&amp; c!&#x3D;10执行时，c已经取得了从getch( )读取的新字符。</li>
<li>将逗号右方表达式的值作为整个测试表达式的结果。本例中，左表达式c &#x3D; getch( )在赋值后返回c作为表达式的值，右表达式也会返回布尔运算的结果，但逗号表达式确保将右表达式，即c!&#x3D;13 &amp;&amp; c!&#x3D;10的结果作为整个循环测试表达式的结果。</li>
</ul>
<p>本程序中，作者期望把按下回车键作为程序停止执行的条件，但在不同的操作系统及执行环境下，按下回车键后，getch( )得到的字符却不尽相同，有的是’\r’，即”返回行首“符，对应ASCII码13，有的是’\n’，即”换行符“，对应ASCII码10，甚至有的系统13和10会顺序返回。为了兼容上述不同情况，循环的测试表达式同时检查了13和10两个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (; c = getch(), c!=13 &amp;&amp; c!=10;) &#123; //初始化语句为空，更新表达式空缺</span><br><span class="line">    putch(c);</span><br><span class="line">    printf(&quot; %d &quot;,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8 ~ 11行：上述for循环借助于测试表达式，不断从控制台读取字符，如果是普通字符，执行循环体：输出该字符（第9行），输出该字符的ASCII码值（第10行）；如果读入的字符等于13或10，即是由回车键导致的“返回行首”符或”换行“符，测试表达式为假，结束循环，打印“Program exited!”信息（第13行）。</p>
<p>上述程序的输出结果证实：a的ASCII码为97， b为98，A为65，B为66 … 它们是连续的。</p>
<p>关于<strong>逗号操作符（comma operator）</strong>，有必要进行更进一步的讨论。请读者考虑下述C语言程序的执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - Comma</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   int a = 0, b = 0;</span><br><span class="line"></span><br><span class="line">   a = b++, 3;</span><br><span class="line"></span><br><span class="line">   printf(&quot;a = %d, b = %d&quot;,a,b);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照本节中提及的逗号操作符的语法含义，读者可能会对第7行代码进行如下解读：</p>
<ul>
<li>逗号左表达式b++先执行，b值由0变1；</li>
<li>逗号右表式的值3作为整个表达式的结果返回，然后赋值给a，a值变为3；</li>
<li>执行结果为： a &#x3D; 3, b &#x3D; 1。</li>
</ul>
<p>但真实的执行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 0, b = 1</span><br><span class="line">a = b++, 3;</span><br></pre></td></tr></table></figure>

<p>第7行：编译器的真正解读如下。</p>
<ul>
<li>逗号操作符的优先级低于赋值操作符，所以a &#x3D; b++被视为逗号的左表达式。逗号左表达式a &#x3D; b++先执行，b++先取值，后递增，故a被赋值为b之前的初始值0；</li>
<li>逗号右表达式3后执行，其返回值3作为整个逗号表达式的值返回。由于返回后没有”人“需要它，所以直接被舍弃。</li>
</ul>
<p>本例中，如果期望a被赋值为3，第7行应修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (b++,3);</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-基于范围的for循环"><a href="#4-3-2-基于范围的for循环" class="headerlink" title="4.3.2 基于范围的for循环"></a>4.3.2 基于范围的for循环</h4><p>基于范围的for循环<strong>【C++ 11】</strong>比传统的for循环语法简单得多。</p>
<p>假设某商量有4种商品，其2月18日的价格依次为1030.23f, 2828.12f, 76.0f, 992.0f，2月19日统一加价10%。现要求使用表格打印显示上述商品在2月18、19日的价格变化。C++程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - RangeFor</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float fPrices[] &#123;1030.23f, 2828.12f, 76.0f, 992.0f&#125;; //2月18日的商品价格</span><br><span class="line"></span><br><span class="line">    int idx = 0;</span><br><span class="line">    cout &lt;&lt; &quot;idx\t2/18\t2/19\n&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;----------------------------\n&quot;;</span><br><span class="line">    for (auto x:fPrices)</span><br><span class="line">        cout &lt;&lt; ++idx &lt;&lt; &quot;\t&quot; &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; x*1.1f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">idx     2/18    2/19</span><br><span class="line">----------------------------</span><br><span class="line">1       1030.23 1133.25</span><br><span class="line">2       2828.12 3110.93</span><br><span class="line">3       76      83.6</span><br><span class="line">4       992     1091.2</span><br><span class="line">float fPrices[] &#123;1030.23f, 2828.12f, 76.0f, 992.0f&#125;; //2月18日的商品价格</span><br></pre></td></tr></table></figure>

<p>第6行：fPrices变量名后增加了一个方括号，这表明fPrices不是float类型的变量，而是一个数组▲，这个数组可以存储多个float类型的值。{ }包裹的部分称为初始化列表（initializer list）<strong>【C++ 11】</strong>，编译器会自动统计其中的元素个数以便为fPrices数组分配恰当的存储空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (auto x:fPrices)</span><br><span class="line">    cout &lt;&lt; ++idx &lt;&lt; &quot;\t&quot; &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; x*1.1f &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 12行：auto x:fPrices以冒号为界面，分为两部分。冒号之后为被遍历的数据集，此处为fPrices数组，它表明了循环的范围。冒号之前为循环取值变量。由于C&#x2F;C++的数组只能存储同一类型的值，即fPrices数组内部元素全部为float类型，所以此处，我们使用auto进行类型推断，编译器会推断确定x变量的类型，结果为float。被遍历的数据集有多少个元素，循环体代码（第12行）就会执行多少次，每次循环开始前，x会自动从fPrices数组中按顺序取值。</p>
<p>++idx是第3章中讨论过的递增操作符，它先递增，后取值。在循环过程中，idx表示输出数据的行号。每执行一次循环体，idx值都会增加1。</p>
<p>程序的执行结果证实，for循环遍历了fPrices数组，依次打印了其中的原价格及加价后的价格。</p>
<p>此外，C++ 也允许直接把初始化列表放在基于范围for循环的冒号后面，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int x:&#123;1,3,5,7,9&#125;)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span><br></pre></td></tr></table></figure>

<h3 id="微实践-质数判定"><a href="#微实践-质数判定" class="headerlink" title="微实践 - 质数判定"></a>微实践 - 质数判定</h3><p>质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。根据这一数学定义，我们用C语言设计了isPrime( )函数及其测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Project - IsPrime</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">bool isPrime(int);         //函数的声明</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;sizeof(bool) = %lld.\n&quot;,sizeof(bool));</span><br><span class="line"></span><br><span class="line">    printf(&quot;isPrime(-2):\t%s.\n&quot;, isPrime(-2)?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    printf(&quot;isPrime(3):\t%s.\n&quot;, isPrime(3)?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    printf(&quot;isPrime(4):\t%s.\n&quot;, isPrime(4)?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    printf(&quot;isPrime(117):\t%s.\n&quot;, isPrime(117)?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isPrime(int n) &#123;     //函数的定义</span><br><span class="line">    if (n&lt;=1)</span><br><span class="line">        return false;</span><br><span class="line">    for (int i=2;i&lt;n;i++)</span><br><span class="line">        if (n % i == 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sizeof(bool) = 1.</span><br><span class="line">isPrime(-2):    No.</span><br><span class="line">isPrime(3):     Yes.</span><br><span class="line">isPrime(4):     No.</span><br><span class="line">isPrime(117):   No.</span><br></pre></td></tr></table></figure>

<p>本书第2章曾经提及C语言没有bool类型，那么上述C语言代码中的bool类型从何而来？第3行引入了stdbool.h头文件，在该头文件中，我们可以找到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define bool	_Bool</span><br><span class="line">#define true	1</span><br><span class="line">#define false	0</span><br></pre></td></tr></table></figure>

<p>由于上述#define预处理指令▲的存在，源代码经过预处理器▲处理后，其中的bool全部被文本替换为_Bool，其中的true和false则被替换为1和0。</p>
<p>在C++语言中，bool，true，false均为关键字。而上述代码中，bool，true，false只是头文件引入的代号，分别对应_Bool，1和0。_Bool是C99引入的“布尔类型”，在某些编译器中，它可以只占1个比特。C99并没有定义关键字true及false，因此stdbool.h通过#define对其进行了“定义”。</p>
<p>第17 ~ 25行<strong>定义</strong>了函数isPrime( )，请注意，这个定义位于main( )函数之后。为了在main( )函数中使用isPrime( )函数，第5行代码给出了isPrime( )函数的<strong>声明</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool isPrime(int);         //函数的声明</span><br></pre></td></tr></table></figure>

<p>该声明提供了如下的信息给编译器：函数的名称，函数的返回值类型，函数的参数个数及类型。对于编译器而言，上述信息已经足以判定第10行的函数调用 isPrime(-2) 在形上是合法的，所以编译器会愉快地通过对第10行代码的审查。请读者注意上述函数声明中参数列表省略了形式参数的名称，这是允许的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(bool) = %lld.\n&quot;,sizeof(bool));</span><br></pre></td></tr></table></figure>

<p>第8行：从输出结果看，sizeof(bool)，也就是sizeof(_Bool)的返回值为1。这<strong>可能</strong>提示在作者的开发环境里，_Bool类型占据1个字节。之所以说是可能，因为sizeof操作符以字节为单位，1个比特显然不等于0字节。由于sizeof操作符返回值类型为unsigned long long，该行printf( )中的占位符如果是%d，编译器可能会给出警告。因为%d通常与int类型对应，从unsigned long long到int类型的转换存在超储值范围的可能。将该占位符修改为%lld可以消除上述警告。</p>
<p>第17 ~ 25行：isPrime(n)函数用于判定n是否是质数，是的话返回true，否则返回false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (n&lt;=1)</span><br><span class="line">    return false;</span><br></pre></td></tr></table></figure>

<p>第18 ~ 19行：排除n小于等于1的情况，如果成立，返回假。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i=2;i&lt;n;i++)</span><br><span class="line">    if (n % i == 0)</span><br><span class="line">        return false;</span><br></pre></td></tr></table></figure>

<p>第20 ~ 22行：通过for循环逐一考查2 ~ n-1（不包含n）的整数i，如果n能被i整除，说明n不是质数，返回假。请注意，第21 ~ 22行的循环体虽书写成两行，但可以认为第22行是第21行if语句的下层代码。在逻辑上，第21 ~ 22行是一条语句，所以该for循环中，作为循环体的第21 ~ 22行没有用{ }包裹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return true;</span><br></pre></td></tr></table></figure>

<p>第24行：如果在前述for循环中没有发现除1及n自身外的其它因数，说明n为质数，返回真。</p>
<p>在isPrime( )函数定义中有3个return语句，这意味着根据n值的不同，isPrime( )函数可能从这3个return语句中的其中1个返回。由于这3个return语句所返回的都是bool类型（实为_Bool类型），故合法。</p>
<h3 id="4-4-break语句"><a href="#4-4-break语句" class="headerlink" title="4.4 break语句"></a>4.4 break语句</h3><p>为了理解break语句的作用，我们试图完成下述任务。</p>
<p>任务：找出大于等于10000的第1个质数。</p>
<p>分析：在得到结果之前，我们并不知道大于等于10000的第1个质数是什么，因此，我们从10000开始，逐一交给微实践 - 质数判定中定义的isPrime( )函数进行判定。当发现第1个质数后，任务达成，后续的检查没有继续进行的必要，程序应停止。</p>
<p>基于上述分析，我们使用C语言实现了下述程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - BreakExample</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">bool isPrime(int n) &#123;     //函数的定义</span><br><span class="line">     ...  //详见微实践 - 质数判定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Try to find first prime number(&gt;=10000):\n&quot;);</span><br><span class="line"></span><br><span class="line">    int iPrime = -1;</span><br><span class="line">    for (int i=10000;;i++)&#123;</span><br><span class="line">        if (isPrime(i))&#123;</span><br><span class="line">            iPrime = i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d checked, not prime number.\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;First prime number(&gt;=10000) is: %d.&quot;,iPrime);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Try to find first prime number(&gt;=10000):</span><br><span class="line">10000 checked, not prime number.</span><br><span class="line">10001 checked, not prime number.</span><br><span class="line">10002 checked, not prime number.</span><br><span class="line">10003 checked, not prime number.</span><br><span class="line">10004 checked, not prime number.</span><br><span class="line">10005 checked, not prime number.</span><br><span class="line">10006 checked, not prime number.</span><br><span class="line">First prime number(&gt;=10000) is: 10007.</span><br><span class="line">int iPrime = -1;</span><br></pre></td></tr></table></figure>

<p>第12行：iPrime变量用于保存找到的质数，初始值定为-1。初值定为-1的理由是负数明显不是质数，当程序编写错误导致错误结果时，容易通过该变量的-1初值发现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i=10000;;i++)&#123;</span><br></pre></td></tr></table></figure>

<p>第13行：for关键字后面的括号内给出了初始化语句和更新表达式，但测试表达式空缺。这说明for循环没办法通过测试表达式终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (isPrime(i))&#123;</span><br><span class="line">    iPrime = i;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 17：将循环变量i交给isPrime( )函数进行判定，如果是质数，首先将i赋值给iPrime保存，然后使用break语句终止将跳出循环。本程序中，当break语句执行后，程序的执行点将由第16行直接跳至循环外的第21行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;First prime number(&gt;=10000) is: %d.&quot;,iPrime);</span><br></pre></td></tr></table></figure>

<p>第21行：输出找到的质数iPrime。</p>
<p>上述for循环中，我们之所以敢于放弃测试表达式，是基于我们的数学知识：10000之后一定会有质数，即第16行的break语句一定会执行并导致循环终止。当因为程序编写错误导致循环无法终止，这种情况我们称之为“死循环”。</p>
<p>从执行结果可以看出，上述程序依次检查了10000 ~ 10006，均不是质数。在检查10007时，isPrime( )返回真，执行break语句结束了循环。</p>
<p><img src="http://codelearn.club/images/image-20200220111207461.png" alt="image-20200220111207461"></p>
<p>图4- break跳转示意</p>
<p>图4- 展示了本程序中当break语句执行时的执行点跳转。可以看到，<strong>break语句跳出循环，程序执行点跳转到循环后语句</strong>。</p>
<p>【？缺：双重循环内内层循环中的break语句执行时的效果，适补】</p>
<h3 id="4-5-continue语句"><a href="#4-5-continue语句" class="headerlink" title="4.5 continue语句"></a>4.5 continue语句</h3><p>为了理解continue语句的作用，我们试图完成下述任务。</p>
<p>任务：找出并打印100以内的全部质数。</p>
<p>分析：将整数2 ~ 100逐一交给isPrime( )函数进行判定，如果是，打印出来。</p>
<p>基于上述分析，我们用C语言实现了下述程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - ContinueExample</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">bool isPrime(int n) &#123;     //函数的定义</span><br><span class="line">     ...  //详见微实践 - 质数判定</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;Try to find all prime number(&lt;=100):\n&quot;);</span><br><span class="line"></span><br><span class="line">    int iFound = 0;       //发现的质数个数</span><br><span class="line">    for (int i=2;i&lt;=100;i++)&#123;</span><br><span class="line">        if (!isPrime(i))</span><br><span class="line">            continue;</span><br><span class="line">        iFound++;</span><br><span class="line">        printf(&quot;%d, &quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n%d prime numbers been found.&quot;,iFound);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Try to find all prime number(&lt;=100):</span><br><span class="line">2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,</span><br><span class="line">25 prime numbers been found.</span><br><span class="line">int iFound = 0;       //发现的质数个数</span><br></pre></td></tr></table></figure>

<p>第12行：iFound变量存储发现的质数个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!isPrime(i))</span><br><span class="line">    continue;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 15行：在循环体内，对i进行质数判定，如果不是（注意逻辑非操作符！），执行continue语句，该语句的执行放导致本次循环的剩余代码，即第16 ~ 17被跳过，直接尝试下一轮循环。当然，按照for循环自身的流程，会先执行更新表达式（i++），然后再测试（i&lt;&#x3D;100），测试通过则再次执行循环体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iFound++;</span><br><span class="line">printf(&quot;%d, &quot;,i);</span><br></pre></td></tr></table></figure>

<p>第16 ~ 17行：由于前述if判断及continue语句的存在，程序执行点到达第16行即意味着当前轮循环中的i是一个质数。这两行代码将iFound递增1，并将质数i打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\n%d prime numbers been found.&quot;,iFound);</span><br></pre></td></tr></table></figure>

<p>第20行：当for循环因测试（i&lt;&#x3D;100)测试失败终止后，程序执行点到达第20行，该行负责打印发现的质数的总个数（iFound）。</p>
<p><img src="http://codelearn.club/images/image-20200220132930741.png" alt="image-20200220132930741"></p>
<p>图4- continue跳转示意</p>
<p>图4- 展示了本程序中当continue语句执行时的执行点跳转。可以看到，<strong>continue的执行并不会结束整个循环，它只是略过本轮循环体的剩余代码，直接跳转至下一轮循环</strong>。本例中，按照for循环自身的机制，continue执行后，下一条被执行的语句应该是更新表达式（i++)，然后再根据测试表达式（i&lt;&#x3D;100）的结果来决定是否再次执行循环体。</p>
<h3 id="微实践-程序的断点调试"><a href="#微实践-程序的断点调试" class="headerlink" title="微实践 - 程序的断点调试"></a>微实践 - 程序的断点调试</h3><p><a target="_blank" rel="noopener" href="http://codelearn.club/2020/02/qtdebug/">http://codelearn.club/2020/02/qtdebug/</a></p>
<h3 id="4-6-while循环"><a href="#4-6-while循环" class="headerlink" title="4.6 while循环"></a>4.6 while循环</h3><p>while循环的基本语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while (测试表达式)</span><br><span class="line">    语句;</span><br><span class="line"></span><br><span class="line">while (测试表达式)  &#123;</span><br><span class="line">    语句;</span><br><span class="line">    ...</span><br><span class="line">    语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while关键字之后的括号内包含一个测试表达式。当循环体的构成语句多于1行时，循环体部分需要用{ }包裹。</p>
<p>while循环先检查测试表达式的值，如果为真，执行循环体；如果为假，结束循环。每执行完一轮循环体代码，会再次检查测试表达式，为真继续，为假结束。</p>
<p>为便于解释，我们编写了下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - Parrot1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;I am a parrot, say something to me.&quot; &lt;&lt; endl;</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    while (s!=&quot;q&quot;)&#123;</span><br><span class="line">        getline(cin,s);</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Bye, see you later.&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I am a parrot, say something to me.</span><br><span class="line">Good morning.</span><br><span class="line">Good morning.</span><br><span class="line">Run Forrest!</span><br><span class="line">Run Forrest!</span><br><span class="line">q</span><br><span class="line">q</span><br><span class="line">Bye, see you later.</span><br></pre></td></tr></table></figure>

<p>说明：第2、4、6行为操作者的输入。</p>
<p>我们对照图4- 来解释上述程序的执行过程及其功能。</p>
<table>
<thead>
<tr>
<th>步号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>第6行引入了std名字空间。作者故意将该行移至此处，以便告知读者，该行代码并不是必须出现在文件的开头处。</td>
</tr>
<tr>
<td>2</td>
<td>第8行输出了一行文字：我是<strong>鹦鹉</strong>，请跟我说话。第9号定义了一个string类型的变量s，并初始化其值为一个字空符串。</td>
</tr>
<tr>
<td>3</td>
<td>检查测试表达式s !&#x3D; “q”，此时s的为空，表达式为真，准备执行循环体。</td>
</tr>
<tr>
<td>4</td>
<td>循环体执行：第11行getline( )函数从cin读取一行输入”Good morning.”，存入s对象。第12行将s输出给cout，控制台输出”Good morning.”。</td>
</tr>
<tr>
<td>5</td>
<td>检查测试表达式s !&#x3D; “q”，此时s的值为”Good morning.”，表达式为真，准备执行循环体。</td>
</tr>
<tr>
<td>6</td>
<td>循环体执行：第11行getline( )函数从cin读取一行输入”Run Forrest!”，存入s对象。第12行将s输出给cout，控制台输出”Run Forrest!”。</td>
</tr>
<tr>
<td>7</td>
<td>检查测试表达式s !&#x3D; “q”，此时s的值为”Run Forrest!”，表达式为真，准备执行循环体。</td>
</tr>
<tr>
<td>8</td>
<td>循环体执行：第11行getline( )函数从cin读取一行输入”q”，存入s对象。第12行将s输出给cout，控制台输出”q”。</td>
</tr>
<tr>
<td>9</td>
<td>检查测试表达式s !&#x3D; “q”，此时s的值为”q”，表达式为假，退出循环。</td>
</tr>
<tr>
<td>10</td>
<td>第15行，输出道别字符串。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><img src="http://codelearn.club/images/image-20200220164248419.png" alt="image-20200220164248419"></th>
<th><img src="http://codelearn.club/images/image-20200220165524724.png" alt="image-20200220165524724"></th>
</tr>
</thead>
<tbody><tr>
<td>图4- while循环的结构</td>
<td></td>
</tr>
</tbody></table>
<p>综上， 上述程序通过while循环不断读取输入，并将得到的输入字符串输出给控制台，就像鹦鹉重复主人的话一样。如果操作者输入q，则循环测试失败，程序结束退出。</p>
<p>请读者注意观察图4- 的流程，while循环<strong>先检查（测试表达式），后执行（循环体）</strong>，在极端情况下，循环体有可能执行0次。</p>
<p>对上述程序略作修改，可以避免在“鹦鹉”重复主人的命令q，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - Parrot2</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;I am a parrot, say something to me.&quot; &lt;&lt; endl;</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line">    while (true)&#123;</span><br><span class="line">        getline(cin,s);</span><br><span class="line">        if (s==&quot;q&quot;)</span><br><span class="line">            break;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Bye, see you later.&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">while (true)&#123;</span><br></pre></td></tr></table></figure>

<p>第10行：测试表达式恒为真，这意味着放弃了循环测试表达式的检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (s==&quot;q&quot;)</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：当输入字符串为”q”时，执行break语句结束并跳出循环。这同时意味着第14行的代码只有当s不为”q”时才有机会执行。</p>
<p>事实上，while循环只是for循环的一个简化版本。上述鹦鹉程序（Parrot1），也可以用for循环实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (; s!=&quot;q&quot;; )&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个for循环，没有初始化语句，也没有更新表达式，只有测试表达式。它的执行过程与Parrot1中的while循环完全相同。</p>
<h3 id="微实践-九层之台，起于累土"><a href="#微实践-九层之台，起于累土" class="headerlink" title="微实践 - 九层之台，起于累土"></a>微实践 - 九层之台，起于累土</h3><p>＂九层之台，起于累土＂出自春秋·楚·李耳《老子》第64章：＂合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下＂。不论起点有多低，只要不断成长，假以时日，终有所成。</p>
<p>一张厚度为0.1毫米的足够大的纸，每对折一次，厚度翻倍。问： 这张纸对折多少次以后将达到世界最高峰珠穆朗玛峰的高度？如果凭直觉，作者觉得再怎样也要上千次对折才行。</p>
<p>我们用C语言编写了下述程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - Everest</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iCounter = 0;              //对折次数</span><br><span class="line">    float fThickness = 0.0001F;    //纸厚，单位米</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (fThickness &gt; 8844.43F) //超过珠峰高度就停止循环</span><br><span class="line">            break;</span><br><span class="line">        else&#123;</span><br><span class="line">            fThickness *= 2;       //对折一次厚度翻倍</span><br><span class="line">            iCounter++;            //对折次数加1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Thickness = %.2f after %d folds, exceeding Everest.&quot;,</span><br><span class="line">           fThickness,iCounter);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thickness = 13421.77 after 27 folds, exceeding Everest.</span><br><span class="line">int iCounter = 0;              //对折次数</span><br><span class="line">float fThickness = 0.0001F;    //纸厚，单位米</span><br></pre></td></tr></table></figure>

<p>第5 ~ 6行：iCounter记录纸的对折次数；fThickness记录对折后的纸厚。</p>
<p>第8 ~ 15行：通过一个while循环确定超过珠峰高度所需要的最小对折次数。</p>
<ul>
<li>while (1)将整数1视为布尔值，按非零即真原则，总是真，执行一个“死”循环。</li>
<li>循环内对对折后的纸厚与珠峰高度比较，如果大于珠峰高度，break跳出循环。</li>
<li>每次对折纸厚翻倍，iCounter记数器加1。</li>
</ul>
<p>输出结果显示所需对折次数为27次。你没有看错，作者也没有算错，就是27次！上面的代码使用循环，完全出于教学目的。显然，求超过珠峰高度的最小对折次数，下述C语言代码更直接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - EverestSimple</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;    //引入log2()函数</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double t = log2(8844.43/0.0001);</span><br><span class="line">    printf(&quot;%f&quot;,t);</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n%f&quot;,0.0001 * pow(2,27));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">26.398266</span><br></pre></td></tr></table></figure>

<p>log2(x)函数计算并返回x的以2为底的对数。如果要验证27次对折后纸的厚度，可用下述C语言代码，直接求0.0001 * 227。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%f&quot;,0.0001 * pow(2,27));</span><br></pre></td></tr></table></figure>

<p>将上述代码置入一个main( )函数中执行，其执行结果应为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13421.772800</span><br></pre></td></tr></table></figure>

<p>1万3千多米，这就是0.1mm厚的纸对折27次之后的厚度。实践中，这个不太可能做到，对折半个珠峰高度厚的纸，人类的体力或者机械都办不到，奥特曼估计也不行。</p>
<h3 id="4-7-do-while循环"><a href="#4-7-do-while循环" class="headerlink" title="4.7 do while循环"></a>4.7 do while循环</h3><p>我们通过do while版本的鹦鹉程序也说明do while与while循环的异同。C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - Parrot3</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;I am a parrot, say something to me.&quot; &lt;&lt; endl;</span><br><span class="line">    string s = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        getline(cin,s);</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    while (s!=&quot;q&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Bye, see you later.&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I am a parrot, say something to me.</span><br><span class="line">Good morning.</span><br><span class="line">Good morning.</span><br><span class="line">Run Forrest!</span><br><span class="line">Run Forrest!</span><br><span class="line">q</span><br><span class="line">q</span><br><span class="line">Bye, see you later.</span><br></pre></td></tr></table></figure>

<p>说明：第2、4、6行为操作者的输入。</p>
<p>如下图4- 所示，do while循环与while循环的主要区别是<strong>先执行（循环体），后检查（测试表达式）</strong>。也就是说，无论测试表达式真假，循环体至少会被执行一次。</p>
<p>上述程序的执行过程请读者参照流程图，自行模拟。</p>
<p><img src="http://codelearn.club/images/image-20200220183333692.png" alt="image-20200220183333692"></p>
<p>图4- do while循环的结构</p>
<p>对于程序设计而言，do while循环并不是必须使用的技术。其相关功能，完全可以通过while或者for循环来实现。坦率地讲，作者上一次使用do while循环，大概是作为学生参加C语言考试的时候。</p>
<h3 id="4-8-switch分支"><a href="#4-8-switch分支" class="headerlink" title="4.8 switch分支"></a>4.8 switch分支</h3><p>除了else if语句外，switch语句也可以实现多分支程序结构。switch语句的基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch (整数表达式) &#123;</span><br><span class="line">case 标签1:</span><br><span class="line">        ...</span><br><span class="line">case 标签k:</span><br><span class="line">    语句(一条或多条);</span><br><span class="line">    break;</span><br><span class="line">...        </span><br><span class="line">case 标签n：</span><br><span class="line">    语句(一条或多条);</span><br><span class="line">    break;</span><br><span class="line">default:</span><br><span class="line">    语句(一条或多条);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在switch关键字之后的括号内包含一个整数表达式（integer-expression）。所谓整数表达式，是指该表达式的值必须是整数或者可以转换成整数的类型，包括但不限于char，int， short，long long以及以后要讨论的枚举型▲。</p>
<p>接下来的{ }内包裹了1个到多个以冒号结尾的case子句，子句中的标签也必须是整数或者可以转换成整数的字符或者枚举类型。程序执行时，将从上到下将整数表达式的值与case后面的标签进行比较，如果相等，则执行后续代码，直至遇到break语句跳出switch结构或者遇到反花括号 } 为止。如果检查完所有的标签，都不相等，则执行default子句之后的代码。 在上述语法格式中，default子句是可选的（optional）。</p>
<p>为了消解读者的疑惑，我们用C语言编写了下述程序，它要求操作者输入表示月份的整数（1 ~ 12），然后输出该月的天数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//Month</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iMonth = 1;</span><br><span class="line">    printf(&quot;Please input month number(1~12):&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;iMonth);</span><br><span class="line"></span><br><span class="line">    switch (iMonth)&#123;</span><br><span class="line">    case 1:</span><br><span class="line">    case 3:</span><br><span class="line">    case 5:</span><br><span class="line">    case 7:</span><br><span class="line">    case 8:</span><br><span class="line">    case 10:</span><br><span class="line">    case 12:</span><br><span class="line">        printf(&quot;There are 31 days in %dth month.\n&quot;,iMonth);</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        printf(&quot;There are 28 or 29 days in %dth month.\n&quot;,iMonth);</span><br><span class="line">        //break;  //break缺失</span><br><span class="line">    case 4:</span><br><span class="line">    case 6:</span><br><span class="line">    case 9:</span><br><span class="line">    case 11:</span><br><span class="line">        printf(&quot;There are 30 days in %dth month.\n&quot;,iMonth);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        printf(&quot;Wrong month number.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，不同的输入值将导致不同的执行结果。</p>
<ul>
<li>当输入为7时，上述程序的执行结果如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input month number(1~12):7</span><br><span class="line">There are 31 days in 7th month.</span><br></pre></td></tr></table></figure>

<p>执行过程：switch语句从上到下检查case标签，在第13行（case 7）成功匹配，执行后续代码第17行，第18行（break）。break语句的执行使用程序跳出switch结构至第32行（return 0）。</p>
<ul>
<li>当输入为2时，上述程序的执行结果如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Please input month number(1~12):2</span><br><span class="line">There are 28 or 29 days in 2th month.</span><br><span class="line">There are 30 days in 2th month.</span><br></pre></td></tr></table></figure>

<p>执行过程：switch语句从上到下检查case标签，在第19行（case 2）成功匹配，执行后续代码第20行，第26行，第27行（break）。break语句的执行使用程序跳出switch结构至第32行（return 0）。显然，第26行的执行（表示该月有30天）是多余而且错误的。作者有意构造了这一错误，请读者注意，第21行的break语句被注释掉了。</p>
<ul>
<li>当输入19时，上述程序的执行结果如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input month number(1~12):19</span><br><span class="line">Wrong month number.</span><br></pre></td></tr></table></figure>

<p>执行过程：19无法匹配所有的case子句，程序执行default子句后的第29行。</p>
<p>建议读者执行并尝试输入其它值，如1，6，12等，体会switch语句的程序分支功能。</p>
<h3 id="4-9-goto语句"><a href="#4-9-goto语句" class="headerlink" title="4.9 goto语句"></a>4.9 goto语句</h3><p>C语言从更早期的 Fortran语言继承了goto语句，其基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标签:</span><br><span class="line">   语句; </span><br><span class="line">   ...</span><br><span class="line">   语句; </span><br><span class="line">   </span><br><span class="line">goto 标签;</span><br></pre></td></tr></table></figure>

<p>当goto语句被执行时，程序将直接跳转到对应标签所在的代码行。上述格式中，第1行的标签后面有一个冒号，这是语法要求。此外，标签定义（第1行）既可位于对应的goto语句前，也可位于goto语句后，也就是说，goto语句既可以实现往前跳转，也可以实现往后跳转。</p>
<p>为了解读goto语句的用法，我们构造了下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - GotoExample</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i &#123;1&#125;;</span><br><span class="line">    int sum &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    loop:</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    if (i&lt;=100)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = 5050</span><br></pre></td></tr></table></figure>

<p>上述程序使用goto语句构造了一个循环，计算1 + 2 + … + 100的和。读者可以把上述代码的第10 ~ 11行视作循环体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br></pre></td></tr></table></figure>

<p>第9行：定义了标签loop。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (i&lt;=100)</span><br><span class="line">    goto loop;</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行： 当i&lt;&#x3D;100时，使用goto语句跳转至loop标签，即第9行。</p>
<p>图4- 中的箭头展示了当上述程序中第13行的goto语句执行时，程序的跳转方向。</p>
<p><img src="http://codelearn.club/images/image-20200221155617592.png" alt="image-20200221155617592"></p>
<p>图4- goto跳转示意图</p>
<p>goto语句的执行效率很高，但对初学者非常不友好，容易导致程序逻辑混乱、资源泄露等方面的问题。事实上，通过组合使用if else，for&#x2F;while循环，break，continue等可以避免goto语句的使用。我们给初学者的建议是：<strong>不要使用goto语句</strong>。</p>
<p>对于那些有丰富经验的程序员而言，goto语句的恰当使用，除了获得较高的执行效率之外，有时还可以简化程序的结构。在Linux操作系统的内核代码中，我们可以看到大量的goto语句。当前最流行的手机操作系统之一的Android，基于Linux内核。</p>
<h2 id="5-数组及字符串"><a href="#5-数组及字符串" class="headerlink" title="5. 数组及字符串"></a>5. 数组及字符串</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h3><p>数组（array）可以在连续的空间里存储相同类型的多个对象。当定义一个数组时，需要提供下述信息：</p>
<ul>
<li>数组内元素（element）的数据类型；</li>
<li>数组的名称；</li>
<li>数组内的元素个数。</li>
</ul>
<p>定义一个数组的通用语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素类型 数组名[元素个数];</span><br></pre></td></tr></table></figure>

<p>我们通过下述C语言示例来初步理解一维数组的定义和使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - Scores</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float scores[5] = &#123;77,92.5,68,99,100&#125;;</span><br><span class="line">    scores[0] = 88;</span><br><span class="line"></span><br><span class="line">    printf(&quot;sizeof(scores) = %lld\n&quot;, sizeof(scores));</span><br><span class="line">    printf(&quot;scores = %p\n&quot;,scores);</span><br><span class="line">    printf(&quot;%p - %p - %p - %p - %p\n&quot;, &amp;scores[0], &amp;scores[1],</span><br><span class="line">            &amp;scores[2], &amp;scores[3], &amp;scores[4]);</span><br><span class="line"></span><br><span class="line">    float fSum  = 0;</span><br><span class="line">    for (int i=0;i&lt;5;i++)</span><br><span class="line">        fSum += scores[i];</span><br><span class="line"></span><br><span class="line">    float fAverage = fSum / 5;</span><br><span class="line">    printf(&quot;Average score = %.2f&quot;,fAverage);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(scores) = 20</span><br><span class="line">scores = 000000000061FE00</span><br><span class="line">000000000061FE00 - 000000000061FE04 - 000000000061FE08 - 000000000061FE0C - 000000000061FE10</span><br><span class="line">Average score = 89.50</span><br></pre></td></tr></table></figure>

<p>说明：读者在自己计算机上的运行结果中的第2 ~ 3行很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float scores[5] = &#123;77,92.5,68,99,100&#125;;</span><br></pre></td></tr></table></figure>

<p>第5行：定义了一个名为scores的数组，该数组有5个元素，元素的类型为float。等号之后的初始化列表给出了5个元素的初始值。本例中，我们假设scores数组存储了某位同学某学期所修的5门课程的成绩。</p>
<p><img src="http://codelearn.club/images/image-20200221205428200.png" alt="image-20200221205428200"></p>
<p>图5- 数组的内存布局</p>
<p>说明：数组的内存地址是在运行时刻由操作系统分配的，所以读者在自己计算机上获得的scores数组的内存地址很可能与图5- 不同。图中的每个单元格表示4个字节的内存空间，每4个字节正好可以存入一个float类型的对象。</p>
<p>图5- 给出了scores数组在内存中的布局图。从该图中可以看到，数组由5个float对象构成，每个float对象占据4个字节，<strong>从内存低地址往内存高地址依次排列</strong>。整个数组占据4 x 5 &#x3D; 20个字节的内存空间。我们给数组的5个元素依次编号为0，1，2，3，4，这个编号称之为数组元素的<strong>下标（subscript）</strong>或<strong>索引（index）</strong>。请读者注意，同大多数程序设计语言一样，C&#x2F;C++中对数组元素的计数从0开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[0] = 88</span><br></pre></td></tr></table></figure>

<p>第6行：使用[ ]操作符访问scores数组下标为0的元素，通过赋值操作符将其值修改为88。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(scores) = %lld\n&quot;, sizeof(scores));</span><br></pre></td></tr></table></figure>

<p>第8行：打印通过sizeof操作符获取的scores数组的大小，输出证实，其值为20个字节。刚好等于单个元素尺寸 x 元素个数，即4 x 5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;scores = %p\n&quot;,scores);</span><br></pre></td></tr></table></figure>

<p>第9行：将数组名scores视为一个地址（指针），输出其值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%p - %p - %p - %p - %p\n&quot;, &amp;scores[0], &amp;scores[1],</span><br><span class="line">        &amp;scores[2], &amp;scores[3], &amp;scores[4]);</span><br></pre></td></tr></table></figure>

<p>第10 ~ 11行：通过&amp;scores[0]取得数组第0个元素的地址并打印出来， 类似地，其余4个元素的地址也被打印出来。</p>
<p>从输出结果第2~3行可以看到，数组名scores与&amp;scores[0]的输出值都是0x000000000061FE00。请读者记住下述规则：<strong>数组名 &#x3D;&#x3D; 数组中首元素的地址</strong>。输出结果的第3行同时印证了图5- 中的内存布局，scores数组的5个元素是从低地址到高地址依次连续存储的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float fSum  = 0;</span><br><span class="line">for (int i=0;i&lt;5;i++)</span><br><span class="line">    fSum += scores[i];</span><br><span class="line"></span><br><span class="line">float fAverage = fSum / 5;</span><br><span class="line">printf(&quot;Average score = %.2f&quot;,fAverage);</span><br></pre></td></tr></table></figure>

<p>第13 ~ 18行：通过for循环对scores全部数组元素求和，再除以5，得到平均分数并打印出来。其中，scores[i]获取scores数组下标为i的元素值。</p>
<h3 id="5-2-元素的下标访问"><a href="#5-2-元素的下标访问" class="headerlink" title="5.2 元素的下标访问"></a>5.2 元素的下标访问</h3><p>通过a[i]可以访问a数组的第i个元素。当计算机试图访问一个存储在内存中的对象时，必须先知晓该对象的存储地址。那么，计算机是如何获得a数组第i个元素的存储地址的呢？请见下述公式：<br>a[i]的地址&#x3D;首元素的地址+i×单个元素的尺寸 &#x3D;a+i×sizeof(ElementType)a[i]的地址&#x3D;首元素的地址+i×单个元素的尺寸 &#x3D;a+i×sizeof(ElementType)<br>为了解读方便，我们准备了如下的C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - Subscript</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a1[5] = &#123;11,11,11,11,11&#125;;</span><br><span class="line">    int a2[5] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">    int a3[5] = &#123;33,33,33,33,33&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%p - %p - %p\n&quot;,a1,a2,a3);</span><br><span class="line">    printf(&quot;%d,%d,%d,%d,%d\n&quot;,a2[0],a2[1],a2[2],a2[3],a2[4]);</span><br><span class="line">    printf(&quot;a2[-4] = %d\n&quot;,a2[-4]);</span><br><span class="line">    printf(&quot;a2[8] = %d\n&quot;,a2[8]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序在作者计算机上的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000000000061FE00 - 000000000061FDE0 - 000000000061FDC0</span><br><span class="line">0,1,2,3,4</span><br><span class="line">a2[-4] = 33</span><br><span class="line">a2[8] = 11</span><br></pre></td></tr></table></figure>

<p>说明：每种类型的编译器在局部变量及数组的内存布局上会有异差，这些差异会导致在读者的计算机上，输出结果很可能与本书不同。</p>
<p><img src="http://codelearn.club/images/image-20200222203139818.png" alt="image-20200222203139818"></p>
<p>图5- 3个数组的内存布局</p>
<p>说明：图中的每个单元格代表4个字节的存储空间，每4个字节正好可以存入一个int类型的对象。</p>
<p>根据上述程序的输出，我们绘制了a1、a2、a3三个数组的内存布局图，请见图5- 。上述三个数组均包含5个int类型的元素，1个int占4个字节，故三个数组的大小均为5 x 4 &#x3D; 20字节。如图所示，a3占据了从0x0061FDC0开始的连续20个字节的空间，a2占据了从0x0061FDE0开始的连续20个字节的空间，a1占据了从0x0061FE00开始的连续20个字节的空间。编译器出于某些特殊的理由（比如内存对齐或调试需要），在a3、a2和a1三个数组间空出了12个字节的空间，对应图中数组间的灰色单元。上图中，每个单元代表4个字节，一个单元正好可以存入一个int。此外，图中还可以看到，定义在先的对象a1位于较高的内存地址段，定义在后的对象a3位于较低的内存地址段，a2夹在中间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[5] = &#123;11,11,11,11,11&#125;;</span><br><span class="line">int a2[5] = &#123;0,1,2,3,4&#125;;</span><br><span class="line">int a3[5] = &#123;33,33,33,33,33&#125;;</span><br></pre></td></tr></table></figure>

<p>第5 ~ 7行：定义并初始化了a1、a2和a3三个数组，每个数组都包含5个int类型的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%p - %p - %p\n&quot;,a1,a2,a3);</span><br></pre></td></tr></table></figure>

<p>第9行：将三个数组名按地址输出，根据前节所述，数组名即数组首元素的地址。该行的输出结果已反应在图5- 当中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d,%d,%d,%d,%d\n&quot;,a2[0],a2[1],a2[2],a2[3],a2[4]);</span><br></pre></td></tr></table></figure>

<p>第10行：依次打印a2[0] ~ a2[4]的值。从数组元素取值过程中，应用到了本节开头处给出的元素地址计算公式计算相应元素的内存地址。可以看到，当给出合法的下标0 ~ 4时，程序正确输出了a2的全部元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a2[-4] = %d\n&quot;,a2[-4]);</span><br></pre></td></tr></table></figure>

<p>第11行：打印a2[-4]的值，根据元素地址计算公式，相应元素地址为：<br>a2+(−4)×sizeof(int)&#x3D;0x0061FDE0−16&#x3D;0x0061FDD0a2+(−4)×sizeof(int)&#x3D;0x0061FDE0−16&#x3D;0x0061FDD0<br>该地址正好对应a3[4]，其值为33。输出结果中的第3行证实了这一判断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a2[8] = %d\n&quot;,a2[8]);</span><br></pre></td></tr></table></figure>

<p>第12行：打印a2[8]的值，根据元素地址计算公式，相应元素地址为：<br>a2+8×sizeof(int)&#x3D;0x0061FDE0+32&#x3D;0x0061FE00a2+8×sizeof(int)&#x3D;0x0061FDE0+32&#x3D;0x0061FE00<br>该地址正好对应a1[0]，其值为11。输出结果中的第4行证实了这一判断。</p>
<blockquote>
<p><strong>警告🚩</strong> 出于执行效率的考虑，C&#x2F;C++不会对数组下标进行<strong>越界检查</strong>，而只是机械地使用本节介绍的元素地址计算公式计算出元素地址，然后访问。本例中，a2[-4]和a2[8]事实上已经超出了a2数组的存储范围，但编译器最多给一个警告，不会拒绝。如果我们对a2[-4]或a2[8]进行赋值，则事实上修改了a2数组之外的对象，这十分危险！ 用C&#x2F;C++编程，就象是闪电侠快速地奔跑在布满地雷的雷区，又快又危险。</p>
</blockquote>
<p>再次说明，不同的编译器会对上述a1~a3数组的内存布局作出不同安排。在读者的计算机上，运行结果很可能会与本书不同。读者可能需要研究调整a2[-4]和a2[8]当中的下标值，才能观察到与本书类似的结果。</p>
<h3 id="5-3-数组初始化"><a href="#5-3-数组初始化" class="headerlink" title="5.3 数组初始化"></a>5.3 数组初始化</h3><p>当数组的初始化列表中给出的初始值个数N少于元素个数时，则数组的前N个元素会被赋以指定值，其余元素则被初始化为0。对于下述dummy数组，其前2个元素的值分别被初始化为1和2，其余8个元素则被初始化为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">short dummy[10] = &#123;1,2&#125;;   //前两个元素初始化为1和2，其余元素初始化为0</span><br></pre></td></tr></table></figure>

<p>事实上，下述两种写法都可以导致dummy数组的全部元素被初始化为0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short dummy[10] = &#123;&#125;;      //元素值全部初始化为0</span><br><span class="line">short dummy[10] = &#123;0&#125;;     //元素值全部初始化为0</span><br></pre></td></tr></table></figure>

<p>如果数组定义时不对数组进行初始化， 则数组的元素值是不确定的。下述dummy数组的元素值取决于数组分配前相应内存单元的当前状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double dummy[1000];        //元素值不确定</span><br></pre></td></tr></table></figure>

<p>数组定义时，如果将[ ]内的元素个数留空，编译器会通过初始化列表中的元素个数来确定数组的大小。下述示例中，dummy数组的元素个数将为4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double d[] = &#123;1.2,3.2,888,99.12&#125;;</span><br><span class="line">printf(&quot;%d&quot;,sizeof d / sizeof(double));  //元素个数 = 数组尺寸 / 元素尺寸</span><br></pre></td></tr></table></figure>

<p>上述代码第2行的sizeof d等价于sizeof(d)。当对一个不是数据类型的对象&#x2F;变量应用sizeof操作符时，括号可以省略。对于数组，有下述等式成立：<br>元素个数&#x3D;数组尺寸（字节数）&#x2F;元素尺寸（字节数）元素个数&#x3D;数组尺寸（字节数）&#x2F;元素尺寸（字节数）<br>在C++ 11中，初始化数组时，初始化列表前的等号可以省略，如下述代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char d1[5] &#123;&#x27;a&#x27;,120,&#x27;K&#x27;,&#x27;,&#x27;,&#x27;?&#x27;&#125;;</span><br><span class="line">char d[] &#123;12.0,&#x27;L&#x27;,250&#125;; //报错：250超出储值范围，12.0类型收窄</span><br></pre></td></tr></table></figure>

<p>上述代码的第2行会被编译器拒绝。C++ 11会对初始化列表中的值进行检查，其中，250超出了char的储值范围，12.0属于double类型的字面量，将其转换成char类型存在类型收窄（narrowing）。</p>
<h3 id="算法-折半查找"><a href="#算法-折半查找" class="headerlink" title="算法 - 折半查找"></a>算法 - 折半查找</h3><p>【未完成】</p>
<h3 id="算法-冒泡排序"><a href="#算法-冒泡排序" class="headerlink" title="算法 - 冒泡排序"></a>算法 - 冒泡排序</h3><p>当水里有气泡时，气泡的密度比水小，水的浮力大于气泡的重力，上浮。而水面的石头则注定下沉。冒泡排序(bubble sort)即得名于此。请注意，这里的所谓浮、沉、轻和重只是形象化的描述，不要机械理解。</p>
<p>如下图中的9个整数所构成的序列。现在我们要进行非递减，也就是递增排序。我们从前（下标0）往后两两比较，如果左边的元素大于右边的元素，则两两交换。如下例，9与3比较，9&gt;3，交换；9与1比较, 9&gt;1，交换；9与4比较, 9 &gt; 4，交换 … 最后9与5比较，9 &gt; 5，交换。经过这一轮共8次的两两比较以及次数不确定的交换，我们发现，序列中最大的那个元素9到了序列的尾部，即下标8的位置。而这个位置正好是元素9在排序后的目标位置。</p>
<p><img src="http://codelearn.club/images/1542550737940.png" alt="1542550737940"></p>
<p>图5- 第1轮冒泡排序过程（前3次比较&#x2F;交换）</p>
<p>经过一轮冒泡，9来到了序列最右端的目标位置：</p>
<p><img src="http://codelearn.club/images/1542550864357.png" alt="1542550864357"></p>
<p>图5- 第1轮冒泡后的序列</p>
<p>此时，我们可以认为9个元素中的前8个是无序的，而最后一个元素无需参与后续的排序。所以我们把前8个元素构成的子序列再来一轮从左至右的冒泡。在这一轮里，我们总共进行7次两两比较。最后，子序列中最大的元素8也到达了目标位置，即子序列的最后端。</p>
<p><img src="http://codelearn.club/images/1542551073811.png" alt="1542551073811"></p>
<p>图5- 第2轮冒泡后的序列</p>
<p>同样，我们可以把前7个元素构成的子序列再来一轮冒泡；… 把前2个元素构成的子序列再来一轮冒泡。最后，全部元素都达到了目标位置，排序完成，如下图：</p>
<p><img src="http://codelearn.club/images/1542551157218.png" alt="1542551157218"></p>
<p>图5- 完成冒泡排序后的序列</p>
<p>总结：对于由n个元素组成的序列，如果进行冒泡排序，总共要进行n-1轮的冒泡。第一轮的冒泡执行n-1次比较，第二轮冒泡执行n-2次比较，… 最后一轮冒泡执行1次比较。故，比较运算的总次数为：n-1 + n-2 + n-3 + … + 2 + 1 ，这是一个等差数列， 其和等于n(n-1)&#x2F;2。如果以后读者学习算法或者数据结构课程，会进一步地将该式简化成仅评估n的阶，用符号表达为Θ(n2)。在算法分析的术语里，我们称冒泡排序的计算复杂性为Θ(n2)。</p>
<p>下面是冒泡排序的C语言示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - BubbleSort</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void bubbleSort(int a[], const int n)&#123;</span><br><span class="line">    for (int i=n-1;i&gt;0;i--)</span><br><span class="line">        for (int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if (a[j] &gt; a[j+1])&#123;</span><br><span class="line">                int t = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int data[] = &#123;3,9,1,4,7,6,5,8,2&#125;;</span><br><span class="line">    bubbleSort(data,9);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Sorted array: &quot;);</span><br><span class="line">    for (int i=0;i&lt;9;i++)</span><br><span class="line">        printf(&quot;%d,&quot;,data[i]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sorted array: 1,2,3,4,5,6,7,8,9,</span><br></pre></td></tr></table></figure>

<p>第4 ~ 13行：定义了一个名为bubbleSort的函数。该函数接受一个整数数组a，以及一个整数n作为参数。其中，n代表参数数组a内的元素个数。该函数对a数组内的元素进行冒泡非递减排序。</p>
<ul>
<li>形式参数a的后面打了一个方括号[ ]，这种形式表示参数a实际为一个整数数组。请注意，当第17行将实参data传递给bubbleSort( )的形参a时，并不是将整个数组传递过来，实际被传递的是数组名，即data数组首元素的地址。由于数组名a所关联的地址值与data相同，所以，bubbleSort( )函数内对a数组元素的修改，事实上就是对外部的data数组的修改。</li>
<li>形式参数n的类型为const int，系常量型整数。相较于变量，除了初始化赋值之外，常量型对象是不可以被修改的。将形参n设定为常量型是有好处的：按照程序逻辑，bubbleSort( )函数预期不应修改代表数组元素个数的对象n，如果不小心在bubbleSort( )函数内错误修改n的值，编译器会报错。</li>
<li>bubbleSort( )函数内进行了双重循环。其中，外层循环中的i表示进行本轮冒泡排序的元素范围为a[0] ~ a[i]，本例中，取值依次为 8、7、6、5、4、3、2、1（不含0）。内层循环中的j表示从左到右两两比较的左元素的下标，右元素的下标为j+1。本例中，当i&#x3D;8时,（j, j+1)依次取(0,1)、(1,2)、(2,3)、(3,4)、(4,5)、(5,6)、(6,7)、(7,8)。</li>
<li>当进行非递减排序时，if子句中使用&gt;，否则使用&lt;。</li>
<li>第8 ~ 10行交换a[j]和a[j+1]的值，引入了一个临时变量t。t负责保存a[j]在被覆盖赋值之前的值，以便在稍后传递给a[j+1]。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int data[] = &#123;3,9,1,4,7,6,5,8,2&#125;;</span><br></pre></td></tr></table></figure>

<p>第16行：定义并初始化了data数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bubbleSort(data,9);</span><br></pre></td></tr></table></figure>

<p>第17行：调用执行bubbleSort( )函数对data数组进行了非递减冒泡排序。再次强调，data实参传递给bubbleSort( )函数的形参a时，只传递了函数名，即数组的首元素地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Sorted array: &quot;);</span><br><span class="line">for (int i=0;i&lt;9;i++)</span><br><span class="line">    printf(&quot;%d,&quot;,data[i]);</span><br></pre></td></tr></table></figure>

<p>第19 ~ 21行：打印输出排序后的data数组的全部元素。输出结果证实，排序正确无误。</p>
<p>如果读者还是不太明白，那么拿出一支笔，一张纸， 把自己当成一台计算机，来一次上述程序的模拟执行，或许有用。</p>
<h3 id="5-4-C风格字符串"><a href="#5-4-C风格字符串" class="headerlink" title="5.4 C风格字符串"></a>5.4 C风格字符串</h3><h4 id="5-4-1-字符数组"><a href="#5-4-1-字符数组" class="headerlink" title="5.4.1 字符数组"></a>5.4.1 字符数组</h4><p>在前述章节中，我们已经无数次使用过用双引号包裹的字符串字面量，比如”Hello World”。下述C语言程序有助于我们理解字符串的本质，即<strong>元素类型为字符的一维数组</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - CStyleString</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char s1[] = &quot;hello&quot;;</span><br><span class="line">    printf(&quot;s1 = %s, addr = %p, sizeof s1: %lld\n&quot;, s1, s1, sizeof s1);</span><br><span class="line">    printf(&quot;s1 = %d %d %d %d %d %d\n&quot;,s1[0],s1[1],s1[2],s1[3],s1[4],s1[5]);</span><br><span class="line"></span><br><span class="line">    char s2[256] = &quot;forrest&quot;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (s2[i]!=0)&#123;</span><br><span class="line">        s2[i] = s2[i] + (&#x27;A&#x27; - &#x27;a&#x27;);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;s2 = %s, addr = %p, sizeof s2: %lld\n&quot;, s2, s2, sizeof s2);</span><br><span class="line"></span><br><span class="line">    printf(&quot;&#x27;A&#x27; = %d,  &#x27;a&#x27; = %d&quot;,&#x27;A&#x27;,&#x27;a&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = hello, addr = 000000000061FE06, sizeof s1: 6</span><br><span class="line">s1 = 104 101 108 108 111 0</span><br><span class="line">s2 = FORREST, addr = 000000000061FD00, sizeof s2: 256</span><br><span class="line">&#x27;A&#x27; = 65,  &#x27;a&#x27; = 97</span><br></pre></td></tr></table></figure>

<p>说明：在读者计算机上，输出结果中的地址很可能与本书不同。</p>
<p><img src="http://codelearn.club/images/image-20200222203545411.png" alt="image-20200222203545411"></p>
<p>图5- s1的存储结构</p>
<p>我们结合图5- 来解读上述程序中关于字符串s1的部分。如执行结果的第1行所示，在作者的计算机上，由5个字符构成的”hello”占据了从地址0x0061FE06开始的连续6个字节的内存空间。其中，每个字节存储一个字符。多出来的一个字节是由编译器主动添加的，其值为整数0，用于表示字符串的终止。</p>
<p>如第2章所述，char类型的实质是单字节的有符号整数。图5- 的第2行显示了s1的6个字节的整数值，第1行则显示了这些整数值对应的ASCII码字符。需要注意的是，最后1个字节存储的是整数0，其对应的转义字符为’\0’，它并不是字符‘0’，字符‘0’的ASCII码值为48。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char s1[] = &quot;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>第5行：定义了字符数组s1，元素个数从字符串字面量统计而得，编译会主动添加1个字节并将其赋值为整数0，以表示字符串的终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;s1 = %s, addr = %p, sizeof s1: %lld\n&quot;, s1, s1, sizeof s1);</span><br></pre></td></tr></table></figure>

<p>第6行：占位符%s按字符串方式输出s1，可以想象，printf( )在执行占位符替换的过程中，会逐一考察构成s1数组的每一个元素，如果其值不为0，则转换输出其对应的ASCII字符，如果等于0，则终止。占位符%p按地址&#x2F;指针形式输出s1，按本章稍早的讨论，数组名s1即为该数组首元素的地址。sizeof s1取得s1数组的内存空间大小，为6个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;s1 = %d %d %d %d %d %d\n&quot;,s1[0],s1[1],s1[2],s1[3],s1[4],s1[5]);</span><br></pre></td></tr></table></figure>

<p>第7行：使用下标获得s1每个元素的值，并按照整数输出。所得即为s1存储空间内6个字节的整数值。其结果与图5- 的第2行相符。</p>
<p><img src="http://codelearn.club/images/image-20200222212206506.png" alt="image-20200222212206506"></p>
<p>图5- s2的存储结构</p>
<p>我们结合图5- 来解读上述程序中关于字符串s2的部分。如执行结果的第3行所示，在作者的计算机上，s2占据了从地址0x0061FD00开始的连续256个字节的内存空间。其中，前7个字节存储了7个字符，剩余的字节全部被初始化为整数0，用于表示字符串的终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char s2[256] = &quot;forrest&quot;;</span><br></pre></td></tr></table></figure>

<p>第9行：定义并初始化了字符数组s2，除了前7个字符，后续的256 - 7个字节的空间都被初始化为整数0值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">while (s2[i]!=0)&#123;</span><br><span class="line">    s2[i] = s2[i] + (&#x27;A&#x27; - &#x27;a&#x27;);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 14行：通过while循环从头开始逐一遍历s2的每一个字节，如果其值不为0，则将其值减去32。上述过程一直持续到遇到0为止。直观上，该while循环将字符串内的全部小写字符转换成对应的大写字符。读者如果翻看ASCII码表，即可发现小写字母与其对应的大写字母的码值正好差32。但作者在编写上述代码时，并不记得小写字母与大写字母的码差为32，就顺手通过’A’ - ‘a’来获得上述码差。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;s2 = %s, addr = %p, sizeof s2: %lld\n&quot;, s2, s2, sizeof s2);</span><br></pre></td></tr></table></figure>

<p>第15行：输出s2字符串，s2的地址，以及s2的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&#x27;A&#x27; = %d,  &#x27;a&#x27; = %d&quot;,&#x27;A&#x27;,&#x27;a&#x27;);</span><br></pre></td></tr></table></figure>

<p>第17行：通过%d占位符输出字符’A’及’a’的ASCII码值，从输出结果看，’A’ - ‘a’ &#x3D; 65 - 97 &#x3D; -32。</p>
<p>区别于C++标准模板库中的string类型，上述以字符数组形式实现的字符串称为<strong>C风格的字符串</strong>（C-style string）。</p>
<p>需要注意的是，C&#x2F;C++用单引号包裹单个字符，用双引号包裹字符串，不可混淆使用。请见下述代码及其注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;c&#x27;;    //正确：单引号包裹单个字符</span><br><span class="line">char d = &quot;d&quot;;    //错误：双引号包裹字符串</span><br><span class="line">char e[] = &quot;e&quot;;  //正确</span><br><span class="line">char f[] = &#x27;f&#x27;;  //错误</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-字符串运算"><a href="#5-4-2-字符串运算" class="headerlink" title="5.4.2 字符串运算"></a>5.4.2 字符串运算</h4><p>string.h头文件引入了一些与C风格字符串相关的函数，通过这些函数，可以对字符串进行比较、拼接等运算。请见下述C语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - StringOperation</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char s1[256] = &quot;Hello&quot;;</span><br><span class="line">    printf(&quot;s1 = %s, len = %lld\n&quot;,s1, strlen(s1));</span><br><span class="line"></span><br><span class="line">    char s2[512] = &quot;World&quot;;</span><br><span class="line">    printf(&quot;strcmp(s1,s2) = %d\n&quot;,strcmp(s1,s2));</span><br><span class="line"></span><br><span class="line">    char s3[512];</span><br><span class="line">    strcat(s1,&quot; &quot;);    //给s1附加一个空格</span><br><span class="line">    strcat(s1,s2);</span><br><span class="line">    strcpy(s3,s1);</span><br><span class="line">    printf(&quot;s1 = %s, s2 = %s, s3 = %s&quot;,s1,s2,s3);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = Hello, len = 5</span><br><span class="line">strcmp(s1,s2) = -1</span><br><span class="line">s1 = Hello World, s2 = World, s3 = Hello World</span><br><span class="line">printf(&quot;s1 = %s, len = %lld\n&quot;,s1, strlen(s1));</span><br></pre></td></tr></table></figure>

<p>第7行：<strong>strlen(s1)函数</strong>返回s1字符串包含的字符个数，其返回类型为size_t，在作者的计算机上，size_t即unsigned long long类型。其输出结果可知，该函数返回的是实际字符个数，而不是s1数组的内存大小。strlen的函数名来自英文string length。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;strcmp(s1,s2) = %d\n&quot;,strcmp(s1,s2));</span><br></pre></td></tr></table></figure>

<p>第10行：<strong>strcmp(s1,s2)函数</strong>将字符串s1和s2作比较，其返回类型为int。如果s1 &gt; s2，返回&gt;0的整数，如果s1 &lt; s2，返回&lt;0的整数，如果两者相等，返回0。所谓字符串比较，事实上是从前到后进行字符的逐一比较，而字符的比较，即比较字符的ASCII码值。由于’H’的ASCII码值 &lt; ‘W’，所以s1 &lt; s2，本例中该函数返回了-1，见执行结果的第2行。strcmp的函数名来自英文string comparison。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strcat(s1,&quot; &quot;);    //给s1附加一个空格</span><br><span class="line">strcat(s1,s2);</span><br></pre></td></tr></table></figure>

<p>第13 ~ 14行：<strong>strcat(s1,s2)函数</strong>将s2字符串附加在s1字符串的后面。同样基于执行速度的考虑，该函数不会对s1数组的空间进行越界检查，保证s1数组的剩余空间足够容纳s2的内容，是程序员的职责。C语言中的数组，其存储空间的大小是在定义时确定的，无法在执行过程中被改变。strcat的函数名来自英文string concatenation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcpy(s3,s1);</span><br></pre></td></tr></table></figure>

<p>第15行：**strcpy(s3,s1)**函数将字符串s1的内容到字符串s3。过程中，s3的原内容会被覆盖。同样，程序员需要自行确保s3的空间足够大。strcpy的函数名来自英文string copy。</p>
<blockquote>
<p>参考文档：C&#x2F;C++的标准库里有数量众多的函数、类型、算法等内容，了解其用法的最佳途径是查询C&#x2F;C++的参考文档。互联网上有诸多网站提供上述内容，在搜索引擎中以关键字C++ Reference或者C Reference搜索可得。</p>
</blockquote>
<h3 id="5-5-C-字符串"><a href="#5-5-C-字符串" class="headerlink" title="5.5 C++字符串"></a>5.5 C++字符串</h3><p>C风格字符串本质上是字符类型的一维数组，而数组的长度是在定义时就确定且在程序运行过程中无法修改的。如果试图往字符数组中超过其容量的字符串，会导致越界访问问题。C++引入了新的string类型，该类型的对象的“大小”可以根据需要自动变化。</p>
<p>下述C++程序可以帮助我们理解string类型的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Project - CppString1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s1 &#123;&quot;hello&quot;&#125;;</span><br><span class="line">    for (unsigned int i=0;i&lt;s1.size();i++)</span><br><span class="line">        s1[i] += (&#x27;A&#x27; - &#x27;a&#x27;);</span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; &quot;, size = &quot; &lt;&lt; s1.size()</span><br><span class="line">         &lt;&lt; &quot;, sizeof(s1) = &quot; &lt;&lt; sizeof(s1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s2 = &quot; World!&quot;;</span><br><span class="line">    string s3 = s1 + s2;</span><br><span class="line">    s1 += s2;</span><br><span class="line">    s2 = &quot;Hello&quot; + s2;</span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; &quot; s2 = &quot; &lt;&lt; s2 &lt;&lt; &quot; s3 = &quot; &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s4 = &quot;Life is a box of chocolates, you...&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;s4.substr(17,10) = &quot; &lt;&lt; s4.substr(17,10) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto iPos = s4.find(&quot;chocolates&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;s4.find(\&quot;chocolates\&quot;) = &quot; &lt;&lt; iPos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s4.replace(iPos,10,&quot;CHOCOLATES&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;s4 after replace = &quot; &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = HELLO, size = 5, sizeof(s1) = 32</span><br><span class="line">s1 = HELLO World! s2 = Hello World! s3 = HELLO World!</span><br><span class="line">s4.substr(17,10) = chocolates</span><br><span class="line">s4.find(&quot;chocolates&quot;) = 17</span><br><span class="line">s4 after replace = Life is a box of CHOCOLATES, you...</span><br></pre></td></tr></table></figure>

<p>说明：在不同开发环境下，第一行sizeof(s1)的输出结果可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：string头文件引入了string类型。同int, float这些内置类型一样，string也属于一种数据类型。区别在于，int, float是C++原生的，而string是由string头文件定义并介绍给编译器的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s1 &#123;&quot;hello&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>第7行：定义了string类型的对象s1，并使用一个C风格的字符串初始化了s1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (unsigned int i=0;i&lt;s1.size();i++)</span><br><span class="line">    s1[i] += (&#x27;A&#x27; - &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>

<p>第8 ~ 9行：通过for循环遍历并修改了s1内的每个字符，将其由小写变为大写。</p>
<ul>
<li>s1.size( )是s1对象的成员函数（member function），它返回s1对象内包含的字符个数。该函数的返回类型为size_t，即unsigned long long，与之匹配，循环变量i的类型设定为unsigned int。如果按照常规将i的类型定义为int，即有符号整数，编译器可能会给出“有符号整数与无符号整数比较”的警告。使用一个对象的成员函数的语法是：对象名.函数名(&lt;实参列表&gt;)。</li>
<li>s1[i]用于访问s1字符串内的第i个字符。与C风格的字符串数组不同，s1[i]在语法上类似于访问数组元素，但实质上是一次“操作符函数调用”▲。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; &quot;, size = &quot; &lt;&lt; s1.size()</span><br><span class="line">     &lt;&lt; &quot;, sizeof(s1) = &quot; &lt;&lt; sizeof(s1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 11行：从输出结果的第1行可见，s1被成功转换成了大写形式。size( )函数返回值为5，与实际情况相符。sizeof(s1)返回值为32，这表示s1对象的内存尺寸。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s2 = &quot; World!&quot;;</span><br><span class="line">string s3 = s1 + s2;</span><br><span class="line">s1 += s2;</span><br><span class="line">s2 = &quot;Hello&quot; + s2;</span><br><span class="line">cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; &quot; s2 = &quot; &lt;&lt; s2 &lt;&lt; &quot; s3 = &quot; &lt;&lt; s3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第13 ~ 17行：通过+操作符可以实现string字符串的拼接，其作用类似于C风格字符串的strcat( )函数。同时，还应注意到，+操作符即可以拼接两个string对象，也可以将一个string对象与一个C风格字符数组相加，均返回拼接好的新的string对象。在第15行，我们还看到了+&#x3D;操作符的使用。上述+，+&#x3D;的功用与strcat( )函数类似，但用起来要简单和直观很多。以后我们会学到，这里的+以及+&#x3D;并不是普通的操作符，其实质是<strong>重载的操作符函数</strong>▲。请结合输出结果的第2行理解上述代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s4 = &quot;Life is a box of chocolates, you...&quot;;</span><br><span class="line">cout &lt;&lt; &quot;s4.substr(17,10) = &quot; &lt;&lt; s4.substr(17,10) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 20行：s4.substr(17,10）截取s4字符串中从第17个字符开始的连续10个字符，并返回截取的<strong>子串</strong>，类型为string。请注意，所谓第17个字符，是从0开始计数的。输出结果的第3行可见截取出来的子串为”chocolates”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto iPos = s4.find(&quot;chocolates&quot;);</span><br><span class="line">cout &lt;&lt; &quot;s4.find(\&quot;chocolates\&quot;) = &quot; &lt;&lt; iPos &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第22 ~ 23行：s4.find(“chocolates”)函数返回”chocolates”子串在s4中出现的位置（下标）。输出结果的第4行证实，其位置下标为17。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s4.replace(iPos,10,&quot;CHOCOLATES&quot;);</span><br><span class="line">cout &lt;&lt; &quot;s4 after replace = &quot; &lt;&lt; s4 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第25 ~ 26行：s4.replace(iPos,10,”CHOCOLATES”)将s4中从iPos下标（即17）开始的连续10个字符替换成”CHOCOLATES”，输出结果的第5行证实了上述操作成功完成。</p>
<p>当使用string类型的对象来存储字符串时，我们完全不用担心容量问题。在现代计算机上，往一个string类型的对象s内往入一本莎士比亚全集毫无压力。事实上，无论我们给string对象s装入多大长度的字符串，sizeof(s)为固定值，即s对象的内存尺寸不会变大。那么？ 字符串存在哪里了？string类型的对象是如何管理字符串的存储空间的？这些问题需要到本书稍后部分才能解释清楚。</p>
<p>char类型只包含1个字节的存储空间，而1个字节最多最能表达256种不同的值。如果只表达英文字符及其符号，1个字节足够。但其它文字，比如中文，其“字符”有数万之多。在编码其它语言文字时，可能会使用到不同的多字节编码方案。 详情请阅读下述扩展。</p>
<blockquote>
<p>扩展：【？未完成】 UTF-8编码及非英文字符的处理与显示</p>
</blockquote>
<p>为了便于处理不同的文字编码方案，C++引入了wstring及wchar_t类型，C++ 11引入了u16string、u32string、char16_t以及char32_t类型。下述示例中，L, u, U前缀分别表明对应的字符串字面量属于wchar_t、char16_t以及char32_t类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wstring s1 = L&quot;Run, Forrest.&quot;;    //wchar_t 字符串</span><br><span class="line">wchar_t s2[] = L&quot;Run, Forrest.&quot;;</span><br><span class="line"></span><br><span class="line">u16string s3 = u&quot;Run, Forrest.&quot;;</span><br><span class="line">char16_t s4[] = u&quot;Run, Forrest.&quot;;</span><br><span class="line"></span><br><span class="line">u32string s5 = U&quot;Run, Forrest.&quot;;</span><br><span class="line">char32_t s6[] = U&quot;Run, Forrest.&quot;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一些第三方的开发包，提供了比C++标准库中的string更优秀的字符串解决方案。比如，Qt中的QString类型，MFC中的CString类型。</p>
</blockquote>
<h3 id="5-6-二维数组"><a href="#5-6-二维数组" class="headerlink" title="5.6 二维数组"></a>5.6 二维数组</h3><p>在日常工作生活中，经常会遇到二维的数据表格。比如，某学业导师指导了4位学生，每位学生都在2020年春季学期选修了相同的5门课。到期末时，导师可能会汇总出下述成绩单：</p>
<p>表5- 成绩单</p>
<table>
<thead>
<tr>
<th></th>
<th>课程0</th>
<th>课程1</th>
<th>课程2</th>
<th>课程3</th>
</tr>
</thead>
<tbody><tr>
<td>学生0</td>
<td>67</td>
<td>98</td>
<td>77</td>
<td>80</td>
</tr>
<tr>
<td>学生1</td>
<td>56</td>
<td>89</td>
<td>45</td>
<td>76</td>
</tr>
<tr>
<td>学生2</td>
<td>78</td>
<td>69</td>
<td>96</td>
<td>67</td>
</tr>
<tr>
<td>学生3</td>
<td>88</td>
<td>19</td>
<td>78</td>
<td>55</td>
</tr>
</tbody></table>
<p>在5.1节中，我们使用一维数组float scores[5]来表示一个学生的5门课程的成绩。 那么要表示上述4位同学的成绩，应该如何表达呢？ 其中一种解决方案是使用4个一维数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float scores0[5] = &#123;67, 98.5, 77, 100, 86&#125;;   //学生0的成绩</span><br><span class="line">float scores1[5] = &#123;56, 89,   45, 76,  63&#125;;   //学生1的成绩</span><br><span class="line">float scores2[5] = &#123;78, 69,   96, 67,  99&#125;;	  //学生2的成绩</span><br><span class="line">float scores3[5] = &#123;88, 19,   78, 55,  68&#125;;   //学生3的成绩</span><br></pre></td></tr></table></figure>

<p>如果只有4个学生，使用上述方法或许是可行的，那如果有5万学生呢？ 使用5万行代码定义5万个一维数组？ 这显然不是个好主意。</p>
<p>既然平面表格可以是二维（行+列两个维度）的，那么计算机内的数组也可以是二维的。下述C语言程序演示了二维数组的定义和使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Project - TwoDim</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float scores[4][5] = &#123;</span><br><span class="line">        &#123;67, 98, 77, 80, 86&#125;,</span><br><span class="line">        &#123;56, 89, 45, 76, 63&#125;,</span><br><span class="line">        &#123;78, 69, 96, 67, 99&#125;,</span><br><span class="line">        &#123;88, 19, 78, 55, 68&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    scores[1][2] = 100;</span><br><span class="line"></span><br><span class="line">    printf(&quot;scores = %p, sizeof(scores) = %lld\n&quot;,scores, sizeof(scores));</span><br><span class="line">    printf(&quot;scores[0~3] = %p %p %p %p\n&quot;,scores[0],scores[1],scores[2],scores[3]);</span><br><span class="line">    printf(&quot;&amp;scores[1][0~2] = %p %p %p\n&quot;,&amp;scores[1][0],&amp;scores[1][1],&amp;scores[1][2]);</span><br><span class="line">    printf(&quot;&amp;scores[1~2][1] = %p %p\n&quot;,&amp;scores[1][1], &amp;scores[2][1]);</span><br><span class="line"></span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (unsigned int j=0;j&lt;5;j++)</span><br><span class="line">        fSum += scores[1][j];</span><br><span class="line">    float fAverage = fSum / 5;</span><br><span class="line">    printf(&quot;Average of scores[1][0~4] = %.2f&quot;,fAverage);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在作者的计算机上，上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scores = 000000000061FDC0, sizeof(scores) = 80</span><br><span class="line">scores[0~3] = 000000000061FDC0 000000000061FDD4 000000000061FDE8 000000000061FDFC</span><br><span class="line">&amp;scores[1][0~2] = 000000000061FDD4 000000000061FDD8 000000000061FDDC</span><br><span class="line">&amp;scores[1~2][1] = 000000000061FDD8 000000000061FDEC</span><br><span class="line">Average of scores[1][0~4] = 76.80</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，输出结果中的地址很可能与本书不同，但其分布规律应与本书相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float scores[4][5] = &#123;</span><br><span class="line">    &#123;67, 98, 77, 80, 86&#125;,</span><br><span class="line">    &#123;56, 89, 45, 76, 63&#125;,</span><br><span class="line">    &#123;78, 69, 96, 67, 99&#125;,</span><br><span class="line">    &#123;88, 19, 78, 55, 68&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第5 ~ 10行：定义了名为scores的二维数组，元素类型为float，分4行5列。第5行的float scores[4][5]可以简写为float scores[ ][5]，让编译器自动从初始化列表中统计行数。但是，编译器不允许列数5空缺。因为是二维数组，scores的初始列表使用了两层{ }来包裹。</p>
<p><img src="http://codelearn.club/images/image-20200223164556687.png" alt="image-20200223164556687"></p>
<p>图5- 二维数组的内存布局</p>
<p>说明：数组的内存地址是在运行时刻由操作系统分配的，所以读者在自己计算机上获得的scores二维数组的内存地址很可能与图5- 不同。图中的每个单元格代表4个字节的存储空间，每4个字节的存储空间正好可以存入一个float类型的对象。</p>
<p>从逻辑上看，数组是二维的，但计算机的内存是一维的。图5- 展示了二维数组scores是如何布局在一维的计算机内存中的。scores数组4行5列，共20个float，每个float占4个字节， 20 x 4 &#x3D; 80字节。图中可见，scores数组占据了从地址0x0061FDC0开始的连续80个字节的空间，所有的元素，按照先行后列的顺序逐一排列。其中，第1行scores[0]占据了从地址0x0061FDC0开始的边续20个字节的空间，第2行scores[1]则占据了从地址0x0061FDD4开始的边续20个字节的空间，然后是第3和第4行。二维数组的每一行可以视为一个一维数组，在这些一维数组的内部，其元素排列与普通的一维数组完全相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[1][2] = 100;</span><br></pre></td></tr></table></figure>

<p>第11行：scores[1][2]代表了数组第1行，第2列的元素，即表5- 中学生1的课程2成绩。通过赋值，程序将该值由45改为100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;scores = %p, sizeof(scores) = %lld\n&quot;,scores, sizeof(scores));</span><br></pre></td></tr></table></figure>

<p>第13行：将二维数组名scores按照地址&#x2F;指针格式打印，从输出结果的第1行可见，数组名scores的值仍为数组首元素，即第0行第0列元素的地址。sizeof(scores)返回该二维数组的空间大小，为80个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;scores[0~3] = %p %p %p %p\n&quot;,scores[0],scores[1],scores[2],scores[3]);</span><br></pre></td></tr></table></figure>

<p>第14行：scores[i]指二维数组的第i行，它可以视为一个一维数组。我们将scores[0 ~ 3]以地址&#x2F;指针格式打印，从输出结果的第2行可见，scores[i]的值为该一维数组的首元素地址。实践中，我们可以将scores[i]视为该一维数组的数组名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;scores[1][0~2] = %p %p %p\n&quot;,&amp;scores[1][0],&amp;scores[1][1],&amp;scores[1][2]);</span><br></pre></td></tr></table></figure>

<p>第15行： 通过&amp;操作符，我们获得了scores[1][0]、scores[1][1]、scores[1][2]的地址并打印，输出结果的第3行证实，在一维数组scores[1]中，其内部元素是依次排列的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;scores[1~2][1] = %p %p\n&quot;,&amp;scores[1][1], &amp;scores[2][1]);</span><br></pre></td></tr></table></figure>

<p>第16行：我们打印输出了元素scores[1][1]和scores[2][1]的内存地址，见输出结果的第4行。如果读者将两个地址相减，其值应为20。这说明，二维数组中，相邻行的同列元素之间地址差正好等于一行元素的空间大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float fSum = 0;</span><br><span class="line">for (unsigned int j=0;j&lt;5;j++)</span><br><span class="line">    fSum += scores[1][j];</span><br><span class="line">float fAverage = fSum / 5;</span><br><span class="line">printf(&quot;Average of scores[1][0~4] = %.2f&quot;,fAverage);</span><br></pre></td></tr></table></figure>

<p>第18 ~ 22行：统计并打印了学生1，即scores数组第1行的平均值。</p>
<p>同一维数组一样，当我们通过a[i][j]去访问二维数组a第i行第j列的元素时，计算机也必须先求得该元素在内存中的地址。计算公式如下：<br>a[i][j]的地址&#x3D;首元素的地址+i×单行元素的尺寸+j×单个元素的尺寸 &#x3D;a+i×(单个元素的尺寸×单行元素个数)+j×单个元素的尺寸 &#x3D;a+i×(sizeof(ElementType)×列数)+j×sizeof(ElementType)a[i][j]的地址&#x3D;首元素的地址+i×单行元素的尺寸+j×单个元素的尺寸 &#x3D;a+i×(单个元素的尺寸×单行元素个数)+j×单个元素的尺寸 &#x3D;a+i×(sizeof(ElementType)×列数)+j×sizeof(ElementType)<br>以上述公式为基础，我们尝试计算scores[2][1]的地址：<br>scores[2][1]的地址&#x3D;首元素的地址+i×单行元素的尺寸+j×单个元素的尺寸 &#x3D;scores+i×(sizeof(float)×5)+j×sizeof(float) &#x3D;0x0061FDC0+2×(4×5)+1×4 &#x3D;0x0061FDC0+40+4 &#x3D;0x0061FDECscores[2][1]的地址&#x3D;首元素的地址+i×单行元素的尺寸+j×单个元素的尺寸 &#x3D;scores+i×(sizeof(float)×5)+j×sizeof(float) &#x3D;0x0061FDC0+2×(4×5)+1×4 &#x3D;0x0061FDC0+40+4 &#x3D;0x0061FDEC<br>计算结果与上例输出结果的第4行一致。从计算过程可知，计算机依赖于每行的元素个数，即列数来计算单个元素的存储位置，这就是二维数组scores[4][5]被定义时，行数4可以省略，但列数5不能被省略的理由。</p>
<p>同样地，C&#x2F;C++不会对二维数组的越界访问进行检查，保证只访问”属于“该数组的元素，是程序员的职责。</p>
<h3 id="算法-矩阵乘积的计算"><a href="#算法-矩阵乘积的计算" class="headerlink" title="算法 - 矩阵乘积的计算"></a>算法 - 矩阵乘积的计算</h3><p>【?缺】</p>
<h3 id="5-7-多维数组"><a href="#5-7-多维数组" class="headerlink" title="5.7 多维数组*"></a>5.7 多维数组*</h3><p>多维数组与二维数组本质相同，只是维度更多而已。下述C语言代码定义并使用了数组名为a的三维数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - ThreeDim</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    short a[2][2][3] = &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;0,1,2&#125;,</span><br><span class="line">            &#123;10,11,12&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;100,101,102&#125;,</span><br><span class="line">            &#123;110,111,112&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a = %p, sizeof(a) = %lld\n&quot;,a,sizeof(a));</span><br><span class="line">    printf(&quot;a[1][1][1] = %d&quot;,a[1][1][1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 000000000061FE00, sizeof(a) = 24</span><br><span class="line">a[1][1][1] = 111</span><br></pre></td></tr></table></figure>

<p>第5 ~ 14行：定义了一个2x2x3的三维数组，该数组包含两个2行3列的二维数组。上述代码中可见，a数组的初始化列表用了三层{ }包裹。同样地，该数组被定义时，程序员可以省略0维的元素个数（本例中为2），让编译器从初始化列表中统计，但1维和2维的元素个数（本例中为2和3）不可以省略。</p>
<p>a数组是三维数组的数组名，其维度信息可以表示为（2，3，3）；a[0]、a[1]则可视为二维数组的数组名，其维度为（2，3）；a[1][1]则可视为一维数组的数组名，它包含3个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a = %p, sizeof(a) = %lld\n&quot;,a,sizeof(a));</span><br></pre></td></tr></table></figure>

<p>第16行：将数组名a以地址&#x2F;指针格式输出，结果可见，数组名a为a数组中首元素，即a[0][0][0]的地址。数组a中有2 x 2 x 3 &#x3D; 12个元素，每个short占2两个字节，故sizeof(a)的返回值为24。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a[1][1][1] = %d&quot;,a[1][1][1]);</span><br></pre></td></tr></table></figure>

<p>第17行：输出了元素a[1][1][1]的值。该元素的内存地址计算公式与上节所述的二维数组类似。</p>
<h2 id="6-指针及引用"><a href="#6-指针及引用" class="headerlink" title="6. 指针及引用"></a>6. 指针及引用</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>C&#x2F;C++中的指针（pointer）是无数初学者的噩梦，也是造成C&#x2F;C++难学难用的原因之一。很多其它的程序设计语言，包括著名的Java，都避免引入指针，以简化语法。</p>
<h3 id="6-1-指针"><a href="#6-1-指针" class="headerlink" title="6.1 指针"></a>6.1 指针</h3><p><strong>指针是一个值为内存地址的对象</strong>，它既可以是变量，也可以是常量。请先阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - PointerBasic</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 9999, *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">    printf(&quot;before: a = %d,  *p = %d\n&quot;, a, *p);</span><br><span class="line">    a++;</span><br><span class="line">    *p = *p + 100;</span><br><span class="line">    printf(&quot;after: a = %d,  *p = %d\n&quot;, a, *p);</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;a = %p, p = %p, sizeof(p) = %lld\n&quot;, &amp;a, p, sizeof(p));</span><br><span class="line">    printf(&quot;&amp;p = %p&quot;, &amp;p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before: a = 9999,  *p = 9999</span><br><span class="line">after: a = 10100,  *p = 10100</span><br><span class="line">&amp;a = 000000000061FE1C, p = 000000000061FE1C, sizeof(p) = 8</span><br><span class="line">&amp;p = 000000000061FE10</span><br></pre></td></tr></table></figure>

<p>说明：在读者计算机上，第3 ~ 4行的地址及sizeof(p)可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 9999, *p;</span><br></pre></td></tr></table></figure>

<p>第5行：定义了类型为int的变量a，初始化其值为9999；变量名p前加了一个<em>号，该星号表明，变量p是一个指向int类型对象的指针，它预期用于存储一个int类型对象的内存地址，其数据类型简写为int</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>

<p>第6行：取变量a的地址，赋值给指针变量p。对一个int类型的变量a使用&amp;操作符，其返回的地址为一个int对象的地址，简写为int<em>。同时，变量p的类型也为int</em>，第6行赋值操作符两端操作数（operand）的类型相同。下表列出了本例中第6行执行完成后变量a与p的状态。</p>
<p>表6- a与p的状态</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>类型</th>
<th>值</th>
<th>内存地址</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>int</td>
<td>9999</td>
<td><strong>0x0061FE1C</strong></td>
</tr>
<tr>
<td>p</td>
<td>int*</td>
<td><strong>0x0061FE1C</strong></td>
<td>0x0061FE10</td>
</tr>
</tbody></table>
<p>从表中可见，p的值即为a的地址。同时，p作为一个变量，也有自己的内存空间以及地址。</p>
<p><img src="http://codelearn.club/images/image-20200224160321908.png" alt="image-20200224160321908"></p>
<p>图6- a与p的内存布局</p>
<p>借助于本程序的输出结果，我们绘制了变量a与p的内存布局图6- 。图中可见，a变量占据了从地址0x0061FE1C开始的连续4个字节的空间，p变量则占据了从地址0x0061FE10开始的连续8个字节的空间。在64位编译器下，指针&#x2F;地址占据8个字节，共64个比特的空间。编译器出于某些考虑（比如内存对齐），在p和a的内存之前留下了一些空白内存，请见图中两者之间的灰色单元格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;before: a = %d,  *p = %d\n&quot;, a, *p);</span><br></pre></td></tr></table></figure>

<p>第8行：在int<em>类型的指针变量p前打上一个*号，</em>p，其含义为取指针p所指向的对象，也可称为取p所存地址处的对象。本例中，<em>p即为对象a，其类型为int。此处的</em>号与作为乘法运算符的星号是不同的操作符，它称为<strong>间接操作符（indirection operator）</strong>，也可称作<strong>解引用操作符（dereferencing operator）</strong>。从输出结果的第1行可见，a和*p的值均为9999，它们事实上关联同一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br><span class="line">*p = *p + 100;</span><br></pre></td></tr></table></figure>

<p>第9 ~ 10行：先通过a++把a的值增加了1，然后通过*p把a值增加了100。这两行代码执行后，a值预期应为9999 + 1 + 100 &#x3D; 10100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;after: a = %d,  *p = %d\n&quot;, a, *p);</span><br></pre></td></tr></table></figure>

<p>第11行：再次输出了a和<em>p的值，同为10100。如前所述，</em>p事实上就是a。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;a = %p, p = %p, sizeof(p) = %lld\n&quot;, &amp;a, p, sizeof(p));</span><br></pre></td></tr></table></figure>

<p>第13行：输出变量a的地址&amp;a，以及指针p的值，还有sizeof(p)。从执行结果的第3行可见，指什p的值即为变量a的地址；在作者的计算机上，p对象占据8字节内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;p = %p&quot;, &amp;p);</span><br></pre></td></tr></table></figure>

<p>第14行：既然指针变量p也是一个变量，那么它也有内存空间，而内存空间，一定有地址。通过&amp;p取得p的地址并输出，得执行结果的第4行。</p>
<h3 id="6-2-空指针"><a href="#6-2-空指针" class="headerlink" title="6.2 空指针"></a>6.2 空指针</h3><p>当一个指针对象的值为0时，该指针事实上不能指向任何对象，我们称该指针为<strong>空指针（null pointer）</strong>。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Project - NullPointer</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double d = 3.14;</span><br><span class="line">    double* p = NULL;     //等价于double *p = (double*)0;</span><br><span class="line">    printf(&quot;p = NULL = %p\n&quot;, p);</span><br><span class="line">    //*p = 3.14 + 1;      //对一个空指针应用间接操作符会引发执行错误</span><br><span class="line"></span><br><span class="line">    p = &amp;d;</span><br><span class="line">    printf(&quot;p = &amp;d = %p, *p = d = %f&quot;, p, *p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = NULL = 0000000000000000</span><br><span class="line">p = &amp;d = 000000000061FE10, *p = d = 3.140000</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第2行中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double* p = NULL;     //等价于double *p = (double*)0;</span><br></pre></td></tr></table></figure>

<p>第6行：该行中，double* p与double *p两种写法等价，编译器并不在意*号在double和p之间的位置。在Qt Creator环境中，用鼠标右键单击第6行的NULL，然后选择Find References to Symble Under Cursor。如图6- 。</p>
<p><img src="http://codelearn.club/images/image-20200224164253607.png" alt="image-20200224164253607"></p>
<p>图6- 查找NULL的引用</p>
<p>接下来，可在Qt Creator的下方窗口中看到本项目中有两个文件引用&#x2F;使用了NULL。</p>
<p><img src="http://codelearn.club/images/image-20200224164549900.png" alt="image-20200224164549900"></p>
<p>图6- NULL的引用文件</p>
<p>双击打开stdio.h，可以关于NULL的下述定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NULL 0LL</span><br><span class="line">...</span><br><span class="line">#define NULL ((void *)0)</span><br></pre></td></tr></table></figure>

<p>根据不同的编译器设置，NULL的定义将是上述二者之一：</p>
<ul>
<li>0LL，即为long long类型的字面量0；</li>
<li>((void*)0)，整数0，经显式类型转换为void*。这里的**void***表示一种特殊的指针类型，它表示对象是一个指针，但这个指针所指向的对象类型不确定。</li>
</ul>
<p>无论NULL的定义是上述哪一种，指针p &#x3D; NULL执行后，p的值将为整数0，这表示一个非法的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;p = NULL = %p\n&quot;, p);</span><br></pre></td></tr></table></figure>

<p>第7行：将p值按地址格式输出，执行结果的第1行可见，p值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//*p = 3.14 + 1;      //对一个空指针应用间接操作符会引发执行错误</span><br></pre></td></tr></table></figure>

<p>第8行：当p为一个空指针时，不可以对其使用间接操作符*，否则会引发执行错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;d;</span><br></pre></td></tr></table></figure>

<p>第10行：将d的地址赋值给指针p，赋值完成后，p指向d，不再是空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;p = &amp;d = %p, *p = d = %f&quot;, p, *p);</span><br></pre></td></tr></table></figure>

<p>第11行：打印p以及<em>p，执行结果的第2行可见，p有一个合法的地址值，</em>p即为d值3.14。</p>
<p>上述讨论中，我们知道，当NULL是由编译器预处理指令定义的，其值为0。而字面量0，既可以视作整数，也可以视作void*类型的指针，其类型具有不确定性。这种类型不确定性在C++里会带来其他问题。<strong>【C++ 11】</strong>引入了一个新的关键字<strong>nullptr</strong>来表示空指针，虽然事实上nullptr也是0值，但其有确定的类型，即std::nullptr_t。</p>
<p>我们建议读者在编写C++ 11及其之后版本的C++程序时，永远使用nullptr，不要使用NULL或整数0来代表空指针。关于nullptr的使用，请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - NullPtr</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char c &#123;&#x27;c&#x27;&#125;;</span><br><span class="line">    char* p &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;p = nullptr = %p\n&quot;, p);</span><br><span class="line">    p = &amp;c;</span><br><span class="line">    printf(&quot;p = &amp;c = %p, c = %c, *p = %c&quot;, p, c, *p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = nullptr = 0000000000000000</span><br><span class="line">p = &amp;c = 000000000061fe17, c = c, *p = c</span><br></pre></td></tr></table></figure>

<p>说明：在读者计算机上，执行结果第2行中的地址很可能与本书不同。</p>
<p>因为cout输出指针对象时，其行为不太符合我们的需要，故上述程序仍然使用C语言的printf( )函数来输出指针。从执行结果可以看到，nullptr赋值给p后，p的值事实上就是0。</p>
<p>读者可能仍然对nullptr到底是什么感到疑惑，对nullptr的解读需要建立在对C++语言的良好理解之上。作者的下述解释可能会让初学者更加糊涂：C++ 11中的nullptr可以转换为任意指针类型的对象，其值为0，它既可以赋值给int<em>，也可赋值给char*, 还可以赋值给unsigned long long</em>类型的对象▲。</p>
<h3 id="6-3-指针的简单应用"><a href="#6-3-指针的简单应用" class="headerlink" title="6.3 指针的简单应用"></a>6.3 指针的简单应用</h3><p>下述C语言程序演示了指针的最基本用途：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - Swap</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap1(int a, int b)&#123;</span><br><span class="line">    int t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap2(int* a, int* b)&#123;</span><br><span class="line">    int t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m = 2, n = 7;</span><br><span class="line"></span><br><span class="line">    swap1(m,n);</span><br><span class="line">    printf(&quot;after swap1: m = %d, n = %d\n&quot;, m, n);</span><br><span class="line"></span><br><span class="line">    swap2(&amp;m, &amp;n);</span><br><span class="line">    printf(&quot;after swap2: m = %d, n = %d\n&quot;, m, n);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">after swap1: m = 2, n = 7</span><br><span class="line">after swap2: m = 7, n = 2</span><br></pre></td></tr></table></figure>

<p>上述程序中的swap1( )及swap2( )试图完成相同的功能：交换两个整数对象的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap1(int a, int b)&#123;</span><br><span class="line">    int t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第4 ~ 8行：swap1( )函数接受int类型的形参a和b，函数体内借助于临时变量t，变换了形式参数a，b的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap2(int* a, int* b)&#123;</span><br><span class="line">    int t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 14行：swap2( )函数接受int*类型的形参a和b，函数体内借助于临时变量t，交换了a，b指针指向的整数对象的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap1(m,n);</span><br><span class="line">printf(&quot;after swap1: m = %d, n = %d\n&quot;, m, n);</span><br></pre></td></tr></table></figure>

<p>第19 ~ 20行：将m，n作为实参调用执行swap1( )函数，执行完后再打印m，n的值，从执行结果的第1行可见，m，n的值没有因swap1( )函数的执行而交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap2(&amp;m, &amp;n);</span><br><span class="line">printf(&quot;after swap2: m = %d, n = %d\n&quot;, m, n);</span><br></pre></td></tr></table></figure>

<p>第22 ~ 23行：取m和n的地址，并将地址作为实参调用执行swap2( )函数。对于swap2( )函数而言，a，b形参的值即为m，n变量的地址，函数体内对<em>a，</em>b的修改即是对外部变量m，n的修改。从执行结果的第2行可见，借助于指针，swap2( )函数成功交换了变量m，n的值。这用传递指针调用函数的方式，称为<strong>传指针调用（call by pointer）</strong>。</p>
<p>接下来解释为什么swap1( )函数未能达成目标。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - CallByValue</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap1(int a, int b)&#123;</span><br><span class="line">    printf(&quot;before swap in swap1: &quot;);</span><br><span class="line">    printf(&quot;&amp;a = %p, &amp;b = %p, a = %d, b = %d\n&quot;, &amp;a, &amp;b, a, b);</span><br><span class="line">    int t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">    printf(&quot;after swap in swap1: &quot;);</span><br><span class="line">    printf(&quot;&amp;a = %p, &amp;b = %p, a = %d, b = %d\n&quot;, &amp;a, &amp;b, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m = 2, n = 7;</span><br><span class="line">    printf(&quot;before function call: &quot;);</span><br><span class="line">    printf(&quot;&amp;m = %p, &amp;n = %p, m = %d, n = %d\n&quot;, &amp;m, &amp;n, m, n);</span><br><span class="line">    swap1(m,n);</span><br><span class="line">    printf(&quot;after function call: &quot;);</span><br><span class="line">    printf(&quot;&amp;m = %p, &amp;n = %p, m = %d, n = %d\n&quot;, &amp;m, &amp;n, m, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before function call: &amp;m = 000000000061FE1C, &amp;n = 000000000061FE18, m = 2, n = 7</span><br><span class="line">before swap in swap1: &amp;a = 000000000061FDE0, &amp;b = 000000000061FDE8, a = 2, b = 7</span><br><span class="line">after swap in swap1: &amp;a = 000000000061FDE0, &amp;b = 000000000061FDE8, a = 7, b = 2</span><br><span class="line">after function call: &amp;m = 000000000061FE1C, &amp;n = 000000000061FE18, m = 2, n = 7</span><br></pre></td></tr></table></figure>

<p>在main( )函数中，我们分别打印了变量m，n在swap1( )函数执行前后的地址和值；在swap1( )函数中，我们打印了形参a，b在数据交换前的地址和值。从执行结果可以看到，按照顺序，实参m的值2传递给了形参a，实参n的值传递给了实参b，但传递完成后，a与m，b与n完全独立，它们只是m，n的品而已。在执行结果中，我们可以看到，a，b与m，n拥有不同的内存地址。</p>
<p>从执行结果的第2 ~ 3行可以看到，在swap1( )函数内部，我们成功地交换了形参a，b的值：2，7变成了7，2。但对形参a，b的变换并不会影响外部变量m，n，它们的值在函数执行前后完全没有变，请见执行结果的第1行，第4行。</p>
<p>在swap1(m, n)的调用过程中，m, n的值传递给了形参a，b，这种传递参数的值调用函数的方式，称为<strong>传值调用（call by value）</strong>。</p>
<h3 id="6-4-指针与数组"><a href="#6-4-指针与数组" class="headerlink" title="6.4 指针与数组"></a>6.4 指针与数组</h3><p>在第5章，我们已经知道数组名即为数组首元素的地址，而指针变量的值也是地址。事实上，数组名与指针可以相互转换。请见下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - ArrayPointer1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float scores[5] = &#123;55,66,77,88,99&#125;;</span><br><span class="line">    float* p1 = scores;       //把数组名赋值给指针</span><br><span class="line">    printf(&quot;sizeof(scores) = %lld,  sizeof(p1) = %lld\n&quot;,sizeof(scores),sizeof(p1));</span><br><span class="line"></span><br><span class="line">    float* p2 = (float*)malloc(sizeof(float)*5);  //申请分配20字节的内存</span><br><span class="line">    if (p2==NULL)</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (unsigned int i=0;i&lt;5;i++)&#123;</span><br><span class="line">        p2[i] = p1[i];       //指针当成数组用</span><br><span class="line">        fSum += p2[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Average = %f&quot;,fSum/5);</span><br><span class="line"></span><br><span class="line">    free(p2);                //释放申请的内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(scores) = 20,  sizeof(p1) = 8</span><br><span class="line">Average = 77.000000</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：stdlib.h头文件引入函数malloc( )以及free( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float* p1 = scores;       //把数组名赋值给指针</span><br><span class="line">printf(&quot;sizeof(scores) = %lld,  sizeof(p1) = %lld\n&quot;,sizeof(scores),sizeof(p1));</span><br></pre></td></tr></table></figure>

<p>第7 ~ 8行：将数组名scores赋值给float*类型的指针p1。虽然同为指针，但将数组名赋值给指针是有信息丢失的。在Qt Creator或者其它IDE环境中，将鼠标悬停在scores数组名上方，系统会提示该名称的类型为float[5]，意即包含5个float的数组。如图6- 所示。</p>
<p><img src="http://codelearn.club/images/image-20200224214113598.png" alt="image-20200224214113598"></p>
<p>图6- 数组名的类型提示</p>
<p>p1的类型为float*，在把scores赋值给p1后，虽然p1事实上指向了一个包含5个float元素的数组，但对于编译器而言，它就是指向一个float对象的指针。从执行结果的第1行可见，sizeof(scores)的结果为20，因为编译器知道scores的类型为float[5]，sizeof(p1)的结果为8，它就是一个平凡的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float* p2 = (float*)malloc(sizeof(float)*5);  //申请分配20字节的内存</span><br><span class="line">if (p2==NULL)</span><br><span class="line">    exit(EXIT_FAILURE);</span><br></pre></td></tr></table></figure>

<p>第10 ~ 12行：C语言标准库函数malloc( n )用于向操作系统申请n个字节的存储空间，返回申请到的内存的地址，其类型为void<em>。按稍早的讨论，void</em>表示一种特殊的指针类型，该类型指针所指向的对象类型不确定。在第10行中，由于p2是float<em>，而malloc( )的返回值为void</em>，两者类型不一致，所以通过(float*)进行显式类型转换。向操作系统的内存申请并不总是能获得批准，在资源紧张的情况下，操作系统可能会拒绝。这时，malloc( )函数将返回一个空指针。第11行检查p2的值，如果是空指针，则调用exit( )函数退出程序的执行，其参数EXIT_FAILURE系值为1为常量，该参数将被exit( )传递给操作系统，提示程序的执行过程中发生了异常。本例中， sizeof(float) * 5 &#x3D; 20， 我们申请了20字节的空间。此外，malloc( )函数不会对申请的内存进行初始化，p2所指向的5个float的值是不确定的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">float fSum = 0;</span><br><span class="line">for (unsigned int i=0;i&lt;5;i++)&#123;</span><br><span class="line">    p2[i] = p1[i];       //指针当成数组用</span><br><span class="line">    fSum += p2[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;Average = %f&quot;,fSum/5);</span><br></pre></td></tr></table></figure>

<p>第14 ~ 20行：float*类型的指针p1和p2可以当成数组用。逻辑上，可以把p1和p2视为元素类型为float的一维数组的数组名，p1[i]和p2[i]计算元素地址的方式与数组完全相同。上述程序中，通过for循环把p1数组的值逐一拷贝到p2数组，顺便把数组元素求和，再平均，再打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(p2);                //释放申请的内存</span><br></pre></td></tr></table></figure>

<p>第22行：scores数组，p1指针，p2指针都是所谓<strong>自动变量（automatic variable）</strong>，它们的内存分配与回收由编译器负责生成机器指令自动处理。但是，p2指针所指向的由malloc( )函数申请的20个字节不属于自动变量，负要由程序员主动释放。free(p2)函数将p2指针指向的内存释放给操作系统，使用操作系统可以在恰当地时候将这片内存另作他用。</p>
<p>对于编译器而言，p1和p2指针就是平凡的指向一个float对象的指针。将把指针当成数组名来使用时，确保下标不越界是程序员的职责。</p>
<blockquote>
<p>注意：程序员必须确保申请的内存资源得到恰当的释放。未能妥善释放内存会造成系统可用内存资源的减少，影响计算机性能。这种情况称之为<strong>内存泄漏（memory leakage）</strong>。</p>
</blockquote>
<h3 id="6-5-指针运算"><a href="#6-5-指针运算" class="headerlink" title="6.5 指针运算"></a>6.5 指针运算</h3><p>指针对象可以与整数进行加减运算，但其执行结果与多数读者的期待不一致。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - PointerOperation1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float* p = (float*)calloc(10,sizeof(float));</span><br><span class="line">    if (p==NULL)</span><br><span class="line">        exit(1);</span><br><span class="line"></span><br><span class="line">    printf(&quot;p = %p,  p + 1 = %p,  p + 3 = %p\n&quot;, p, p+1, p+3);</span><br><span class="line"></span><br><span class="line">    for (int i=0;i&lt;10;i++)</span><br><span class="line">        *(p++) = i;            //*p1++结果相同</span><br><span class="line">    p-=10;</span><br><span class="line">    printf(&quot;p[0] = %f,  p[3] = %f,  p[9] = %f\n&quot;, *p,  *(p+3), *(p+9));</span><br><span class="line"></span><br><span class="line">    free(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 00000000009D14A0,  p + 1 = 00000000009D14A4,  p + 3 = 00000000009D14AC</span><br><span class="line">p[0] = 0.000000,  p[3] = 3.000000,  p[9] = 9.000000</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。</p>
<p>第3行：stdlib.h头文件引入函数calloc( )及free( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float* p = (float*)calloc(10,sizeof(float));</span><br></pre></td></tr></table></figure>

<p>第6行：与malloc(n)函数直接指定要申请空间的字节数不同，calloc(n, size)函数提供了两个参数，n表示期望存储的元素个数，size则表示每个元素的字节数。本例中，10 * sizeof(float) &#x3D; 10 * 4 &#x3D; 40，calloc( )将申请40个字节的内存，然后返回void*。与malloc( )函数保存申请内存的原始状态不同，calloc( )函数会自动将所申请的内存全部设置为0值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;p = %p,  p + 1 = %p,  p + 3 = %p\n&quot;, p, p+1, p+3);</span><br></pre></td></tr></table></figure>

<p>第10行：将指针p，p+1，p+3按地址格式输出。从执行结果的第1行可见，p+1的结果并不是p值加上整数1，而是p值加上4（0x09D14A0到0x09D14A4）， 即sizeof(float)；类似地，p+3的结果在数值上等于p值加12，即3<em>sizeof(float)（0x09D14A0到0x09D14AC）。当ElementType</em>类型的指针p加上整数i时，其结果仍是一个ElementType*类型的指针，该指针的值为：<br>p+i×sizeof(ElementType)p+i×sizeof(ElementType)<br>直观地，可以认为指针p向高地址方向滑动了i个ElementType。本例中，p+3得到的新指针相对于p，住高地址方向移动了3个float。类似地，ElementType*类型的指针p减去整数i，相当于指针p往低地址方向移动了i个ElementType； p++相当于指针p往高地址方向移动了一个ElementType，p–则是往低地址方向移动了一个ElementType。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;10;i++)</span><br><span class="line">    *(p++) = i;            //*p1++结果相同</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：将第6行calloc( )返回的内存空间视为包含10个float的数组，通过for循环将数组内的元素依次设置为0 ~ 9。请注意，对于循环体内的代码*(p++)，p++是先取值，后递增，所以，(p++)返回的是递增之前的指针p，这个返回的指针再打上<em>号（间接操作符），即为数组的第i个元素。事实上，如第13行的注释所述，这里的</em>(p++)也可以写成*p++，结果完全相同。作者在这里有意加上的括号有助于改善代码的可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-=10;</span><br></pre></td></tr></table></figure>

<p>第14行：第12 ~ 13行的循环共执行了10次p++，指针p的位置已指向数组外部元素。p -&#x3D; 10将指针p移回至数组的首元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;p[0] = %f,  p[3] = %f,  p[9] = %f\n&quot;, *p,  *(p+3), *(p+9));</span><br></pre></td></tr></table></figure>

<p>第15行：打印<em>p、</em>(p+3)和*(p+9)的值。执行结果的第2行说明，<em>p的值即为p[0]、</em>(p+i)的值即为p[i]。</p>
<p><img src="http://codelearn.club/images/image-20200225135634770.png" alt="image-20200225135634770"></p>
<p>图6- 指针在数组上的移动</p>
<p>图6- 展示了上述代码循环内十次执行p++，以及p -&#x3D; 10时指针p在数组上的移动过程。该图中，每个单元格代表４个字节，每个单元格正好存入一个float。 每执行一次p++，p指向往高地址方向移动至下一个元素；p -&#x3D; 10时，p往低地址方向移动10个元素，重新指向数组的首元素。</p>
<p>综上所述，指针p加减一个整数后所得到的新指针的值，与该指针的类型有关。当指针是p是一个float<em>时，p+1事实上将相关地址增加了4。推而广之，当指针p是一个char</em>时，p+1则只将地址值加1。借助于指针在数组内的移动，下述C语言程序将一个C风格字符串中的小写英文字母全部改为大写，同时保持其它字符不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - PointerOperation2</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char s[] = &quot;Mary has 3 lambs.&quot;;</span><br><span class="line">    char* p = s;</span><br><span class="line"></span><br><span class="line">    while (*p!=0)&#123;      //*p!=0 等价于 (*p)!=0</span><br><span class="line">        if (islower(*p))</span><br><span class="line">            *p = *p + (&#x27;A&#x27; - &#x27;a&#x27;);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;s = %s&quot;,s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = MARY HAS 3 LAMBS.</span><br><span class="line">#include &lt;ctype.h&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：ctype.h头文件引入了islower( )函数，该函数接受一个字符作为参数，判断该字符是否是小写英文字母。类似的函数还有isalpha( )、isblank( )、isupper( )、isdigit( )等，读者很容易从这些函数的函数名推断其功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (*p!=0)&#123;      //*p!=0 等价于 (*p)!=0</span><br><span class="line">    if (islower(*p))</span><br><span class="line">        *p = *p + (&#x27;A&#x27; - &#x27;a&#x27;);</span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9 ~ 13行：while循环将<em>p不为0作为循环条件遍历整个字符数组，因为字符数组会以0值表示终止。在循环体内，先判断p所指向的字符</em>p是否是小写字母，如果是，修改其值，将其转换成大写字母。在处理完当前字符后，p++将p移动至下一个字符。由于指针p的类型为char*，所以p++只会导致p的值增加1，因为sizeof(char)等于1。</p>
<p>输出结果证实，上述转换获得了成功，所有的小写字母变成了大写，而字符串中原有的大写字母、空格及数字没有改变。</p>
<h3 id="6-6-指向指针的指针"><a href="#6-6-指向指针的指针" class="headerlink" title="6.6 指向指针的指针*"></a>6.6 指向指针的指针*</h3><p>如果一个指针指向一个int类型的对象，那么该指针的类型为int*。如果一个指针指向的对象不是一个平凡的对象，而是另外一个指针，那么这个指针就成为“指向指针的指针”。请见下述C语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - Pointer2Pointer</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    int *p = &amp;a;</span><br><span class="line">    int **pp = &amp;p;</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;a = %p, p = %p\n&quot;, &amp;a, p);   //p的值为a的地址</span><br><span class="line">    printf(&quot;&amp;p = %p, pp = %p\n&quot;, &amp;p, pp); //pp的值为p的地址</span><br><span class="line">    printf(&quot;&amp;pp = %p\n&quot;, &amp;pp);</span><br><span class="line">    printf(&quot;before: a = %d, *p = %d, **pp = %d\n&quot;, a, *p, **pp);</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    (*p)++;</span><br><span class="line">    **pp = **pp + 1;</span><br><span class="line"></span><br><span class="line">    printf(&quot;after: a = %d, *p = %d, **pp = %d\n&quot;, a, *p, **pp);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;a = 000000000061FE1C, p = 000000000061FE1C</span><br><span class="line">&amp;p = 000000000061FE10, pp = 000000000061FE10</span><br><span class="line">&amp;pp = 000000000061FE08</span><br><span class="line">before: a = 100, *p = 100, **pp = 100</span><br><span class="line">after: a = 103, *p = 103, **pp = 103</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果前3行中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">int **pp = &amp;p;</span><br></pre></td></tr></table></figure>

<p>第5 ~ 7行：定义了三个变量a、p以及pp。根据程序的输出值，我们画出了下述示意图。</p>
<p><img src="http://codelearn.club/images/image-20200225155500938.png" alt="image-20200225155500938"></p>
<p>图6- a、p及pp之间的关系</p>
<p>从图6- 中可以看出，a、p、pp都是变量，只是类型各不相同，它们都有自己的存储地址和空间。p是指向a的指针，p的值即为a的地址；pp则是指向p的指针，pp的值即为p的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;a = %p, p = %p\n&quot;, &amp;a, p);   //p的值为a的地址</span><br></pre></td></tr></table></figure>

<p>第9行：输出a的地址及p的值，从执行结果的第1行可见，p值即为a的地址，指针p指向a。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;p = %p, pp = %p\n&quot;, &amp;p, pp); //pp的值为p的地址</span><br></pre></td></tr></table></figure>

<p>第10行：输出p的地址及pp的值，从执行结果的第2行可见，pp的值即为p的地址，指向指针的指针pp指向指针p。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;pp = %p\n&quot;, &amp;pp);</span><br></pre></td></tr></table></figure>

<p>第11行：输出pp的地址。从执行结果的第3行可见，pp也是一个对象，拥有自己的内存及地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;before: a = %d, *p = %d, **pp = %d\n&quot;, a, *p, **pp);</span><br></pre></td></tr></table></figure>

<p>第12行：输出a，<em>p以及**pp的值。pp是一个指向指针的指针，</em>pp即为p，*<em>pp等价于</em>p，即为a。执行结果的第4行可见，三种途径都输出了相同的值，即a的值100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++;</span><br><span class="line">(*p)++;</span><br><span class="line">**pp = **pp + 1;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 16行：通过a、*p以及**pp三种方式修改a的值，执行完后，a值预期应为103。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;after: a = %d, *p = %d, **pp = %d\n&quot;, a, *p, **pp);</span><br></pre></td></tr></table></figure>

<p>第18行：再次输出a，*p以及**pp的值。执行结果的第5行可见，三种途径都事实上输出了a值，为103。</p>
<h3 id="6-7-main函数的参数"><a href="#6-7-main函数的参数" class="headerlink" title="6.7 main函数的参数"></a>6.7 main函数的参数</h3><p>读者如果有使用Linux终端或者Windows命令行的的经验，便知道操作系统是可以向应用程序传递参数的。比如，下述Linux终端命令将为当前目录下的文件file1制作一份拷贝，其文件名为file2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>

<p>这行命令里的字符串”file1”、”file2”即为cp命令的参数。读者自行创建并构建（build）▲完成的可执行程序也是应用程序，我们也可以通过操作系统为自己的应用程序提供参数，影响该应用程序的行为。</p>
<p>请读者在Qt Creator中新建一个名为add的Plain C Application，然后将其中的main.c内容修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - add</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;   //char *argv[]</span><br><span class="line">    for (int i=0;i&lt;argc;i++)</span><br><span class="line">        printf(&quot;%d: %s,  %p\n&quot;, i, argv[i], argv[i]);</span><br><span class="line"></span><br><span class="line">    int iSum = 0;</span><br><span class="line">    for (int i=1;i&lt;argc;i++)</span><br><span class="line">        iSum += atoi(argv[i]);</span><br><span class="line"></span><br><span class="line">    printf(&quot;sum = %d&quot;,iSum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译并运行程序前，我们还需要在Qt Creator中做一些设置，以便指定程序运行的参数。在Qt Creator中选择“项目“页，在”运行设置“中将Command line arguments设置为33 777 103，这相当于给应用程序提了以空格分隔的三个参数，分别为33、777和103，如图6- 所示。请注意图中箭头以及黑色方框标识的内容。</p>
<p><img src="http://codelearn.club/images/image-20200225184235327.png" alt="image-20200225184235327"></p>
<p>图6- 运行参数设置</p>
<p>接下来运行程序，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: C:\C2Cpp\C6_Pointer_Reference\build-add-Desktop_Qt_5_14_1_MinGW_64_bit-Debug\add.exe,  00000000001E14A0</span><br><span class="line">1: 33,  00000000001E1420</span><br><span class="line">2: 777,  00000000001E1440</span><br><span class="line">3: 103,  00000000001E1500</span><br><span class="line">sum = 913</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<p>要解释这段程序及其执行结果，需要从main( )函数的参数说起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)&#123;   //char *argv[]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>argc及argv都是通过操作系统传递给应用程序的：</p>
<ul>
<li>argc为int类型，表示操作系统传递给应用程序的参数个数。argc应该源自英文<strong>arg</strong>uments <strong>c</strong>ount，意即参数总数。</li>
<li>argv为char<strong>，它是一个指向指针的指针。事实上，argv指向的内存块中存储了argc个地址，每个地址均指向一个以0结尾的字符数组，这些字符数组即为参数字符串。实践中，可以把指针argv视为一个一维数组的数组名，该数组中有argc个元素，每个元素是一个类型为char<em>的指针。所以，有的教科书中会将main( )函数中的argv描述成char</em> argv[ ]，意即元素类型为char*的一维数组。argv这个名字源自英文</strong>arg**uments <strong>v</strong>ector，意即参数向量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：stdlib.h头文件引入函数atoi( const char* str)，该函数将参数字符串转换成对应的整数。如果希望将字符串转换成浮点数，应使用函数atof( )。提醒读者注意，提供给atoi( )函数的参数字符串需要是合法的整数格式，否则可能会引发错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;argc;i++)</span><br><span class="line">    printf(&quot;%d: %s,  %p\n&quot;, i, argv[i], argv[i]);</span><br></pre></td></tr></table></figure>

<p>第6 ~ 7行：通过循环，将argc个argv[i]分别按字符串以及地址形式输出。本例中，执行结果的前4行为相关输出。可以看出，argc的值为4，其中，第0个参数字符串即为被运行的可执行文件的路径，后面3个就是我们在”运行设置“中填入的Command line arguments。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int iSum = 0;</span><br><span class="line">for (int i=1;i&lt;argc;i++)</span><br><span class="line">    iSum += atoi(argv[i]);</span><br></pre></td></tr></table></figure>

<p>第9 ~ 11行：通过循环将除去第0个之外的全部参数字符串转换为整数，并求和。从字符串到整数的转换是通过atoi( )函数完成的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sum = %d&quot;,iSum);</span><br></pre></td></tr></table></figure>

<p>第13行：打印求得的和。</p>
<p>直观上，本例中的应用程序add.exe将参数中列出的全部整数相加，并输出和值。</p>
<p>为了进一步让读者体会参数字符串的使用， 作者在自己的Windows 10计算机上，进行了如下操作：</p>
<ul>
<li>进入Windows命令行；</li>
<li>通过cd命令进入到了可执行文件add.exe所在的目录，路径可在本例执行结果的第1行找到；</li>
<li>执行命令add.exe 11 22 33 44，应用程序add.exe脱离Qt Creator运行，输出了和110。</li>
</ul>
<p>相关过程如图6- 所示。</p>
<p><img src="http://codelearn.club/images/image-20200225192920700.png" alt="image-20200225192920700"></p>
<p>图6- 应用程序的命令行执行方法</p>
<h3 id="6-8-指针与常量"><a href="#6-8-指针与常量" class="headerlink" title="6.8 指针与常量"></a>6.8 指针与常量</h3><p>如第3章所述，常量（constant）是只读的对象。指针作为对象，既可以是变量，也可以是常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int a = 10;</span><br><span class="line">//int* p1 = &amp;a;     //错误：a的地址为const int*，而p1是int*</span><br></pre></td></tr></table></figure>

<p>第2行代码错误，a的类型为const int，&amp;a的类型为const int<em>，而p1的类型为int</em>。如果将a的地址赋值给p1，则意味着通过*p1可以修改对象a，a的常量特性被破坏。如果试图把一个指向常量对象的指针（&amp;a）赋值给一个指向非常量对象的指针（p1），编译器会拒绝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int b = 10;</span><br><span class="line">const int* p2 = &amp;b;</span><br><span class="line">//*p2 = *p2 * 2;    //错误：p2指向const int，不可以修改*p2</span><br></pre></td></tr></table></figure>

<p>第2行代码正确无误。b为int，&amp;b的类型为int<em>，p2为const int</em>，将&amp;b赋值给p2，只是不允许通过p2修改b，赋值完成后，b仍然是变量。</p>
<p>第3行代码错误，p2是指向const int的指针，不允许修改*p2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int c = 10, d = 11;</span><br><span class="line">const int* const p3 = &amp;c;</span><br><span class="line">//*p3 = 101;        //错误：p3指向const int，不可修改*p3</span><br><span class="line">//p3 = &amp;d;          //错误：p3自身是常量，不可修改其值改变其指向</span><br></pre></td></tr></table></figure>

<p>第2行代码里出现了两个const，对于指针p3而言，这两个const具有不同的意义：前者用于修饰p3指向的对象，意即p3所指向的对象为常量；后者用于修饰p3，意即p3是常量，除初始化赋值外，不可以修改p3的值改变其指向。如图6- 所示。</p>
<p><img src="http://codelearn.club/images/image-20200226152144545.png" alt="image-20200226152144545"></p>
<p>图6- 指向常量的常量型指针</p>
<p>所以，第3行代码错误，*p3，即p3所指向的对象不可以修改；第4行也错误，不可以修改常量p3。</p>
<h3 id="6-9-引用"><a href="#6-9-引用" class="headerlink" title="6.9 引用"></a>6.9 引用</h3><p>C语言的指针实在是太难以理解和使用了，很多试图入门的初学者放弃于“指针”。但对于编程语言而言，指针并非必须，Python、Java等语言都没有指针。为了降低语言的难度，<strong>【C++】</strong>引入了<strong>引用（reference）</strong>，可以实现与指针类似的用途。请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - BasicRef</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iRabbits = 100;</span><br><span class="line">    int&amp; iBunnies = iRabbits;</span><br><span class="line">    printf(&quot;&amp;iRabbits = %p, &amp;iBunnies = %p\n&quot;, &amp;iRabbits, &amp;iBunnies);</span><br><span class="line"></span><br><span class="line">    iRabbits += 10;</span><br><span class="line">    iBunnies += 5;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;iRabbits = &quot; &lt;&lt; iRabbits &lt;&lt; &quot;, iBunnies = &quot; &lt;&lt; iBunnies &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;iRabbits = 000000000061fe14, &amp;iBunnies = 000000000061fe14</span><br><span class="line">iRabbits = 115, iBunnies = 115</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp; iBunnies = iRabbits;</span><br></pre></td></tr></table></figure>

<p>第8行：行中的&amp;符号不是取地址操作符，而是iBunnies的类型的一部分。iBunnies的类型为<strong>int&amp;<strong>，它是iRabbits对象的别名（alias）。我们称iBunnies是对iRabbits的</strong>引用（reference）</strong>。引用关系建立起来以后，iBunnies与iRabbits可以等效使用，两个名字关联了同一个对象。这就好比杜甫又称杜子美，两个名字都指的是同一个人。杜甫是本尊（被引用对象），杜子美是别名（引用）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;iRabbits = %p, &amp;iBunnies = %p\n&quot;, &amp;iRabbits, &amp;iBunnies);</span><br></pre></td></tr></table></figure>

<p>第9行：分别对iRabbits和iBunnies取地址并输出。执行结果的第1行证实，两者事实上指同一个对象，因为地址相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iRabbits += 10;</span><br><span class="line">iBunnies += 5;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 12行：给iRabbits变量加10， 通过iBunnies引用给iRabbits变量加5。以上累计，iRabbits变量加了15，其值变为115。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;iRabbits = &quot; &lt;&lt; iRabbits &lt;&lt; &quot;, iBunnies = &quot; &lt;&lt; iBunnies &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第14行：打印iRabbits及iBunnies的值。执行结果第2行可见，均为115，印证了两者事实是同一个对象的结论。</p>
<p><strong>引用的实质是自解析的指针</strong>。本例中，我们可以想像引用iBunnies内部有一个指针&#x2F;地址，当然第8行代码定义iBunnies并将iBunnies引用到iRabbits时，程序会取得iRabbits对象的地址，并赋值给iBunnies内部的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int&amp; iBunnies = iRabbits;</span><br></pre></td></tr></table></figure>

<p>对第8行代码可以做出下述“形象理解”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iBunnies的内部指针 = &amp;iRabbits;</span><br></pre></td></tr></table></figure>

<p>在后续代码中如果使用到iBunnies，由于编译器知道iBunnies是一个引用，它会自动解析iBunnies内部保存的指针&#x2F;地址。所以对iBunnies的操作即是对iRabbits的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iBunnies += 5;</span><br></pre></td></tr></table></figure>

<p>对第12行代码可以做出下述“形象理解”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iBunnies的内部指针 += 5;      //iBunnies的内部指针即为iRabbits的地址</span><br></pre></td></tr></table></figure>

<p>虽然引用的实质是自解析的指针，但引用与指针存在诸多差异。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 3, b = 4;</span><br><span class="line">int* p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>

<p>指针可以通过赋值修改其指向，比如，上述程序中的p在第2行被初始化为指向变量a，然后第3行又修改了p的值，让其指向变量b。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int c = 3, d = 4;</span><br><span class="line">int&amp; r = c;  //必须在定义时初始化r，将其与特定的对象相绑定</span><br><span class="line">r = d;       //不是将r的指向改向d，而是把d赋值给r引用的变量c</span><br><span class="line">cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; &quot;, d = &quot; &lt;&lt; d &lt;&lt;&quot;, r = &quot; &lt;&lt; r;</span><br></pre></td></tr></table></figure>

<p><strong>引用必须在定义时与其它对象绑定，且不可能通过赋值改变绑定关系</strong>。上述代码中第2行将r与c绑定，如果定义引用时不给予初始化，编译器会报错。第3行并不能将r的绑定对象从c迁移至d，而是把d赋值给r的绑定对象c。所以第3行执行完成后，c、d以及r的值都应该是4。</p>
<blockquote>
<p><strong>要点🎯</strong> 引用一旦定义并初始化与其他对象的绑定关系，这种绑定关系便不可修改。从这个角度，我们可以认为<strong>引用内部的指针是一个常量</strong>。</p>
</blockquote>
<p>我们也可以定义和使用常量型引用，如下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float e = 3.14f;</span><br><span class="line">const float&amp; f = e;</span><br><span class="line">e += 1.0;</span><br><span class="line">//f += 1.0;           //不可以修改常量型引用</span><br><span class="line">cout &lt;&lt; &quot;e = &quot; &lt;&lt; e &lt;&lt; &quot;, f = &quot; &lt;&lt; f;</span><br></pre></td></tr></table></figure>

<p>第2行的f是关于浮点数e的常量型引用，这意味着不能修改f，或者说不能通过f修改e。但直接修改e依然是合法的，如上述代码中的第3行。当第3行给e加上1.0使得e变成4.14后，第5行中输出的f值也会是4.14。</p>
<p>当我们使用auto类型推断<strong>【C++ 11】</strong>时，变量的类型默认是非引用的。比如，下述代码中的循环变量x，其类型将被推断为float，在循环过程中，x将是prices数组中元素的品。第3行对x的修改，并不会导致prices数组元素的改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float prices[] &#123;56.12f, 99.0f, 1.7f, 14.47f&#125;;</span><br><span class="line">for (auto x:prices)</span><br><span class="line">    x *= 1.2f;</span><br></pre></td></tr></table></figure>

<p>如果在auto关键字后加上&amp;符号，变量将被推断为引用类型。比如，下例中的循环变量f，将被推断为float&amp;类型，在循环中对f的修改，即是对prices数组元素的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; f:prices)</span><br><span class="line">    f *= 1.2f;</span><br></pre></td></tr></table></figure>

<h3 id="6-10-引用与函数"><a href="#6-10-引用与函数" class="headerlink" title="6.10 引用与函数"></a>6.10 引用与函数</h3><p>由于引用的实质就是自解析的指针，所以，当一个函数的形参类型定义为引用时，真正被传入函数的将是实参的地址。请见下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - RefFunc</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap1(float&amp; a, float&amp; b)&#123;</span><br><span class="line">    printf(&quot;&amp;a = %p, &amp;b = %p\n&quot;, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    float t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float m = 1.1f, n = 9.9f;</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;m = %p, &amp;n = %p\n&quot;, &amp;m, &amp;n);</span><br><span class="line">    swap1(m,n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;after swap1: m = &quot; &lt;&lt; m &lt;&lt; &quot;, n = &quot; &lt;&lt; n;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;m = 000000000061fe1c, &amp;n = 000000000061fe18</span><br><span class="line">&amp;a = 000000000061fe1c, &amp;b = 000000000061fe18</span><br><span class="line">after swap1: m = 9.9, n = 1.1</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第1 ~ 2行中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void swap1(float&amp; a, float&amp; b)&#123;</span><br></pre></td></tr></table></figure>

<p>第6 ~ 12行：定义了swap1( )函数，用于交换两个形参的值。请注意，形参a及b的类型为引用 - float&amp;。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;a = %p, &amp;b = %p\n&quot;, &amp;a, &amp;b);</span><br></pre></td></tr></table></figure>

<p>第7行：在swap1( )函数内部，打印形参a，b的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float m = 1.1f, n = 9.9f;</span><br></pre></td></tr></table></figure>

<p>第15行：定义了两个浮点数对象m及n，初始值分别为1.1和9.9。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;m = %p, &amp;n = %p\n&quot;, &amp;m, &amp;n);</span><br></pre></td></tr></table></figure>

<p>第17行：打印了m，n的地址。从执行结果的第1 ~ 2行可见，实参m的地址与形参a相同，实参n的地址与形参b相同。证明a是m的引用，b是n的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap1(m,n);</span><br></pre></td></tr></table></figure>

<p>第18行：以m，n为实参调用执行函数swap1( )，由于swap1( )的形参为引用类型，所以实际参数传递的不是m，n的值，而是m，n的地址。其中，m的地址递给了引用a”内部的指针“，n的地址传递给了引用b”内部的指针“。在这行代码里，我们并没有应用&amp;操作符取m和n的地址，这种取地址的操作是编译器根据swap1( )所要求的形参类型float&amp;自动添加的。由于形参a，b是实参m，n的引用，所以swap1( )函数内对形参a，b的操作事实上就是对实参m，n的操作，函数执行过程中将实际交换外部变量m，n的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;after swap1: m = &quot; &lt;&lt; m &lt;&lt; &quot;, n = &quot; &lt;&lt; n;</span><br></pre></td></tr></table></figure>

<p>第20行：在swap1( )函数执行完毕后打印m，n的值。从执行结果的第3行可见，m、n的值被成功交换。</p>
<p>另请读者注意，本例中的函数名为swap1，而不是swap。在C++的标准库中，已经存在一个名为swap的模板函数▲，为了避免与其重名，本例中的函数名定为swap1。</p>
<p>综上所述，通过引用可以达成与指针类似的目的。但相较于指针，引用更容易理解和使用，在使用C++编程时，作者本人坚持能用引用解决就尽量不用指针的原则。这种传递引用调用函数的方法，称为<strong>传引用调用（call by reference）</strong>。</p>
<p>当函数的形参是引用类型时，编译器对实参的类型匹配提出了更高要求。下述C++程序中第9行，第11行都会被编译器拒绝（早期比较宽松的编译器可能只给出警告）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void swap1(float&amp; a, float&amp; b)&#123;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double m = 3.0, n = 4.0;</span><br><span class="line">    //swap1(m,n);           //错误：无法将double类型引用为float&amp;</span><br><span class="line">    float c = 3.0f;</span><br><span class="line">    //swap1(c, c+1.2f);     //错误：c+1.2f为临时对象，无确定的内存实体，无法传递引用</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9行：m，n均为double类型，而swap1( )函数要求传递float类型的引用。</p>
<p>第11行：c + 1.2f对于编译器而言，是一个临时对象，没有确定的内存实体，无法为其生成引用。</p>
<p>上述第9、11行被编译器拒绝的真正理由是：函数的形参是非常量型引用，这意味着在函数内部，可能会通过修改引用型形参来事实上改变外部对象。事实上，对于代码的第9行，早期的不严格的编译器会通过隐式类型转换生成两个float类型的m，n品，然后以临时品变量为基础，生成形参a、b的引用。这样，函数对形参的修改事实上成了对用完即弃的”临时对象“的修改，这通常不是程序员本意，常常会导致程序缺陷。所以，新的C++标准不允许这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">double getCircleArea(const double&amp; r)&#123;</span><br><span class="line">    return 3.1415926 * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double dArea = getCircleArea(7.6f);   //正确</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的第6行则完全没有问题。虽然，7.6f是一个float类型的字面量，这意味着：</p>
<ul>
<li>类型不符，getCircleArea要求的是double类型的引用。</li>
<li>字面量不是一个有内存实体的对象，无法取地址。</li>
</ul>
<p>但是，编译器会接受第6行的编译。原因在于getCircleArea( )的形参是一个常量型引用，在函数内，不能修改形参，函数只是使用到形参的值而已。此时，编译器会为7.6f临时生成一个double类型的品，然后传递品对象的常量型引用给形参r。既然函数只是需要这个值，那编译器想尽一切办法向它提供这个值，没什么不对。</p>
<p>【？缺： 常量型引用参数， 要等到讲完结构或者类再讲】</p>
<p>【？缺：C++11的右值引用】</p>
<h2 id="7-函数与抽象"><a href="#7-函数与抽象" class="headerlink" title="7. 函数与抽象"></a>7. 函数与抽象</h2><p>懒是人类进步的阶梯。　　　　　　　　—　　亚历山大·陈</p>
<hr>
<p>这是个玩笑，没有哪位先贤，更没有哪位姓陈的名人说过这句话。这是作者本人自创的（作者英文名为alex)。人们为了省心省力，事半功倍，努力研究工作中交叉与独立、变与不变的哲学，并将通用部分抽象出来。这种抽象反应在程序设计上，其中一个成果就是函数。</p>
<p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="7-1-抽象的威力"><a href="#7-1-抽象的威力" class="headerlink" title="7.1 抽象的威力"></a>7.1 抽象的威力</h3><p>作为一个司机，你只知道，把油门踏板往下踩，车就会加速。至于汽车是如何做到加速的，你几乎不用关心。如果只有了解汽车发动机、悬挂系统、控制系统全部细节的人才可以开车，那北京的三环路一定修得太宽了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (true) &#123;</span><br><span class="line">    auto cmd = fectchCommandFromQueque();</span><br><span class="line">    if (cmd)&#123;</span><br><span class="line">        auto resp = executeCommand(cmd);</span><br><span class="line">        sendResponse(resp);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        sleep(0.01);</span><br><span class="line">    readAndParseCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个有经验的程序员，看到这些代码，就能够猜出来这段程序大概是在做什么：看起来，这是某个监听服务程序，程序不断地读取并分析来自网络或者其它信源的命令，如果拿到一个命令，就执行之，并且将执行结果发回。如果本轮循环没有拿到命令，还“小睡”一会儿，估计是避免不必要地过多占用CPU时间或者网络带宽。</p>
<p>之所以能在没有任何文档的情况下让程序具备一定的可读性，其中一个原因就是抽象。我们把那些需要重复执行或者多处调用的功能，如发送执行结果，抽象并封装成了函数sendResponse( )。而这些函数和变量的命名，很好地描述了其使命。作为函数的使用者，我们只需要知道执行executeCommand( )函数，把符合格式要求的命令cmd作为参数传递给它，它就会执行相应命令，并返回结果。至于，函数内部实现这些命令的细节，我们可以不了解。</p>
<p>想象一下，如果不抽象并将重复子功能封装成函数，上述程序的主体代码可能长达几千行。要了解代码的梗概，估计就要读个好几天，还不一定读得懂。如果程序员做任何事都要搞清楚全部细节，那Windows操作系统根本就不可能诞生。因为，没有任何正常人类可以读完并全部了解数千万行代码的细节。</p>
<p>本章主要讨论函数的定义与使用。而函数，是结构化编程的核心，同时也是面向对象编程的基础。</p>
<h3 id="7-2-函数的定义"><a href="#7-2-函数的定义" class="headerlink" title="7.2 函数的定义"></a>7.2 函数的定义</h3><p>说到函数，大家可能会想到的数学中的二次函数，例如:f(x)&#x3D;x2+3x+1，它对应二维平面中的一条曲线。</p>
<p><img src="http://codelearn.club/images/sxhs.png" alt="sxhs"></p>
<p>图7- 二次函数曲线</p>
<p>当取某个指定的x值，都会对应一个函数值f(x)。例如f(0)&#x3D;1,f(2)&#x3D;11,f(-4)&#x3D;5等等。</p>
<p>相对应，我们可以把这样一个一元二次函数定义为一个C语言的函数f。在这里，我们可以认为一个函数由输入、处理、输出三部分组成。函数接受的参数即是输入，例如x，函数返回的结果是输出，例如return y，中间的执行代码是处理过程。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - Quadratic</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">float f(float);					//函数的声明(declaration)或者原型(prototype)</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;f(0) = %f,  f(2) = %f,  f(-4) = %f&quot;, f(0),f(2),f(-4));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float f(float x)&#123;			   //函数的定义(definition)</span><br><span class="line">    float y = x*x + 3*x + 1;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(0) = 1.000000,  f(2) = 11.000000,  f(-4) = 5.000000</span><br><span class="line">float f(float);					//函数的声明(declaration)或者原型(prototype)</span><br></pre></td></tr></table></figure>

<p>第4行：f( )函数的声明（declaration)或者原型(prototype)。该函数原型描述了函数的名称、函数的形式参数的个数及类型、函数的返回值类型。对于编译而言，这些信息足够判定第7行的函数调用代码是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;f(0) = %f,  f(2) = %f,  f(-4) = %f&quot;, f(0),f(2),f(-4));</span><br></pre></td></tr></table></figure>

<p>第7行：以不同参数3次调用执行了f( )函数。在调用执行一个函数之前，必须满足下述条件之一：</p>
<ul>
<li>调用点之前已经给出了函数的原型，且在调用点之后存在函数的定义。</li>
<li>函数的定义位于调用点之前。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float f(float x)&#123;			   //函数的定义(definition)</span><br><span class="line">    float y = x*x + 3*x + 1;</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 14行：f( )函数的定义。</p>
<p>在C&#x2F;C++语言中，定义一个函数的通用语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参0类型  形参0名称，形式参数1类型 形参1名称， ... 形参n类型 形参n名称) </span><br><span class="line">&#123;</span><br><span class="line">	语句；</span><br><span class="line">	...</span><br><span class="line">	return 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，{ }包裹的部分称为函数体（function body）。函数名后括号内的部分为形式参数列表，当函数接受0个形参时，括号内可以留空， 或者填上一个void代表零参数。如果函数有多个return语句，则每个return语句后的返回值类型均应与函数的返回值类型相同，或者能够通过隐式类型转换转换成返回值类型。当函数没有返回值时，返回值类型用void代替，此时，return语句后不应跟上返回值。</p>
<h3 id="7-3-函数与一维数组"><a href="#7-3-函数与一维数组" class="headerlink" title="7.3 函数与一维数组"></a>7.3 函数与一维数组</h3><p>在算法 - 冒泡排序一节中，我们曾经将一个数组的数组名，即首元素地址作为参数传递给bubbleSort( )函数进行排序。本节将此问题进一步展开讨论。请先阅读下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - AverageArray1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">float average(const float a[], const unsigned int n)&#123;</span><br><span class="line">    printf(&quot;a = %p\n&quot;,a);</span><br><span class="line"></span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (unsigned int i=0;i&lt;n;i++)</span><br><span class="line">        fSum += a[i];</span><br><span class="line"></span><br><span class="line">    return fSum / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float scores[5] = &#123;50,60,70,80,90&#125;;</span><br><span class="line">    printf(&quot;scores = %p\n&quot;,scores);</span><br><span class="line"></span><br><span class="line">    float fAvg = average(scores,5);</span><br><span class="line"></span><br><span class="line">    printf(&quot;average = %f&quot;,fAvg);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scores = 000000000061FE00</span><br><span class="line">a = 000000000061FE00</span><br><span class="line">average = 70.000000</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第1 ~ 2行的地址很可能与本书不同。</p>
<p>函数功能：average( )函数计算并返回参数数组内全部元素的平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float average(const float a[], const unsigned int n)&#123;</span><br></pre></td></tr></table></figure>

<p>第4行：average( )函数定义。该函数有两个形式参数：</p>
<ul>
<li>a为需要进行平均值计算的参数数组，其类型为const float[ ]，意即元素类型为const float的数组的<strong>数组名</strong>。此处将a数组的元素类型指定为常量，是因为在计算平均值的过程中，并不需要也不应该修改参数数组。</li>
<li>n表示a数组内的元素个数， 类型为const unsigned int。由于元素个数不可能为负数，所以n设定为无符号整数；由于元素个数n不应该在函数体内修改，所以n设定为常量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a = %p\n&quot;,a);</span><br></pre></td></tr></table></figure>

<p>第5行：在函数体内将参数数组名a，即数组首元素的地址输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float scores[5] = &#123;50,60,70,80,90&#125;;</span><br></pre></td></tr></table></figure>

<p>第15行：定义并初始化了scores数组，容易看出，数组内元素的均值应为70。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;scores = %p\n&quot;,scores);</span><br></pre></td></tr></table></figure>

<p>第16行：将数组名scores，即数组首元素的地址输出。从执行结果的第1 ~ 2可见，scores与a的值，即数组的首元素地址相同。这说明，当函数调用时，实参scores向形参a的传递，事实上只传递了数组名，也就是scores数组首元素的地址。在函数内部对a数据元素的操作，事实上操作的是外部的scores数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float fAvg = average(scores,5);</span><br></pre></td></tr></table></figure>

<p>第18行：调用执行average( )函数，返回的平均值给fAvg变量。</p>
<p>综上所述，当函数的形参定义为数组时，该形参实际获得的是外部数组的首元素地址。本例中，无论外部scores数组有多少个元素，传递给形参a的只是scores数组的数组名，也就是首元素地址，传参效率很高。同时，作为一个单纯的数组名，average( )函数无法通过参数a确定数组的元素个数，所以，需要一个额外的n参数指明数组的元素个数。</p>
<p>按第6章的讨论，一维数组的数组名可以认为是一个指针，而指针也可以当成数组名使用。average( )函数也可以把形参a定义为指向const float的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float average(const float *a, const unsigned int n)&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>其执行效果完全相同。当average(scores, 5)被执行时，scores数组名作为地址被传递给了作为形参的指针a，然后，在函数体内部，把指针a当成数组名使用。</p>
<h3 id="7-4-函数与二维数组"><a href="#7-4-函数与二维数组" class="headerlink" title="7.4 函数与二维数组"></a>7.4 函数与二维数组</h3><p>考虑将下述二维数组作为参数传递给average( )函数计算全部元素的均值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float scores[2][3] = &#123;</span><br><span class="line">       &#123;50,60,70&#125;,</span><br><span class="line">       &#123;80,90,100&#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<p>则average( )函数的形参可按如下格式定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Project - AverageArray2</span><br><span class="line">float average(const float a[][3], const unsigned int n)&#123;</span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (unsigned int i=0;i&lt;n;i++)</span><br><span class="line">        for (unsigned int j=0;j&lt;3;j++)</span><br><span class="line">            fSum += a[i][j];</span><br><span class="line"></span><br><span class="line">    return fSum / (n*3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数有两个形参：</p>
<ul>
<li>参数a的类型为const float [ ][3]，意即：a是一个二维数组的数组名，这个数组的列数为3，行数未指定。这个奇怪的类型定义是有原因的，回顾第5章可知，当函数体内访问元素a[ i ][ j ]时，需要通过数组名a计算该元素的存储地址，而地址的计算，必须知道每行有多少个元素，即必须知道列数。所以，形参a定义时，<strong>必须给出列数</strong>3。至于a数组的总行数，上述地址计算过程中用不到，不必给出。</li>
<li>参数n指二维数组a内的行数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float fAvg = average(scores,2);</span><br></pre></td></tr></table></figure>

<p>当上述函数调用发生时，scores数组名传递给形参a，被传递的只是数组的首元素地址。函数体内部依赖于下述信息计算a[ i ][ j ]的元素地址，具体的计算方法请回顾第5章。</p>
<ul>
<li>数组名a，即二维数组scores的首地址；</li>
<li>数组的元素类型，const float，这意味着单个元素占4个字节；</li>
<li>数组的列数，依定义为3，这意味着数组内的每行有3个元素，每行占3 x 4 &#x3D; 12个字节；</li>
<li>下标i, j。</li>
</ul>
<p>综上， 当向一个函数传递二维数组时，形参数组定义时必须给出列数。进一步，当向一个函数传递n维数组时，形参数组定义时，必须给出除0维外的所有维度，比如const int a[ ][10][8][6]。</p>
<p>此外，C语言的设计者还给我们准备了难以理解的另一种语法格式，以便让我们知难而退：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float average2(const float (*a)[3], const unsigned int n)&#123;</span><br><span class="line">	...</span><br><span class="line">    return fSum / (n*3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>形参中的const float <strong>(*<strong>a</strong>)</strong>[3]可以按照如下方式理解：</p>
<ul>
<li>a是一个指针；</li>
<li>a所指向的对象为<strong>包含3个const float的一维数组</strong>。</li>
</ul>
<p>如果把a视为数组名，则数组的元素是也是数组，每个元素数组包含3个const float。换言之，a事实上是列数为3的二维数组。</p>
<p>上述形参a的定义中的括号是必须的，如果去掉括号成为const float* a[3]，编译器会做出完全不同的解读：</p>
<ul>
<li>a是一个包含3个元素的数组；</li>
<li>数组的元素类型为指向const float的指针，即const float*。</li>
</ul>
<p>考虑到const float (*a)[3]这种形式的二维数组形参太具有迷惑性，作者建议使用const float a[ ][3]这种语法。</p>
<h3 id="7-5-变量的作用域"><a href="#7-5-变量的作用域" class="headerlink" title="7.5 变量的作用域"></a>7.5 变量的作用域</h3><p>变量的<strong>作用域（scope）</strong>描述了变量在文件的多大范围内可见。程序中大多数的变量都是所谓<strong>局部变量（local variable）</strong>，它们具有<strong>块作用域（block scope）</strong>。所谓块作用域，就是指该变量的可见范围为从定义处开始直至包含该变量的块的末尾。一般地，<strong>块（block）</strong>指一对花括号**{ }**括起来的区域。我们通过下述C语言程序来解释局部变量的块作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - BlockScope</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)&#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    int b = 6;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        int a = 9;</span><br><span class="line">        int c = 10;</span><br><span class="line"></span><br><span class="line">        printf(&quot;a = %d, &amp;a = %p\n&quot;, a, &amp;a);     //第9行的内层a</span><br><span class="line">        printf(&quot;b = %d, &amp;b = %p\n&quot;, b, &amp;b);     //第6行的外层b</span><br><span class="line">        printf(&quot;c = %d, &amp;c = %p\n&quot;, c, &amp;c);     //第10行的内层c</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;a = %d, &amp;a = %p\n&quot;, a, &amp;a);         //第5行的外层a</span><br><span class="line">    //b = c;                                    //错误：b可见，但c不可见</span><br><span class="line">    printf(&quot;b = %d, &amp;b = %p\n&quot;, b, &amp;b);         //第6行的外层b</span><br><span class="line">    printf(&quot;argc = %d&quot;, argc);                  //main()函数的形参</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 9, &amp;a = 000000000061FE14</span><br><span class="line">b = 6, &amp;b = 000000000061FE18</span><br><span class="line">c = 10, &amp;c = 000000000061FE10</span><br><span class="line">a = 5, &amp;a = 000000000061FE1C</span><br><span class="line">b = 6, &amp;b = 000000000061FE18</span><br><span class="line">argc = 1</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，上述执行结果中的地址很可能与本书不同。</p>
<p>在上述程序中，存在两个块：</p>
<ul>
<li>main( )函数块，第4 ~ 22行。在这个块内，我们定义了第5行的a，第6行的b两个局部变量。此外，main( )的形参argc、argv也被编译器视为该块内的局部变量。本例中，main( )函数块处于外层，简称<strong>外层块</strong>。</li>
<li>第8 ~ 15行花括号内的区域也是一个块，由于它处于main( )函数块的内层，本例简称为<strong>内层块</strong>。在内层块中，我们定义了第9行的a，第10行的c局部变量。</li>
</ul>
<p>为了描述方便，我们让这些局部变量的初始值等于该变量定义时的行号，比如，第5行的a赋初值为5。我们结合图7- 来解释上述代码及其执行结果。</p>
<p><img src="http://codelearn.club/images/image-20200227225759526.png" alt="image-20200227225759526"></p>
<p>图7- 局部变量的块作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a = %d, &amp;a = %p\n&quot;, a, &amp;a);     //第9行的内层a</span><br></pre></td></tr></table></figure>

<p>第12行：本行代码位于内层块。由于块内第9行有一个变量a，所以此处输出的是第9行的内层a值9及其地址。从执行结果的第1行和第4行可以看出，内层块中的a与外层块中的a具有不同的地址，它们是<strong>不同的对象</strong>，只是恰好同名。</p>
<p>规则：<strong>当内层代码引用的变量名同时存在于内层和外层时，使用内层变量。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;b = %d, &amp;b = %p\n&quot;, b, &amp;b);     //第6行的外层b</span><br></pre></td></tr></table></figure>

<p>第13行：本行代码位于内层块。由于块内没有名为b的变量，所以此处输出的是第6行的外层b值6及其地址。见执行结果的第2行。</p>
<p>规则：<strong>当内层代码引用的变量名在内层中不存在时，编译器会尝试在外层中查找</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;c = %d, &amp;c = %p\n&quot;, c, &amp;c);     //第10行的内层c</span><br></pre></td></tr></table></figure>

<p>第14行：本行代码位于内层块。由于块内第10行有一个变量c，所以此处输出的是第10行的内层c值10及其地址。见执行结果的第3行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a = %d, &amp;a = %p\n&quot;, a, &amp;a);         //第5行的外层a</span><br></pre></td></tr></table></figure>

<p>第17行：本行代码位于外层块。内层块第9行的a已超作用域，不可使用。所以此处输出的是第5行的外层a值5及其地址。从执行结果的第4行可见，外层a的地址与内层a的地址（执行结果第1行）不同，它们是<strong>不同的对象</strong>，虽然同名，但互不干涉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//b = c;                                    //错误：b可见，但c不可见</span><br></pre></td></tr></table></figure>

<p>第18行：本行代码位于外层块。在此处，第6行的外层b是可用的，但第10行的内层c已超作用域，不可使用。故该行代码错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;b = %d, &amp;b = %p\n&quot;, b, &amp;b);         //第6行的外层b</span><br></pre></td></tr></table></figure>

<p>第19行：本行代码位于外层块。此处输出的是第6行的外层b值6及其地址。见执行结果的第5行。对照执行结果的第2行还可以证实，本例中，无论是内层代码还是外层代码，访问的是同一个b对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;argc = %d&quot;, argc);                  //main()函数的形参</span><br></pre></td></tr></table></figure>

<p>第20行：本行代码位于外层块。argc属于main( )函数的形参，编译器将其视为外层块的局部变量。</p>
<p>本例向我们证明，内层变量可与外层变量同名，两个或多个同名的变量事实上是独立的不同对象。在本例中，这个同名的变量为a，当在内层代码中使用a时，它指的是内层的a变量。正是基于这个理由，所以我们得以习惯性地在for循环中使用i作为循环变量名，而不用担心重名。</p>
<p>事实上，函数的实参和形参也可以重名且相互不干涉。请见下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - FuncParameter</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">float PI = 3.1415926F;</span><br><span class="line"></span><br><span class="line">float getCircleArea(float r)&#123;</span><br><span class="line">    printf(&quot;getCircleArea: &amp;r = %p\n&quot;, &amp;r);</span><br><span class="line">    return PI * r * r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float r = 4;</span><br><span class="line">    printf(&quot;main: &amp;r = %p\n&quot;, &amp;r);</span><br><span class="line"></span><br><span class="line">    float fArea = getCircleArea(r);</span><br><span class="line"></span><br><span class="line">    printf(&quot;fArea = %f&quot;,fArea);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main: &amp;r = 000000000061FE18</span><br><span class="line">getCircleArea: &amp;r = 000000000061FDF0</span><br><span class="line">fArea = 50.265480</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<p>上述执行结果中的第1行、第2行证实，main( )函数内的局部变量r与getCircleArea( )函数的形参r具有不同的内存地址，虽然重名，但互不干涉。再次重申：函数的形参应视为函数块内的局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float PI = 3.1415926F;</span><br></pre></td></tr></table></figure>

<p>第4行：定义了一个不属于任何块的变量PI，该变量具备所谓<strong>文件作用域（file scope）</strong>，该变量从定义行（第4行）开始一直到其所在文件main.c的结尾，都可见。</p>
<p>本节关于变量作用域的结论，同样适用于常量。</p>
<h3 id="7-6-递归"><a href="#7-6-递归" class="headerlink" title="7.6 递归"></a>7.6 递归</h3><p>中学数学里我们学过阶乘：<br>5!&#x3D;5×4×3×2×1&#x3D;5×(4×3×2×1)&#x3D;5×4!5!&#x3D;5×4×3×2×1&#x3D;5×(4×3×2×1)&#x3D;5×4!<br>同理，<br>n!&#x3D;n×(n−1)!n!&#x3D;n×(n−1)!<br>求4的阶乘同求5的阶乘是相同性质的问题，区别仅在于问题的规模不同（参数大小不一样）。如果我们定义了一个函数factorial(n)可以求出n的阶乘，那理论上，factorial(n)也可以求出n-1的阶乘。</p>
<p>数学上，通过函数自身来定义的函数称为递归函数。到程序设计领域，函数自己调用自己称为<strong>递归函数</strong>。请阅读下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - Factorial</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">long long factorial(int n)&#123;</span><br><span class="line">    printf(&quot;factorial(%d) is called, &amp;n = %p\n&quot;, n, &amp;n);</span><br><span class="line">    if (n==1)</span><br><span class="line">        return 1;</span><br><span class="line">    long long r = n * factorial(n-1);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;6! = %lld&quot;, factorial(6));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factorial(6) is called, &amp;n = 000000000061FE00</span><br><span class="line">factorial(5) is called, &amp;n = 000000000061FDB0</span><br><span class="line">factorial(4) is called, &amp;n = 000000000061FD60</span><br><span class="line">factorial(3) is called, &amp;n = 000000000061FD10</span><br><span class="line">factorial(2) is called, &amp;n = 000000000061FCC0</span><br><span class="line">factorial(1) is called, &amp;n = 000000000061FC70</span><br><span class="line">6! = 720</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long long factorial(int n)&#123;</span><br></pre></td></tr></table></figure>

<p>第4 ~ 10行：factorial( n )函数用于计算并返回n!。考虑到阶乘的值通常比较大，所以返回值定义为long long类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;factorial(%d) is called, &amp;n = %p\n&quot;, n, &amp;n);</span><br></pre></td></tr></table></figure>

<p>第5行：在函数体的开始部分打印形参n的值和地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (n==1)</span><br><span class="line">    return 1;</span><br></pre></td></tr></table></figure>

<p>第6 ~ 7行：如果n&#x3D;1，此时，问题足够简单，直接返回结果1。此处，我们称n&#x3D;&#x3D;1为递归的边界条件，这个边界条件保证了对于合法的n值，这个递归函数一定会运行结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long r = n * factorial(n-1);</span><br><span class="line">return r;</span><br></pre></td></tr></table></figure>

<p>第8 ~ 9行：factorial(n)函数调用执行了factorial(n-1)。只有当factorial(n-1)函数执行完后并返回结果后，factorial(n)才能计算出结果r，然后返回。</p>
<p>factorial()函数内部调用了factorial()函数自身，它是一个递归函数。factorial(6)的执行过程可以这样理解：为了求6的阶乘，函数调用函数自身求5的阶乘，为了求5的阶乘，函数调用自身求4的阶乘， … ，函数调用自身求1的阶乘，1的阶乘满足边界条件，返回结果1。得到了1的阶乘，factorial(2)通过 r &#x3D; 2<em>1 &#x3D; 2得到了2的阶乘并返回。得到了2的阶乘，factorial(3)通过r &#x3D; 3*2 &#x3D; 6得到了3的阶乘并返回。… 然后得到了5的阶乘为120，factorial(6)通过r &#x3D; 6</em>5! &#x3D; 6*120 &#x3D; 720得到6的阶乘，并返回给外部调用者。</p>
<p>可以想象，在factorial(1)函数被执行时，整个解释器内实际上有6个factorial()函数正在执行，分别是factorial(6)、 factorial(5) 、factorial(4) 、factorial(3) 、factorial(2) 、factorial(1)。factorial(1)执行完毕，返回值到factorial(2)，factorial(2)得到factorial(1)的返回值，计算后返回factorial(3)，…， 最终factorial(6)在得到factorial(5)的返回值后，再行计算返回给外部调用者。这一过程可以用图7- 表示，读者可以顺着图中箭头的标号和指向，人工模拟一遍执行过程。</p>
<p><img src="http://codelearn.club/images/image-20200228223223869.png" alt="image-20200228223223869"></p>
<p>图7- 递归执行过程</p>
<p>通过在程序中设置断点，然后借助程序调试方法对上述程序进行调试观察，有助于读者更好地理解递归函数的执行过程以及其对内存资源的消耗。</p>
<p>我们无法在大规模问题中使用递归函数，理由如下：</p>
<ul>
<li>本例中，形参n，变量r都是factorial( )函数块的局部变量。不难看出，当上述factorial(1)函数在执行时，事实上有6个factorial( )函数处于执行当中，在内存中，应该存在6个n对象，以及6个r对象。从执行结果第1 ~ 6行中的地址可以看出，这6个n具有<strong>不同的地址</strong>，是完全独立的对象。当n比较小时，计算机内存尚可应付，如果n很大，比如10000000000000，估计还没有运行到factorial(1)，数量众多的局部变量以及因函数调用而产生的额外内存消耗就会使栈▲空间枯竭，程序崩溃。</li>
<li>除了内存空间的占用，每次函数调用也会产生额外的运行代价：控制执行的跳转、参数传递、局部变量内存空间的准备和回收。海量次数的函数调用将产生海量的额外运算代价。</li>
</ul>
<p>所以，实践中，递归只能解决规模很小的问题（本例中，即n不能太大）。大多数有实际价值的算法和程序，都是非递归的。即便刚开始设计成递归的，最终也要想尽办法转换成非递归的。</p>
<p>但递归自身在数学上又相当的优美。现实世界中的很多问题，天生就是递归的，比如100个数排序，先把100个数分成两堆，各50个。两堆数分别排序，然后再顺序合并成100个有序的数。50个数排序同100个数排序，都是排序，性质相同，区别仅在于问题的规模不同（100 比 50)。由于这种天然的递归属性，我们用递归函数来描述算法，用递归程序来实现递归算法非常的简便和易于理解。还有很多问题，简单的如折半&#x2F;二分查找，复杂的如 01背包，都适合用递归来描述。但我们要牢记，描述算法和理解算法时可以用递归，但如果想得到实用的程序，要把递归给消去。消去递归的方法超出本书范围。</p>
<h3 id="算法-一对兔兔与函数的增长"><a href="#算法-一对兔兔与函数的增长" class="headerlink" title="算法 - 一对兔兔与函数的增长"></a>算法 - 一对兔兔与函数的增长</h3><p>【？缺】</p>
<h3 id="算法-归并排序"><a href="#算法-归并排序" class="headerlink" title="算法 - 归并排序"></a>算法 - 归并排序</h3><p>【？缺】</p>
<h3 id="算法-汉诺塔"><a href="#算法-汉诺塔" class="headerlink" title="算法 - 汉诺塔"></a>算法 - 汉诺塔</h3><p>法国数学家爱德华·卢卡斯曾转述过一个印度的古老传说：在世界中心贝拿勒斯（在印度北部）的圣庙里，一块黄铜板上插着三根金刚石柱。印度教的主神梵天在创造世界的时候，在其中一根石柱上从下到上的穿好了由大到小的64块金盘，这就是所谓的汉诺塔（Hanoi Tower）。</p>
<p>按照梵天的命令，不论白天黑夜，总有一个婆罗门僧侣在按照下面的规则移动这些金盘：一次只移动一个盘，不管在哪根柱上，小盘必须在大盘上面。僧侣们预言，当所有的金盘都从梵天穿好的那根柱上移到另外一根柱上时，世界就将在一声霹雳中消灭，而梵塔、庙宇和众生也都将同归于尽。</p>
<h4 id="1-求解"><a href="#1-求解" class="headerlink" title="1). 求解"></a>1). 求解</h4><p>如下图所示的5个盘的汉诺塔问题，其<strong>总任务</strong>是<strong>将A柱上的n &#x3D; 5个盘移至C柱</strong>。要实现这个总任务并且保证移盘过程中小盘始终在大盘上面，整个过程分三步实现。第1步：我们必须先将n - 1 &#x3D; 4个黑盘从A柱移至B柱。在第1步的执行过程当中，为了保证规则的贯彻，显然，必须借助于C柱作为中转柱才能完成。</p>
<p>第1步所做的工作可描述为：<strong>借助中转柱C， 将n-1&#x3D;4个盘从A移至B</strong>。</p>
<p><img src="http://codelearn.club/images/1542444136655.png" alt="1542444136655"></p>
<p> 现在，最大的白盘在A柱上，C柱是空的。可实施第2步：<strong>将A柱上的大盘取下，移至C柱</strong>。</p>
<p><img src="http://codelearn.club/images/1542445466353.png" alt="1542445466353"></p>
<p>接下来，我们要做的是第3步: <strong>借助中转柱A，将B柱上的n - 1 &#x3D; 4个盘移至C柱</strong>。此时，C柱上虽然已经有了一个盘，但由于此盘是最大的，所以只要移动过程中不搬动C柱上的原有大盘，可以忽略其存在。</p>
<p><img src="http://codelearn.club/images/1542445960115.png" alt="1542445960115"></p>
<p>现在，我们试图总结一下总任务及其三个子任务：</p>
<table>
<thead>
<tr>
<th>总任务: 将 n &#x3D; 5个盘从A柱移至C柱，以B柱为中转柱</th>
</tr>
</thead>
<tbody><tr>
<td>- 子任务1: 将 n - 1 &#x3D; 4个盘从A柱移至B柱，以C柱为中转柱；</td>
</tr>
<tr>
<td>- 子任务2: 将A柱上的大盘移至C柱；</td>
</tr>
<tr>
<td>- 子作务3：将n - 1 &#x3D; 4个盘从B柱移至C柱，以A柱为中转柱。</td>
</tr>
</tbody></table>
<p>不难看出，除了柱子不同，子任务3同子任务1所做的工作是一样的，都是把 n - 1 个盘从一个柱移至另一个柱。同时，子任务1，3与总任务之间也极其相似，除了需要移动的盘子数量差异外。</p>
<p>我们称，将n - 1个盘子从A移至B的汉诺塔问题，与原问题 - 即“将n个盘子从A移至C的汉诺塔问题”的性质完全相同，区别仅在于问题的规模 - 需要移动的盘子数量稍小。我也称为前者是原问题的子问题。</p>
<p>如果我们能将n - 1 &#x3D; 4个盘子从A移至B，从B移至Ｃ，那么n &#x3D; 5个盘子的汉诺塔问题可解。那么如何求解4个盘子的汉诺塔问题呢？ 聪明的读者已经有了答案。</p>
<table>
<thead>
<tr>
<th>子问题: 将 n’ &#x3D; 4个盘从A柱移至B柱，以C柱为中转柱</th>
</tr>
</thead>
<tbody><tr>
<td>- 子子问题1: 将 n’ - 1 &#x3D; 3个盘从A柱移至C柱，以B柱为中转柱；</td>
</tr>
<tr>
<td>- 简单任务: 将A柱上的大盘移至B柱；</td>
</tr>
<tr>
<td>- 子子问题2：将n’ - 1 &#x3D; 3个盘从C柱移至B柱，以A柱为中转柱。</td>
</tr>
</tbody></table>
<p> 下面的图展示了这一过程：</p>
<p><img src="http://codelearn.club/images/1542456814315.png" alt="1542456814315"></p>
<p><img src="http://codelearn.club/images/1542456843161.png" alt="1542456843161"></p>
<p>上面的分析可以看出，5盘汉诺塔问题可以通过求解4盘汉诺塔问题来解决，4盘汉诺塔问题可以通过求解3盘汉诺塔问题来解决。同理，3盘汉诺塔问题可以通过求解2盘汉诺塔问题来解决，2盘汉诺塔问题可以通过求解一盘汉诺塔问题来解决。而一盘汉诺塔问题，由于问题的规模足够小，可直接解决：把盘从原柱搬至目标柱即可。所以在前表中，我们称其为“简单任务”。</p>
<h4 id="2-递归算法"><a href="#2-递归算法" class="headerlink" title="2). 递归算法"></a>2). 递归算法</h4><p>根据前一小节描述的算法思想，我们可以写出汉诺塔问题求解的递归算法。请见下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Project - HanoiTower</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; steps;   //用于存放移盘序列的向量</span><br><span class="line"></span><br><span class="line">void hanoi(int n, const char* a, const char* b, const char* c) &#123;</span><br><span class="line">    if (n==1)</span><br><span class="line">        steps.push_back(string(a) + &quot; --&gt; &quot; + c);</span><br><span class="line">    else &#123;</span><br><span class="line">        hanoi(n-1, a, c, b);</span><br><span class="line">        steps.push_back(string(a) + &quot; --&gt; &quot; + c);</span><br><span class="line">        hanoi(n-1, b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    steps.clear();</span><br><span class="line"></span><br><span class="line">    hanoi(5,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Steps count: &quot; &lt;&lt; steps.size() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;First 3 steps are: &quot; &lt;&lt; steps[0] &lt;&lt; &quot;, &quot;</span><br><span class="line">         &lt;&lt; steps[1] &lt;&lt; &quot;, &quot; &lt;&lt; steps[2];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Steps count: 31</span><br><span class="line">First 3 steps are: A --&gt; C, A --&gt; B, C --&gt; B</span><br></pre></td></tr></table></figure>

<p>函数hanoi(n,a,b,c)用于生成以b为中转柱，将n个金盘从a移至c的移盘序列。可以看到，这个递归函数的执行过程跟前节的总任务-子任务分解完全一致。当n &#x3D;&#x3D; 1时，只有一个盘子，简单任务，直接移盘。如果n &gt; 1，则分解为两个 n - 1 的汉诺塔子问题，以及一个简单移盘任务。子问题的求解以函数递归调用来解决。</p>
<p>上述结果表明，5盘汉诺塔问题共需要31次移盘。steps向量按顺序存储了全部的移盘动作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; steps;   //用于存放移盘序列的向量</span><br></pre></td></tr></table></figure>

<p>第7行：vector（向量）类型由vector头文件引入。当前阶段，读者可以把vector<string>当成是一个容量“无限大”的超级数组，尖括号里的string则约定了该数组内存储的元素类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">steps.push_back(string(a) + &quot; --&gt; &quot; + c);</span><br></pre></td></tr></table></figure>

<p>第11、14行：push_back( )是steps向量的一个成员函数▲，它将参数字符串存入向量。string(a)是string类型的构造函数▲，它将char*类型的参数a转换成一个string类型的对象。由于steps是个容量“无限大”的超级数组，所以程序员可以放心地通过push_back( )函数将对象放入向量，而不必担心容量限制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;Steps count: &quot; &lt;&lt; steps.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第24行：size( )也是steps向量的成员函数，返回steps向量中存储的string对象的个数。此处表示n盘汉诺塔问题的移盘总次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;First 3 steps are: &quot; &lt;&lt; steps[0] &lt;&lt; &quot;, &quot;</span><br><span class="line">     &lt;&lt; steps[1] &lt;&lt; &quot;, &quot; &lt;&lt; steps[2];</span><br></pre></td></tr></table></figure>

<p>第25 ~ 26行：既然向量就是“超级数组”，则[ ]操作符对向量同样适用，它用于取向量中指定下标的元素。</p>
<p>关于vector类型的使用方法及工作原理，我们将来后续章节中进一步讨论。</p>
<h4 id="3-计算复杂性"><a href="#3-计算复杂性" class="headerlink" title="3). 计算复杂性"></a>3). 计算复杂性</h4><p>使用前小节中的程序，作者尝试计算了n &#x3D; 5 … 12汉诺塔问题的移盘过程，得到下述移盘次数。</p>
<table>
<thead>
<tr>
<th>盘数</th>
<th>所需移盘次数</th>
<th>评论</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>31</td>
<td>25-1</td>
</tr>
<tr>
<td>6</td>
<td>63</td>
<td>26-1</td>
</tr>
<tr>
<td>7</td>
<td>127</td>
<td>27-1</td>
</tr>
<tr>
<td>8</td>
<td>255</td>
<td>28-1</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>4095</td>
<td>212-1</td>
</tr>
</tbody></table>
<p>看起来，似乎n个盘的汉诺塔问题的移盘次数为2n-1。事实上，对移盘次数的数学分析可以证明这个结论。n盘的汉诺塔求解可以拆分成两个n-1盘的汉诺塔求解再加上1次简单移盘。如果用T(n)来表示n盘汉诺塔的移盘次数的话，函数T(n)可使用下述递归定义。<br>T(n)&#x3D;{1n&#x3D;1\2T(n−1)+1n&gt;1T(n)&#x3D;{1n&#x3D;1\2T(n−1)+1n&gt;1<br>​</p>
<p>我们试着把递归函数消解成非递归函数。<br>T(n)&#x3D;2T(n−1)+1 &#x3D;2(2T(n−2)+1)+1&#x3D;4T(n−2)+2+1&#x3D;22T(n−2)+21+20 &#x3D;22(2T(n−3)+1)+21+20&#x3D;23T(n−3)+22+21+20 &#x3D;… &#x3D;2tT(n−t)+2t−1+2t−2+…+21+20 T(n)&#x3D;2T(n−1)+1 &#x3D;2(2T(n−2)+1)+1&#x3D;4T(n−2)+2+1&#x3D;22T(n−2)+21+20 &#x3D;22(2T(n−3)+1)+21+20&#x3D;23T(n−3)+22+21+20 &#x3D;… &#x3D;2tT(n−t)+2t−1+2t−2+…+21+20<br>令t &#x3D; n - 1，有：<br>T(n)&#x3D;2n−1T(1)+2n−2+2n−3+…+21+20 &#x3D;n−1∑t&#x3D;02t&amp;&#x3D;2n−1T(n)&#x3D;2n−1T(1)+2n−2+2n−3+…+21+20 &#x3D;∑t&#x3D;0n−12t&amp;&#x3D;2n−1<br>故n盘汉诺塔共需移盘2n-1次。那么，如果梵天规定的是64个金盘的话，总移动次数则为264-1 &#x3D; 18446744073709551615。如果婆罗门僧侣是个熟练工，1秒挪一个盘，那么1小时可以移3600个盘，1年可移3600 x 24 x 365 &#x3D; 31536000个盘(忽略闰年误差）。那么，解64盘汉诺塔问题共需要(264-1)&#x2F;31536000年，即大约5949亿年。看起来，按照当前的人类知识，印度的古老智慧好像高估了地球的预期寿命。</p>
<p>读者不要去尝试计算hanoi(64,”A”,”B”,”C”)，显然，在你有限的人生里，是无法完成这件接近“无限”的大事的。而且，因为递归所导致的内存消耗，你有限的计算机内存也排除了这种可能性。</p>
<p>作者是无神论者，上述探讨基于严谨的数学，作者不相信任何人格化的“上帝 ”。</p>
<h3 id="7-7-函数指针"><a href="#7-7-函数指针" class="headerlink" title="7.7 函数指针"></a>7.7 函数指针</h3><p>指针可以指向变量&#x2F;常量等对象，也可以指向函数。指向函数的指针称为<strong>函数指针（function pointer）</strong>。应用程序开始执行前，其二进制代码会被操作系统调入内存。作为程序的一部分，函数当然也占据内存并拥有内存地址，该地址可以被赋值给函数指针。请阅读下述C语言代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - FuncPointer</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int add(int a, short b)&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float f = 3.3F;</span><br><span class="line">    int c = 33;</span><br><span class="line">    printf(&quot;add = %p,  &amp;f = %p, &amp;c = %p\n&quot;, add, &amp;f, &amp;c);</span><br><span class="line"></span><br><span class="line">    int (*pf)(int, short) = NULL;</span><br><span class="line">    pf = add;</span><br><span class="line">    printf(&quot;pf = %p,  &amp;pf = %p\n&quot;, pf, &amp;pf);</span><br><span class="line"></span><br><span class="line">    int d = pf(3,2);</span><br><span class="line">    printf(&quot;3+2 = %d&quot;, d);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = 0000000000401560,  &amp;f = 000000000061FE18, &amp;c = 000000000061FE14</span><br><span class="line">pf = 0000000000401560,  &amp;pf = 000000000061FE08</span><br><span class="line">3+2 = 5</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<p><img src="http://codelearn.club/images/image-20200229144811591.png" alt="image-20200229144811591"></p>
<p>图7- 函数与数据的内布分区</p>
<p>根据上述程序的执行结果，我们画出了本例中相关对象在作者计算机上的内存分布局7- 。 从该图中，我们可以看到，操作系统对代码（程序）和数据进行了分区管理，分为代码存储区以及数据存储区。一般地，操作系统和计算机的安全机制会禁止在程序运行过程中修改代码存储区的内容，这块区域是只读的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;add = %p,  &amp;f = %p, &amp;c = %p\n&quot;, add, &amp;f, &amp;c);</span><br></pre></td></tr></table></figure>

<p>第11行：将函数名add按地址格式输出；输出局部变量f、c的地址。从执行结果的第1行可见，函数名add即为相关执行代码在“代码存储区”中的内存地址。add的地址与局部变量f，c的地址相差甚远，提示它们应该不在同一块内存区域。f和c的地址则相差不多，它们都位于数据存储区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*pf)(int, short) = NULL;</span><br></pre></td></tr></table></figure>

<p>第13行：定义了指向函数的指针变量，变量名为pf，并将该指针初始化为空指针。下面给出了函数指针定义的一般格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数返回值类型 (*函数指针名)(形参0的类型,形参1的类型, ... ,形参n的类型)</span><br></pre></td></tr></table></figure>

<p>从该格式可以看出，一个函数指针的定义需要包含如下信息：</p>
<ul>
<li>所指向的函数的返回值类型；</li>
<li>函数指针变量的名称；</li>
<li>所指向函数的形参个数、顺序及类型。</li>
</ul>
<p>在上述格式中，包裹”*函数指针名”的括号必不可少。第13行中的函数指针定义如果去掉括号，就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *pf(int, short)</span><br></pre></td></tr></table></figure>

<p>这对于编译器而言，还可以解释为：一个名为pf的函数，该函数接受int, short两个形参，返回一个int*对象。为了确保编译器将pf理解为指向函数的指针，而不是函数名，上述括号是必不可少。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pf = add;</span><br></pre></td></tr></table></figure>

<p>第14行：将add( )函数的地址赋值给函数指针变量pf。赋值完成后，pf指针指向add( )函数。请读者注意，这个赋值操作能够进行的前提是pf与add拥有相同的类型。add是函数名，即函数的地址，add( )函数接受一个int和一个short形参，返回一个int对象，这些事项均与pf的定义一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;pf = %p,  &amp;pf = %p\n&quot;, pf, &amp;pf);</span><br></pre></td></tr></table></figure>

<p>第15行：pf是个函数指针，同时也是一个局部变量，它存储在数据存储区并拥有地址。从执行结果的第2行可见，pf的值即为add( )函数的地址，pf对象自身存储在数据存储区，其地址与另外两个局部变量c，f很近。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int d = pf(3,2);</span><br><span class="line">printf(&quot;3+2 = %d&quot;, d);</span><br></pre></td></tr></table></figure>

<p>第17 ~ 18行：以函数指针pf为基础，调用执行add( )函数，并将结果赋值给变量d，然后打印出来。执行结果的第3行可见，d值为5，通过函数指针pf，add( )函数正确执行。</p>
<p>比较令人烧脑的是，对于C&#x2F;C++语言而言，下述两种通过函数指针pf调用add( )函数的方法正是正确的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int d = pf(3,2);</span><br><span class="line">int e = (*pf)(3,2);</span><br></pre></td></tr></table></figure>

<p>前者认为，pf是一个函数地址，函数名add事实上也是函数地址，所以pf也可以视为函数名。后者认为，pf是一个指向函数的指针，*pf才代表它所指向的函数。两者都有道理，较新的C&#x2F;C++标准同时接受两种用法。</p>
<p>为了简要演示函数指针的应用，我们“创造”了下述问题。在一个string类型的数组里，存储了多个国家的英文名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string names[] &#123;&quot;China&quot;, &quot;United States&quot;, &quot;Russia&quot;, &quot;Afghanistan&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>现要求使用下述两种方法对这些国家名称进行非递减排序：</p>
<ul>
<li>按字母表顺序；</li>
<li>按国名长度，即国名中包含的字符个数排序。</li>
</ul>
<p>在微实践 - 冒泡排序里，我们设计了bubbleSort( )函数。要实现两种不同的排序策略，最直接的办法当然是设计两个版本的bubbleSort( )函数来完成，但这样做会增加工作量以及代码冗余。另外一种解决方案是把两种不种的排序策略设计为两个不同的比较函数，然后把比较函数作为函数指针传递给bubbleSort( )函数。在bubbleSort( )函数内部进行排序时，使用传入的函数指针来调用相应的比较函数来进行元素比较。相应的C++程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Project - FuncPointer2</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void bubbleSort(string a[],const int n,bool (*bigger)(const string&amp;, const string&amp;))&#123;</span><br><span class="line">    for (int i=n-1;i&gt;0;i--)</span><br><span class="line">        for (int j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if (bigger(a[j],a[j+1]))&#123;</span><br><span class="line">                auto t = a[j];</span><br><span class="line">                a[j] = a[j+1];</span><br><span class="line">                a[j+1] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool biggerThan1(const string&amp; a, const string&amp; b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool biggerThan2(const string&amp; a, const string&amp; b)&#123;</span><br><span class="line">    return a.size() &gt; b.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string names[] &#123;&quot;China&quot;, &quot;United States&quot;, &quot;Russia&quot;, &quot;Afghanistan&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    bubbleSort(names, 4, biggerThan1);</span><br><span class="line">    cout &lt;&lt; &quot;sorted1: &quot; &lt;&lt; names[0] &lt;&lt; &quot;, &quot; &lt;&lt; names[1]</span><br><span class="line">         &lt;&lt; &quot;, &quot; &lt;&lt; names[2] &lt;&lt; &quot;, &quot; &lt;&lt; names[3] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    auto pf = biggerThan2;</span><br><span class="line">    bubbleSort(names, 4, pf);</span><br><span class="line">    cout &lt;&lt; &quot;sorted2: &quot; &lt;&lt; names[0] &lt;&lt; &quot;, &quot; &lt;&lt; names[1]</span><br><span class="line">         &lt;&lt; &quot;, &quot; &lt;&lt; names[2] &lt;&lt; &quot;, &quot; &lt;&lt; names[3] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sorted1: Afghanistan, China, Russia, United States</span><br><span class="line">sorted2: China, Russia, Afghanistan, United States</span><br><span class="line">bool biggerThan1(const string&amp; a, const string&amp; b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第17 ~ 19行：biggerThan1( )函数返回表达式a &gt; b的值，a、b字符串的这种比较是以字母表顺序为依据的。按这种比较方式，“China” &gt; “Afghanistan”，因为在字母表中，C排在A之后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool biggerThan2(const string&amp; a, const string&amp; b)&#123;</span><br><span class="line">    return a.size() &gt; b.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第21 ~ 23行：biggerThan2( )函数返回表达式a.size( ) &gt; b.size( )的值。其中，size( )成员函数返回字符串内的字符个数。按照这种比较方式，”Afghanistan” &gt; “China”，因为前者有11个字符，后者只有5个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(string a[], const int n, bool (*bigger)(const string&amp;, const string&amp;))</span><br></pre></td></tr></table></figure>

<p>第6行：改进后的bubbleSort( )函数多了一个形式参数bigger，其类型为函数指针，其指向的函数接受两个string作为参数，返回一个bool。显然，bigger的类型与biggerThan1( )、biggerThan2( )函数一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (bigger(a[j],a[j+1]))&#123;</span><br></pre></td></tr></table></figure>

<p>第9行：冒泡排序循环中，通过函数指针bigger调用指定的比较函数对a[j]和a[j+1]进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bubbleSort(names, 4, biggerThan1);</span><br><span class="line">cout &lt;&lt; &quot;sorted1: &quot; &lt;&lt; names[0] &lt;&lt; &quot;, &quot; &lt;&lt; names[1]</span><br><span class="line">     &lt;&lt; &quot;, &quot; &lt;&lt; names[2] &lt;&lt; &quot;, &quot; &lt;&lt; names[3] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第28 ~ 30行：执行bubbleSort( )函数对names数组进行排序，将biggerThan1( )函数传入作为比较函数。从执行结果的第1行可见，names确实按照字母表顺序进行了排序，Afghanistan（阿富汗）排在China之前。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto pf = biggerThan2;</span><br></pre></td></tr></table></figure>

<p>第32行：当把函数名赋值给一个函数指针时，必须确保函数指针的类型与函数相同。<strong>【C++ 11】</strong>的auto类型推导可以帮助我们省去描述函数指针类型的麻烦，在C++ 11及其以上版本的编译器下，pf的类型将被推断为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (*)(string[ ], const int, bool (*)(const string&amp;, const string&amp;))</span><br><span class="line">bubbleSort(names, 4, pf);</span><br><span class="line">cout &lt;&lt; &quot;sorted2: &quot; &lt;&lt; names[0] &lt;&lt; &quot;, &quot; &lt;&lt; names[1]</span><br><span class="line">     &lt;&lt; &quot;, &quot; &lt;&lt; names[2] &lt;&lt; &quot;, &quot; &lt;&lt; names[3] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第33 ~ 35行：将pf函数指针传给bubbleSort( )进行排序。由于pf指向biggerThan2( )函数，所以bubbleSort( )函数内的元素比较事实上执行biggerThan2( )函数，即按字符串长度排序。从执行结果的第2行可见，names确实按照字符串长度进行了排序，Afghanistan字符数多，排在China和Russia之后。</p>
<p>作者在第32行引入pf指针完全是为了说明auto类型推断在函数指针定义中的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool (*pfarray[2])(const string&amp;, const string&amp;);</span><br><span class="line">pfarray[0] = biggerThan1;</span><br><span class="line">pfarray[1] = biggerThan2;</span><br><span class="line">pfarray[0](&quot;China&quot;,&quot;India&quot;);</span><br></pre></td></tr></table></figure>

<p>进一步，上述代码的第1行定义了一个函数指针数组pfarray，该数组有2个元素，元素类型为bool (*)(const string&amp;, const string&amp;)。第2行及第3行则将biggerThan1( )及biggerThan2( )函数名赋值给数组元素。第4行则通过pfarray[0]对biggerThan1( )函数进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef bool (*biggerFunc)(const string&amp;, const string&amp;);</span><br><span class="line">biggerFunc pfarray2[2];</span><br><span class="line">pfarray2[0] = biggerThan1;</span><br><span class="line">pfarray2[1] = biggerThan2;</span><br></pre></td></tr></table></figure>

<p>通过typedef（类型定义）▲语句可以帮助我们简化函数指针的定义和使用过程。上述代码的第1行将biggerFunc定义为一个类型，该类型的具体内容为bool (*)(const string&amp;, const string&amp;)。第2行则使用biggerFunc类型来定义函数指针数组。这里的函数指针数组pfarray2跟前述pfarray完全等价。</p>
<blockquote>
<p>提示：如果作者愿意，还可以花上几十页写出更加复杂的函数指针的语法和示例，但这不值得。在程序设计过程中，应该尽可能使用简单的语法和易于理解的算法，尽量避免诸如上述函数指针数组等复杂特性的使用。高质量代码的一个重要特性，就是简单和易于理解（代码可读性）。</p>
</blockquote>
<h3 id="7-8-默认值参数"><a href="#7-8-默认值参数" class="headerlink" title="7.8 默认值参数"></a>7.8 默认值参数</h3><p><strong>【C++】</strong>里，可以为函数的形式参数指定默认值。请阅读下述C++代码，并注意其中add( )函数的形式参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - DefaultParameter</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int add(int a, int b, int c = 0, int d = 0)&#123;</span><br><span class="line">    return a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;1+2 = &quot; &lt;&lt; add(1,2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;1+2+3 = &quot; &lt;&lt; add(1,2,3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;1+2+3+4 = &quot; &lt;&lt; add(1,2,3,4) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1+2 = 3</span><br><span class="line">1+2+3 = 6</span><br><span class="line">1+2+3+4 = 10</span><br><span class="line">int add(int a, int b, int c = 0, int d = 0)&#123;</span><br></pre></td></tr></table></figure>

<p>第5行：区别于之前的函数定义，add( )函数的形参中，最后两个c和d给出了默认值0。这种方式给函数的使用者带来极大方便，当调用函数时，如果提供的实参数量不足，编译器会尝试对形参使用默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;1+2 = &quot; &lt;&lt; add(1,2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第10行：add(1,2)只提供了两个实参，a取1，b取2，c和d取默认值0。在函数的使用者看来，这次函数调用是把1和2两个数相加，其结果为3。而在编译器看来，这次函数调用本质上是把1，2，0，0共4个数相加，结果为3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;1+2+3 = &quot; &lt;&lt; add(1,2,3) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第11行：add(1,2,3)只提供了3个实参，a取1、b取2、c取3、d取默认值0。在函数的使用者看来，这次函数调用是把1、2和3共3个数相加，其结果为6。而在编译器看来，这次函数调用本质上是把1，2，3，0共4个数相加，结果为6。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;1+2+3+4 = &quot; &lt;&lt; add(1,2,3,4) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第12行：add(1,2,3,4)提供了4个实参，a取1、b取2、c取3、d取4。无论从使用者视角，还是编译器视角，都是把1，2，3，4共4个数相加，结果为10。</p>
<p>如果程序中既出现了函数的原型，又出现了函数的定义，则只允许在原型或者定义中提供形参的默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int add(int a, int b, int c = 0, int d = 0); //函数原型</span><br><span class="line"></span><br><span class="line">int add(int a, int b, int c, int d = 0)&#123; //函数定义</span><br><span class="line">    return a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序会编译出错，因为add( )函数的原型和定义中同时给出了形参默认值。作者建议尽量在函数原型中给出形参默认值，因为对于使用者而言，原型是函数的<strong>接口（interface）</strong>▲，在接口中展示形参默认值有助于使用者更好地掌握函数的使用方法。</p>
<p>为函数提供的形参默认值只能提供给形参列表的最后N个。请看下述函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f1(int a, int b = -1, float c = 0);   //合法</span><br><span class="line">double f2(float a, bool b = true, char c); //非法, b有默认值，则c也必须有</span><br><span class="line">bool f3(char a = &#x27;k&#x27;, int b = 22, bool c = false); //合法</span><br></pre></td></tr></table></figure>

<p>之所以作出如上规定，是为了避免编译器在将实际参数分配给形式参数时产生歧义。</p>
<h3 id="7-9-内联函数"><a href="#7-9-内联函数" class="headerlink" title="7.9 内联函数"></a>7.9 内联函数</h3><p>函数调用需要花费额外的CPU及内存资源：</p>
<ul>
<li>为函数的形参分配内存空间，向函数传递参数；</li>
<li>跳转至函数体；</li>
<li>从函数体跳转回调用点；</li>
<li>获取函数的返回值。</li>
</ul>
<p><img src="http://codelearn.club/images/image-20200301142157044.png" alt="image-20200301142157044"></p>
<p>图7- 非内联函数调用流程图</p>
<p>图7- 展示了一个非内联的普通函数average( )被多次调用时的执行流程：</p>
<ul>
<li>average( )函数编译后的二进制执行代码在可执行文件只有一个副本；</li>
<li>main( )函数多次调用执行average( )函数，每次执行，都会在传参后跳转至average( )函数在内存中的唯一副本处执行，再返回。</li>
</ul>
<p>每次函数调用，都意味着额外的CPU及内存开销。将函数<strong>内联（inline）</strong>是避免上述函数调用开销的办法之一。C99标准规定内联函数必须具有内部链接▲且其定义并必须与调用该函数的代码处于同一个文件中。因此，C语言中定义一个内联函数最简单方法是在函数头前加上inline static。inline关键字是内联的意思，static则表示存储类别▲。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - MultiCall</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">inline static float average(float* a, int n) &#123;</span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (int i=0;i&lt;n;i++)</span><br><span class="line">        fSum += a[i];</span><br><span class="line">    return fSum/n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float values[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line"></span><br><span class="line">    float v4 = average(values,4);</span><br><span class="line">    printf(&quot;v4 = %f\n&quot;,v4);</span><br><span class="line"></span><br><span class="line">    float v7 = average(values,7);</span><br><span class="line">    printf(&quot;v7 = %f\n&quot;,v7);</span><br><span class="line"></span><br><span class="line">    float v10 = average(values,10);</span><br><span class="line">    printf(&quot;v10 = %f\n&quot;,v10);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v4 = 1.500000</span><br><span class="line">v7 = 3.000000</span><br><span class="line">v10 = 4.500000</span><br></pre></td></tr></table></figure>

<p>上述代码中，main( )函数三次调用average( )函数，用于计算values数组前4个、前7个以及前10个元素的平均数。由于average( )函数被定义为<strong>内联函数（inline static function）</strong>，所以编译器会在average( )函数的调用点将该函数就地展开，以空间换时间：</p>
<ul>
<li>如图7- 所示，函数展开后，average( )的函数体代码将在最终的可执行文件中出现三个副本，增加了存储空间。</li>
<li>内联函数展开后，函数调用的跳转被消除，节省了执行时间。</li>
</ul>
<p><img src="http://codelearn.club/images/image-20200301152758979.png" alt="image-20200301152758979"></p>
<p>图7- 内联函数的展开</p>
<p>说明：因为编译器优化的存在，实际函数展开结果会与图7- 有差异。</p>
<p>为了帮助读者理解在何种情况下应该使用内联函数，我们设计了如下C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - InlineExample</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//将无符号整数v的第bit位设置为1</span><br><span class="line">inline void setBit(unsigned int&amp; v,  int bit)&#123;</span><br><span class="line">    v |= (0x01 &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int v = 0x00000000;</span><br><span class="line">    cout &lt;&lt; &quot;before setBit: &quot; &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    setBit(v,0);</span><br><span class="line">    setBit(v,31);</span><br><span class="line">    v |= (0x01 &lt;&lt; 11);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;after setBit:  &quot; &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before setBit: 00000000000000000000000000000000</span><br><span class="line">after setBit:  10000000000000000000100000000001</span><br></pre></td></tr></table></figure>

<p>一个无符号整数由4个字节共32个比特构成。C&#x2F;C++提供按位操作符允许我们直接对变量的比特位▲进行操作。setBit(v,bit)函数用于将无符号整数v的第bit位设置为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline void setBit(unsigned int&amp; v,  int bit)&#123;</span><br><span class="line">    v |= (0x01 &lt;&lt; bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7 ~ 9行：定义了内联函数setBit( )。与C语言不同，C++中仅需在函数声明或者定义前加上inline关键字即可将函数设定为内联函数。第8行代码通过按位操作符将v的第bit位设置为1，按位操作的工作原理及语法细节在本书第x章中讨论。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int v = 0x00000000;</span><br><span class="line">cout &lt;&lt; &quot;before setBit: &quot; &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：定义了初如值为0的无符号整数v，通过bitset类型将其按二进制格式输出。bitset类型由bitset头文件引入，其语法及工作原理在本书第x章中讨论。执行结果的第1行可见，setBit( )函数执行前，v的32个比特全为0（高位在前，低位在后）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setBit(v,0);</span><br><span class="line">setBit(v,31);</span><br><span class="line">v |= (0x01 &lt;&lt; 11);</span><br></pre></td></tr></table></figure>

<p>第15 ~ 17行：调用setBit( )函数两次将v的第0位（最低位），第31位（最高位）设为1。第17行则直接使用按位操作符将v的第11位设置为1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;after setBit:  &quot; &lt;&lt; bitset&lt;32&gt;(v) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第19行：按二进制格式输出第0位、第11位、第31位置1后的v值。执行结果的第2行可见，上述置1操作成功执行。</p>
<p>既然直接使用按位操作符（如第17行）可以达到目的，那为何要定义setBit( )函数呢？引用setBit( )函数这种似乎不必要的函数的唯一目的是增强代码的可读性。对于代码的阅读者而言，setBit( )函数更容易理解和使用。但如果setBit( )是个普通函数，其引入也带来了负面效应：函数参数传递、跳转的额外开销。通过将setBit( )设置为内联函数则可以兼得鱼和熊掌：既增加了代码的可读性，又避免了因函数引入开来的额外开销。</p>
<p><strong>将一个函数定义为内联函数并不能保证编译器将函数内联</strong>。至少在下述两种情况下，编译器会选择忽视inline关键字，不内联函数：</p>
<ul>
<li>函数过于冗长和复杂。这也通常意味着相对于函数体本身的执行代价，与函数调用有关的额外开销无足轻重，将函数内联的价值很小。</li>
<li>递归函数。递归函数调用是无法展开的，其中一个理由是递归函数的递归次数在编译时无法确定。</li>
</ul>
<h3 id="7-10-函数名重载"><a href="#7-10-函数名重载" class="headerlink" title="7.10 函数名重载"></a>7.10 函数名重载</h3><p>在C语言里，同一个程序中的函数名必须互不相同。<strong>【C++】</strong>中的函数名重载（function overloading）允许多个函数使用相同的函数名，前提是每个函数的形参类型或顺序不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void swapFloat(float&amp; a, float&amp; b)&#123;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swapDouble(double&amp; a, double&amp; b)&#123;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对计算机而言，“交换两个float对象的值”与“交换两个double对象的值”是不一样的操作，需要的机器指令也不相同。这意味着，我们需要设计两个函数，分别完成交换float对象和交换double对象的任务。在“函数名不可重复”的要求下，我们不得不为两个函数取不同的名称，本例中，分别取名为swapFloat和swapDouble。但从函数使用者的角度看，这会带来一些不便：根据不同的参数类型去选择“不同”的函数，带来额外的记忆与使用成本。</p>
<p>借助于C++的函数名重载，我们可以给多个函数取相同的函数名。下述C++程序使用了上述交换函数的函数名重载版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Project - FuncOverloading1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swapObject(float&amp; a, float&amp; b)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;swapObject_float,a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swapObject(double&amp; a, double&amp; b)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;swapObject_double,a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double d1 &#123;1.1&#125;, d2&#123;9.9&#125;;</span><br><span class="line">    swapObject(d1,d2);</span><br><span class="line">    cout &lt;&lt; &quot;d1 = &quot; &lt;&lt; d1 &lt;&lt; &quot;, d2 = &quot; &lt;&lt; d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    float f1 &#123;2.2&#125;, f2 &#123;8.8&#125;;</span><br><span class="line">    swapObject(f1,f2);</span><br><span class="line">    cout &lt;&lt; &quot;f1 = &quot; &lt;&lt; f1 &lt;&lt; &quot;, f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swapObject_double,a=1.1,b=9.9</span><br><span class="line">d1 = 9.9, d2 = 1.1</span><br><span class="line">swapObject_float,a=2.2,b=8.8</span><br><span class="line">f1 = 8.8, f2 = 2.2</span><br></pre></td></tr></table></figure>

<p>可以看到，两个交换函数现在具有完全相同的名称(swapObject)、返回值类型（void）、形参的名称和个数（a，b），唯一的区别是形参的类型不同，一个是double&amp;，一个是float&amp;。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d1 &#123;1.1&#125;, d2&#123;9.9&#125;;</span><br><span class="line">swapObject(d1,d2);</span><br><span class="line">cout &lt;&lt; &quot;d1 = &quot; &lt;&lt; d1 &lt;&lt; &quot;, d2 = &quot; &lt;&lt; d2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第20 ~ 22行：将double类型的d1和d2作为实参调用执行swapObject( )函数，从执行结果的第1，2行可见，编译器依据实参d1，d2的类型选择执行了函数swapObject(double&amp;, double&amp;)，d1和d2成功交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float f1 &#123;2.2&#125;, f2 &#123;8.8&#125;;</span><br><span class="line">swapObject(f1,f2);</span><br><span class="line">cout &lt;&lt; &quot;f1 = &quot; &lt;&lt; f1 &lt;&lt; &quot;, f2 = &quot; &lt;&lt; f2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第24 ~ 26行：将float类型的f1和f2作为实参调用执行swapObject( )函数，从执行结果的第3，4行可见，编译器依据实参f1，f2的类型选择执行了函数swapObject(float&amp;, float&amp;)，f1和f2成功交换。</p>
<p>从本例可知：当函数调用时，如果存在多于一个的同名函数，C++编译器会试图通过实参的类型去匹配并选择正确的函数。在函数使用者的视角，可以认为只有一个名为swapObject的函数，它既可以交换float，也可以交换double。在编译器看来，事实上有两个交换函数，一个用于交换float，一个用于交换double，只是这两个函数恰好同名而已。</p>
<blockquote>
<p>名字装饰：编译器通过一种叫做名字装饰（name decoration）的技术来区分两个同名的swapObject函数。该技术通过把形参的类型附加在函数名的后面来得到不同的内部函数名。比如，本例中的函数名可能被修饰为swapObject_Rf_Rf和swapObject_Rd_Rd，其中的Rf和Rd分别表示float的引用（<strong>R</strong>eference of <strong>f</strong>loat）及double的引用。不同的编译器会使用不同的符号来对函数名进行装饰，装饰后的函数名事实上仅用于编译器内部，程序员通常不用关心具体的装饰名是什么。</p>
</blockquote>
<p>函数名重载只能依赖于形参的个数、类型及顺序，不能依赖于返回值类型。因为函数调用时，使用者可以选择不接收函数的返回值，这种情况下，编译器无法区分仅返回值类型不同的同名函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int  f1(int a,   float b, char c);</span><br><span class="line">int  f1(float a, int b,   char c);</span><br><span class="line">char f1(char a,  int b);</span><br><span class="line">//void f1(int a, float b, char c); //错误：函数名重载不能依赖于返回值类型</span><br></pre></td></tr></table></figure>

<p>上述名为f1的函数中，第2行的f1形参的类型顺序与其它f1函数不同，合法。第3行的f1形参的个数与其它f1函数不同，也合法。第4行的f1其形参个数、类型及顺序与第1行的f1函数相同，仅返回值类型不同，不合法。</p>
<h3 id="7-11-模板函数"><a href="#7-11-模板函数" class="headerlink" title="7.11 模板函数"></a>7.11 模板函数</h3><p>还是考虑用于交换两个同类型对象的swapObject( )函数，我们已经为double和float两种类型设计了两个版本的同名函数，还有char、string、long long、int等多种类型的版本等待我们的实现。这显然是个坏主意！</p>
<p>借助于函数模板，我们可以设计一个通用的swapObject( )函数，适用于“所有“的数据类型。请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - TemplateSwap</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void swapObject(T&amp; a, T&amp; b)&#123;</span><br><span class="line">    auto t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char c1 &#123;&#x27;a&#x27;&#125;, c2 &#123;&#x27;z&#x27;&#125;;</span><br><span class="line">    swapObject(c1,c2);</span><br><span class="line">    cout &lt;&lt; &quot;c1 = &quot; &lt;&lt; c1 &lt;&lt; &quot;, c2 = &quot; &lt;&lt; c2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    double d1&#123;1.1&#125;, d2&#123;9.9&#125;;</span><br><span class="line">    swapObject(d1,d2);</span><br><span class="line">    cout &lt;&lt; &quot;d1 = &quot; &lt;&lt; d1 &lt;&lt; &quot;, d2 = &quot; &lt;&lt; d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    short s1&#123;-22&#125;, s2&#123;22&#125;;</span><br><span class="line">    swapObject&lt;short&gt;(s1,s2);</span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; &quot;, s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 = z, c2 = a</span><br><span class="line">d1 = 9.9, d2 = 1.1</span><br><span class="line">s1 = 22, s2 = -22</span><br></pre></td></tr></table></figure>

<p>第5 ~ 10行：swapObject( )函数的定义过程中，将形参的引用类型T抽象为一个模板参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c1 &#123;&#x27;a&#x27;&#125;, c2 &#123;&#x27;z&#x27;&#125;;</span><br><span class="line">swapObject(c1,c2);</span><br></pre></td></tr></table></figure>

<p>第13 ~ 14行：当提供两个char类型的实参给swapObject( )函数，聪明的编译器会用char类型替换模板参数T，“内部生成”swapObject(char&amp;, char&amp;)函数并使用之。</p>
<p>第17 ~ 18行：当提供两个double类型的实参给swapObject( )函数，编译器会在“内部”生成swapObject(double&amp;, double&amp;)函数并使用之。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">short s1&#123;-22&#125;, s2&#123;22&#125;;</span><br><span class="line">swapObject&lt;short&gt;(s1,s2);</span><br></pre></td></tr></table></figure>

<p>第20 ~ 21行：第21行尖括号内的short内显式地指定了模板参数T的值，要求编译器生成函数swapObject(short&amp;, short&amp;)并使用之。</p>
<p>当程序员试用调用执行一个函数时，编译器会“千方百计”地满足程序员的要求。比如，当函数要求一个int类型的传值参数，而实参是一个short对象时，编译器会进行类型提升，将short对象隐式类型转换为int对象并传值给函数。可以认为：只要编译器认为类型提升和转换不会带来风险，编译器会通过对实参进行类型提升或转换来尽可能满足函数形参的要求。</p>
<p>由于默认值参数、函数名重载、模板函数的使用，有些情况下，一行函数调用代码可能存在多个“合法”的候选函数。此时，编译器会选择最佳的可行函数来使用。显而易见，当多个“最佳”可行函数时，编译器会报错或者至少给出警告。实践中，程序员会尽量避免这种有歧义的函数调用发生。</p>
<h3 id="7-12-decltype声明类型"><a href="#7-12-decltype声明类型" class="headerlink" title="7.12 decltype声明类型**"></a>7.12 decltype声明类型**</h3><p><strong>【C++ 11】</strong>中的auto关键字可以通过变量的初始化值来推断确定变量的类型。decltype关键字<strong>【C++ 11】</strong>源于英文declare type（声明类型），它可以推断一个表达式的结果类型。decltype操作符的用法请见下述代码及其注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">float b = 1.1F;</span><br><span class="line"></span><br><span class="line">decltype(a+b) c;   //int + float结果为float， c被推断为float</span><br><span class="line">decltype(b*a) d;   //float * int结果为float， d被推断为float</span><br><span class="line">float&amp; e = b;      </span><br><span class="line">decltype(e) f = b; //e的类型为float&amp;，f被推断为float&amp;</span><br></pre></td></tr></table></figure>

<p>其中，第7行的f被推断为float&amp;，编译器会要求程序员对引用f进行初始化，即它必须与一个float对象相关联。</p>
<p>为了讨论decltype的应用场景，请读者阅读下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">decltype(a+b) add(T1&amp; a, T2&amp; b)&#123;   //错误：a,b的声明在decltype(a+b)之后</span><br><span class="line">    auto c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板函数add( )试图将T1类型的a和T2类型的b相加，其结果类型既可能是T1，也可能是T2，甚至可能是其它类型▲，因此，该模板函数试图通过decltype(a+b)来推断确定返回类型。看起来很合理，但对编译器而言，decltype(a+b)出现时，a，b尚未声明，不符合语法要求。为了解决这个问题，<strong>【C++ 11】</strong>引入了返回类型后置语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">auto add(T1&amp; a, T2&amp; b) -&gt; decltype(a+b)   //返回类型后置</span><br><span class="line">&#123;   </span><br><span class="line">    auto c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2行的auto起到占位的作用，箭头 -&gt; 后面的decltype(a+b)则后置定义了函数的返回值类型。</p>
<p>有点麻烦，对吗？ <strong>【C++ 17】</strong>对持此相同观点，它去除了这个麻烦。下述代码在C++ 17的编译器下可以正常工作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - DeclareType</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T1, typename T2&gt;</span><br><span class="line">auto add(T1&amp; a, T2&amp; b) // -&gt; decltype(a+b)在C++ 17中不再被需要</span><br><span class="line">&#123;</span><br><span class="line">    auto c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    float b = 1.1F;</span><br><span class="line"></span><br><span class="line">    auto c = add(a,b);</span><br><span class="line">    auto d = add&lt;float,int&gt;(b,a);</span><br><span class="line">    cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(c).name() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; &quot;, type = &quot; &lt;&lt; typeid(d).name() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = 2.1, type = f</span><br><span class="line">d = 2.1, type = f</span><br></pre></td></tr></table></figure>

<p>从执行结果可见，不论是int a + float b还是float b + int a，返回的结果都是float型，auto关键字正确推断了模板函数的返回值类型。</p>
<h3 id="7-13-不确定数量的参数"><a href="#7-13-不确定数量的参数" class="headerlink" title="7.13 不确定数量的参数"></a>7.13 不确定数量的参数</h3><p>【？缺 扩展阅读】</p>
<h2 id="8-内存模型"><a href="#8-内存模型" class="headerlink" title="8. 内存模型"></a>8. 内存模型</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>程序中的每一个对象都会占据内存空间。本章专门讨论不同类型对象的内存分配、管理及回收问题。</p>
<h3 id="8-1-stack栈"><a href="#8-1-stack栈" class="headerlink" title="8.1 stack栈"></a>8.1 stack栈</h3><p>到目前为止，本书示例代码中定义的变量都是自动变量（automatic variables）。比如下述程序中的a和f。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">float f = 1.2;</span><br></pre></td></tr></table></figure>

<p>所有对象都会占据内存空间，自动变量所占据的内存空间的分配与回收是由编译器负责的。而容纳这些自动变量的，是一种被称为<strong>堆栈（stack）</strong>，简称为<strong>栈</strong>的数据结构。据信本书的大部分读者都不具备操作系统、CPU体系结构方面的知识，因此我们只能以比较”形象“但<strong>很可能不够准确</strong>的方式来解释编译器是如何借助于栈来管理自动变量的。</p>
<p>应用程序的栈空间是由操作系统分配的”固定“的有限大小的内存空间，如图8- 所示，这个栈空间是由<strong>栈底</strong>开始的一段连续的内存。在多数计算机上，栈空间由高地址的栈底向低地址方向生长。除了栈底之外，编译器还会保存一个叫做<strong>栈顶指针（stack pointer）</strong>的地址，从栈底一直到栈顶指针之间的区域，表示已经被分配利用的栈空间（网格状区域），栈顶指针之下的空白区域，则表示尚未利用的栈空间。</p>
<p><img src="http://codelearn.club/images/image-20200305153303719.png" alt="image-20200305153303719"></p>
<p>图8- 栈</p>
<p>我们结合图8- 来理解下述伪代码执行过程中的栈空间利用行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void func(int b1, float b2, double b3)&#123;</span><br><span class="line">    double b4 = b1 * b2 + b3;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a1 = 1;</span><br><span class="line">    float a2 = 2.1F;</span><br><span class="line">    func(a1,a2,15.7);</span><br><span class="line">    //...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7 ~ 8行：编译器为自动变量a1，a2分配内存，它们存储在A区域，见图8- 函数调用前（1）。</p>
<p>第9行：调用执行函数func( )，函数的形参b1、b2、b3以及func( )内的局部变量b4都需要占据内存空间，所以编译器将栈顶指针下移，并将上述自动变量分配在B区域，见图8- 函数调用时（2）。需要说明的是，函数调用过程中还有一些额外的内存消耗，这些内存消耗也会使用图中B区域的空间。</p>
<p>第4行：当func( )函数执行结束时，其形参b1、b2、b3以及局部变量超出作用域范围。此时，编译器生成的机器指令将栈顶指针住上移，以回收栈空间。请参见图8- 函数调用返回后（3）。此时，B区域成为未利用的栈空间的一部分，可供后续程序使用。</p>
<p>不太严谨地，我们可以按如下方式总结C&#x2F;C++语言的自动变量的内存管理：当一个新的代码块（比如函数调用）存在新定义的自动变量时，编译器生成代码下移栈顶指针，将新定义的自动变量安排在新开发的栈区域内。因代码块执行结束导致局部的自动变量超出作用范围时，编译器生成代码上移栈顶指针，回收内存。整个程序的执行过程伴随着无数次的栈顶指针移动 &#x2F; 栈的生长和收缩。</p>
<p>我们通过执行下述C语言程序来“印证“上述理论的正确：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - StackExample2</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void dummy(int i, int j)&#123;</span><br><span class="line">    int k = i + j;</span><br><span class="line">    printf(&quot;---------------dummy-------------\n&quot;);</span><br><span class="line">    printf(&quot;&amp;i = %p, &amp;j = %p\n&quot;, &amp;i, &amp;j);</span><br><span class="line">    printf(&quot;&amp;k = %p, k = %d\n&quot;,&amp;k, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(int d, int e, int f)&#123;</span><br><span class="line">    int g = d + e;</span><br><span class="line">    int h = f;</span><br><span class="line">    printf(&quot;---------------add---------------\n&quot;);</span><br><span class="line">    printf(&quot;&amp;d = %p, &amp;e = %p, &amp;f = %p\n&quot;, &amp;d, &amp;e, &amp;f);</span><br><span class="line">    printf(&quot;&amp;g = %p, &amp;h = %p, sum = %d\n&quot;, &amp;g, &amp;h, g + h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a=1,b=1,c=1;</span><br><span class="line">    printf(&quot;&amp;a = %p, &amp;b = %p, &amp;c = %p\n&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    add(a,b,c);</span><br><span class="line">    dummy(a,b);</span><br><span class="line">    add(a,b,c);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;a = 000000000061FE1C, &amp;b = 000000000061FE18, &amp;c = 000000000061FE14</span><br><span class="line">---------------add---------------</span><br><span class="line">&amp;d = 000000000061FDF0, &amp;e = 000000000061FDF8, &amp;f = 000000000061FE00</span><br><span class="line">&amp;g = 000000000061FDDC, &amp;h = 000000000061FDD8, sum = 3</span><br><span class="line">---------------dummy-------------</span><br><span class="line">&amp;i = 000000000061FDF0, &amp;j = 000000000061FDF8</span><br><span class="line">&amp;k = 000000000061FDDC, k = 2</span><br><span class="line">---------------add---------------</span><br><span class="line">&amp;d = 000000000061FDF0, &amp;e = 000000000061FDF8, &amp;f = 000000000061FE00</span><br><span class="line">&amp;g = 000000000061FDDC, &amp;h = 000000000061FDD8, sum = 3</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<p>第20 ~ 21行：输出main( )函数内局部自动变量a，b，c的地址。从执行结果的第1行可见，它们的位于较高的地址，比较接近栈底。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(a,b,c);</span><br></pre></td></tr></table></figure>

<p>第22行：执行add( )函数。从执行结果的第2 ~ 4行可见，add( )的形参d、e、f及局部变量g、h的地址较a、b、c更小，这说明栈顶指针下移，d、e、f、g、h被分配在了新开辟的栈区域内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dummy(a,b);</span><br></pre></td></tr></table></figure>

<p>第23行：在add( )函数调用返回后执行dummy( )函数。从执行结果的第5 ~ 7行可见，dummy( )函数的形参i、j以及局部变量k被分配了与add( )函数形参及局部变量”几乎“相同的内存地址。这提示add( )函数返回时，编译器向上移动栈顶指针回收了内存，调用dummy( )函数时又再次下移栈顶指针，上述被回收的内存被再次利用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(a,b,c);</span><br></pre></td></tr></table></figure>

<p>第24行：在dummy( )函数调用返回后再次执行add( )函数。从执行结果的第8 ~ 10行可见，第二次add( )函数调用时，其内存分配情况与第一次add( )函数调用完全一致。这提示，编译器借助于栈，”完美“地处理了自动变量的内存分配和回收，坏账率为0，借出去多少，就收回来多少。</p>
<h3 id="8-2-heap堆"><a href="#8-2-heap堆" class="headerlink" title="8.2 heap堆"></a>8.2 heap堆</h3><p>操作系统分配给应用程序的栈空间是有限且”固定“的。在作者的计算机（Windows 10, Qt Creator 4.11.0, mingw 7.3.0 64 bit）上，下述C语言程序会因为栈空间溢出而不能正常运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Project - StackOverflow</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a[8000][100];  //如果在你的计算机上运行正常，那试着把100改成10000</span><br><span class="line">    printf(&quot;a[10][2] = %d, seems ok.&quot;,a[10][2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a数组的大小等于8000 x 100 x 4，大约等于3.2M字节的空间。这说明，自动变量不能存储大对象，如果我们需要在内存中保存巨量数据，还需要其它途径。这个其它途径就是<strong>堆（heap）</strong>。</p>
<p>堆也称为<strong>自由存储区（free store）</strong>，是由操作系统管理的公共内存区域。区别于栈，堆不属于任何应用程序。任何应用程序均可通过操作系统API（<strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface，应用程序编程接口）向操作系统申请指定大小的堆内的存储空间，在资源允许的情况下，操作系统会尽量满足应用程序的内存需求。应用程序在使用完申请的内存后，应主动通过操作系统API释放该内存，以便操作系统将其用于其它用途。</p>
<p>在第6章中，我们已经使用过C语言的malloc( )、calloc( )函数从操作系统申请内存，使用完后再通free( )函数释放。事实上，malloc( )、calloc( )函数所申请的内存就源自于堆。</p>
<h4 id="8-2-1-单个堆对象"><a href="#8-2-1-单个堆对象" class="headerlink" title="8.2.1 单个堆对象"></a>8.2.1 单个堆对象</h4><p>在C++语言中，我们通过new， delete操作符来申请和释放堆内存。请阅读下述C++语言示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//Project - NewDelete1</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int i = 3;</span><br><span class="line">    int* p = new int;</span><br><span class="line">    *p = 5;</span><br><span class="line"></span><br><span class="line">    printf(&quot;i = %d, &amp;i = %p\n&quot;, i, &amp;i);</span><br><span class="line">    printf(&quot;p = %p, &amp;p = %p, *p = %d\n&quot;, p, &amp;p, *p);</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    printf(&quot;p = %p&quot;, p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 3, &amp;i = 000000000061fe1c</span><br><span class="line">p = 00000000001d17a0, &amp;p = 000000000061fe10, *p = 5</span><br><span class="line">p = 00000000001d17a0</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* p = new int;</span><br></pre></td></tr></table></figure>

<p>第8行：new int通过操作系统API从堆里申请一个int，即4个字节的存储空间，并返回int*。通过指针赋值，指针p指向这块申请而得的堆内存。通过new操作符从堆里申请一个对象的存储空间的一般语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象类型 *指针名 = new 对象类型;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，需要妥善保管new操作符返回的指针，因为这是应用程序“拥有“这块内存的标志，也是应用程序操作这块内存的唯一途径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;i = %d, &amp;i = %p\n&quot;, i, &amp;i);</span><br><span class="line">printf(&quot;p = %p, &amp;p = %p, *p = %d\n&quot;, p, &amp;p, *p);</span><br></pre></td></tr></table></figure>

<p>第11 ~ 12行：打印局部变量i的值及地址；打印指针p的值和地址，以及p所指向的整数的值。从执行结果的第1~2行可见，p本身是一个自动变量，地址为0x0061fe10，它存储在栈里，与i紧挨着，i的地址为0x0061fe1c。如果观察p的值，也就是申请的内存块的地址，本例中为0x001d17a0，会发现申请的内存块不在栈中，它应该在堆里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete p;</span><br><span class="line">printf(&quot;p = %p&quot;, p);</span><br></pre></td></tr></table></figure>

<p>第14 ~ 15行：delete p用于释放p指针所指向的内存块。然后将p值按地址格式输出。</p>
<p>使用delete释放内容块有如下注意事项：</p>
<ul>
<li>delete只能用于释放通过new操作符申请的内存块，如果试图用delete释放指向栈对象的地址，会发生错误。</li>
<li>new操作符申请的内存块必须通过delete操作符进行释放，如果忘记释放，则在该应用程序退出前，操作系统会一直认为该块内存处于占用状态，无法将其用作其他用途。这种情况称之为<strong>内存泄漏（memory leakage）</strong>。</li>
<li>不能对同一块内存进行两次delete操作，其结果是不确定的。</li>
<li>delete一个空指针是安全而又无用的，什么都不会发生。</li>
</ul>
<p>第15行的输出结果告诉我们，delete p会释放p所指向的内存块，但并不会把指针p置为空指针。</p>
<blockquote>
<p><strong>要点🎯</strong> 当一个非空指针所指向的对象已经事实上被销毁时，该指针也称为<strong>悬空指针（dangling pointer）</strong>。</p>
</blockquote>
<p>一个悬空指针可能会在后续代码中被误用， 为了避免这种情况的发生，作者一般会在项目中定义如下的名为safe_delete的模板函数，来解决这个问题。请见下述C++代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - SafeDelete</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void safe_delete(T&amp; p)&#123;</span><br><span class="line">    delete p;</span><br><span class="line">    p = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    float* p = new float;</span><br><span class="line">    cout &lt;&lt; &quot;before safe_delete: &quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    safe_delete(p);</span><br><span class="line">    cout &lt;&lt; &quot;after safe_delete: &quot; &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before safe_delete: 0xe917a0</span><br><span class="line">after safe_delete: 0</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果第1行中的地址很可能与本书不同。</p>
<p>第6 ~ 9行：safe_delete( )函数接收一个指针的引用p，先使用delete p将p所指向的内存块释放，然后将p置为空指针。请注意，safe_delete( )函数的参数为T&amp;，这非常重要，因为该函数需要修改形参所关联的外部对象的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safe_delete(p);</span><br></pre></td></tr></table></figure>

<p>第14行：执行safe_delete( )函数，释放指针p所指向的内存块，并将p置为空指针（nullptr），以避免在后续代码中误用。 结合本行代码中p的类型float<em>，模板函数safe_delete( )形参p的类型为float</em>&amp;，即指向float对象的指针的引用。相应地，模板参数T的类型为float*。</p>
<p>执行结果证实，safe_delete(p)执行后，p成功被置为空指针。这种对p的delete更加安全可靠。同时，safe_delete( )函数的inline属性又避免了不必要的函数调用代价。</p>
<p>需要说明的是，上述new int， new float申请的内存块都是未经初始化的，即该int对象，float对象的值不确定。如果希望new出来的对象具有确定的初始值，可以使用下述形式的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* a = new int();             //初始化为0</span><br><span class="line">float* b = new float(0);        //初始化为0</span><br><span class="line">double* c = new double(3.3);    //初始化为3.3</span><br></pre></td></tr></table></figure>

<p>上述代码中的double(3.3)这种形式，可以认为是执行了double类型的构造函数▲，以3.3为构造函数的参数。</p>
<h4 id="8-2-2-堆对象数组"><a href="#8-2-2-堆对象数组" class="headerlink" title="8.2.2 堆对象数组"></a>8.2.2 堆对象数组</h4><p>new int可以申请一个int类型的堆对象，如果希望申请100个int类型的堆对象，则应使用下述形式的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int* a = new int[100];</span><br></pre></td></tr></table></figure>

<p>本行代码中的new int[100]可按下述方式理解：</p>
<ul>
<li>通过100 x sizeof(int)得到100个int对象占据400个字节的空间；</li>
<li>new操作符通过操作系统API从堆申请400个字节的空间，然后将该空间地址作为int*类型返回。</li>
</ul>
<p>new操作符返回的指针赋值给a之后，按照第6章的讨论，可以把a指针当数组用。下述C++代码演示了这种用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - NewMany</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n = 100;</span><br><span class="line">    int* a = new int[n];</span><br><span class="line">    int iSum &#123;0&#125;;</span><br><span class="line">    for (int i=0;i&lt;100;i++)&#123;</span><br><span class="line">        a[i] = i+1;</span><br><span class="line">        iSum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete []a;  //同delete[] a;</span><br><span class="line">    a = nullptr;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; iSum &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = 5050</span><br></pre></td></tr></table></figure>

<p>第6 ~ 7行：作者故意引入了变量n来表示需要期望的堆对象的个数。这是为了提醒读者，这个动态数组的元素个数并不需要在写代码的时刻确定，可以在运行时动态确定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete []a;  //同delete[] a;</span><br></pre></td></tr></table></figure>

<p>第14行：当指针a所指向的不是一个对象，而是由多个对象所构成的对象数组时，应该在delete与a之间加一个方括号。</p>
<blockquote>
<p><strong>警告🚩</strong> 当一个指针指向的不是单个动态对象，而是由多个动态对象所构成的数组时，<strong>必须</strong>使用delete [ ]操作符进行释放。当一个提针指向是单个动态对象时，则<strong>必须</strong>用delete操作符进行释放。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = nullptr;</span><br></pre></td></tr></table></figure>

<p>第15行：同样地，delete [] a执行后，a并不是空指针。此时将a设为空指针以避免后续代码误用。类似地，读者也可以自定义与前一小节相仿的模板函数safe_deletearray(T&amp; p)来实现”安全“的delete [ ]。</p>
<p>同样地，new int[100]所申请的内存是未经初始化的，如果期望申请的动态数组具有确定的初始值0，可以使用下述格式的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float* a = new float[10]();         //全部初始化为0</span><br><span class="line">int* b = new int[10]();             //全部初始化为0</span><br><span class="line">//double* c = new double[20](3.3);  //错误，括号内不能带参数</span><br></pre></td></tr></table></figure>

<p>无论是使用C语言的malloc( )、calloc( )，还是C++的new操作符，返回的内存都是由操作系统管理的堆内存。这种形式申请的内存，称为<strong>动态分配的内存（dynamic allocated memory）</strong>，这种内存应该在使用完毕以后尽快通过free( )或者delete、delete[ ]归还给操作系统。忘记归还，就会造成内存泄漏，影响整个计算机的运行甚至引发错误。在本书的后续章节，我们还会讨论一种称之为<strong>智能指针</strong>▲的对象，它可以有效地避免内存泄漏。</p>
<h3 id="8-3-静态对象"><a href="#8-3-静态对象" class="headerlink" title="8.3 静态对象"></a>8.3 静态对象</h3><p>自动变量&#x2F;对象的内存被分配在栈里，其生存周期从定义开始直到作用域结束，由编译器生成代码自动管理。动态对象的内存从堆中申请，其生存周期从new&#x2F;malloc&#x2F;calloc开始直至delete&#x2F;delete[ ]&#x2F;free操作被执行，由程序员手动管理。</p>
<p>不同于自动对象和动态对象，静态对象的生存周期从程序开始运行起，一直到程序运行结束，且被存储到一块称为“全局静态数据区”的内存空间内。</p>
<p>下述C语言代码定义了三种形式的静态变量&#x2F;对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int iGlobal = 11;               //能够在整个应用程序的所有源代码文件中使用</span><br><span class="line">static int iThisFileOnly = 22;  //只能在本文件中被使用</span><br><span class="line"></span><br><span class="line">void func()&#123;</span><br><span class="line">    static int iCounter = 0;    //只能在本函数中被使用</span><br><span class="line">    iCounter++;</span><br><span class="line">    printf(&quot;func called: %d, &amp;iCounter = %p\n&quot;, iCounter, &amp;iCounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，iGlobal定义在任何代码块（block）及函数外之外，它是静态对象的一种。相对于代码块或者函数内部的局部变量，习惯上我们称iGlobal这类变量为<strong>全局变量</strong>，它能够在整个应用程序的所有源代码文件上被使用。这种能够被外部源代码文件使用的性质，称为外部链接属性▲。</p>
<p>iThisFileOnly也定义在任何代码块及函数之外，但其类型前加了一个static关键字。这种类型的静态对象，只能在本源码文件中被使用。这种只能够被其所属于的源代码文件使用的性质，称为内部链接属性▲。</p>
<p>iCounter定义在函数代码块func( )之内，它既是一个静态对象，也是一个局部变量。作为静态对象，它具有全局生命周期；作为局部变量，它只能在func( )函数内被使用。我们稍后再讨论这种类型静态对象的神奇用处。</p>
<p><strong>所有类型的静态对象，如果在定义时不提供初始值，编译器会主动将其初始化为0</strong>。作者强烈建议，即便期望的初始值是0，也应在代码中给静态变量显式地给出初始值0，这样可以提高代码的可读性，避免阅读者疑惑。因为，大多数的代码阅读者，不会记得C&#x2F;C++标准中关于静态对象默认初始值为0的规定。</p>
<p><strong>静态对象的初始化赋值只会执行一次，即便该初始化赋值的代码位于函数体内。</strong>对于上述func( )函数内的static int iCounter &#x3D; 0，iCounter被赋值为0的操作只会发生一次，这项赋值操作是在程序最初启动时完成的。</p>
<p>下述完整的C语言代码可以更好地帮助读者理解静态对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - StaticObject</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int iGlobal = 11;               //能够在整个应用程序的所有源代码文件中使用</span><br><span class="line">static int iThisFileOnly = 22;  //只能在本文件中被使用</span><br><span class="line"></span><br><span class="line">void func()&#123;</span><br><span class="line">    static int iCounter = 0;    //只能在本函数中被使用</span><br><span class="line">    iCounter++;</span><br><span class="line">    printf(&quot;func called: %d, &amp;iCounter = %p\n&quot;, iCounter, &amp;iCounter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int iLocal = 33;</span><br><span class="line">    printf(&quot;&amp;iLocal = %p, iLocal = %d\n&quot;, &amp;iLocal, iLocal);</span><br><span class="line">    printf(&quot;&amp;iGlobal = %p, iGlobal = %d\n&quot;, &amp;iGlobal, iGlobal);</span><br><span class="line">    printf(&quot;&amp;iThisFileOnly = %p, iThisFileOnly = %d\n&quot;,</span><br><span class="line">           &amp;iThisFileOnly, iThisFileOnly);</span><br><span class="line"></span><br><span class="line">    for (int i=0;i&lt;5;i++)</span><br><span class="line">        func();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;iLocal = 000000000061FE18, iLocal = 33</span><br><span class="line">&amp;iGlobal = 0000000000403010, iGlobal = 11</span><br><span class="line">&amp;iThisFileOnly = 0000000000403014, iThisFileOnly = 22</span><br><span class="line">func called: 1, &amp;iCounter = 0000000000407030</span><br><span class="line">func called: 2, &amp;iCounter = 0000000000407030</span><br><span class="line">func called: 3, &amp;iCounter = 0000000000407030</span><br><span class="line">func called: 4, &amp;iCounter = 0000000000407030</span><br><span class="line">func called: 5, &amp;iCounter = 0000000000407030</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int iLocal = 33;</span><br></pre></td></tr></table></figure>

<p>第14行：为对照方便，我们在main( )函数内定义了自动变量iLocal。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;iLocal = %p, iLocal = %d\n&quot;, &amp;iLocal, iLocal);</span><br><span class="line">printf(&quot;&amp;iGlobal = %p, iGlobal = %d\n&quot;, &amp;iGlobal, iGlobal);</span><br><span class="line">printf(&quot;&amp;iThisFileOnly = %p, iThisFileOnly = %d\n&quot;,</span><br><span class="line">       &amp;iThisFileOnly, iThisFileOnly);</span><br></pre></td></tr></table></figure>

<p>第15 ~ 18行：输出了自动变量iLocal、具有外部链接属性的静态对象iGlobal、具体内部链接属性的静态对象iThisFileOnly的地址及值。从输出结果可见，自动变量iLocal的地址0x0061FE18与其他静态对象的地址相去甚远，它应该处于”栈“内。同时，静态对象iGlobal的地址0x00403010、iThisFileOnly的地址0x00403014则紧紧相邻，且与func( )函数内的静态对象iCounter的地址0x00407030相去不远，它们都位于全局静态数据区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func()&#123;</span><br><span class="line">    static int iCounter = 0;    //只能在本函数中被使用</span><br><span class="line">    iCounter++;</span><br><span class="line">    printf(&quot;func called: %d, &amp;iCounter = %p\n&quot;, iCounter, &amp;iCounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7 ~ 11行：函数内的iCounter如果是个普通的局部自动对象，则对于每次的函数调用，该变量都会重新在栈内分配空间且被初始化为0。如果是这样的话，第10行printf( )输出的iCounter值固定为1。</p>
<p>但这里的iCounter是一个静态局部对象，它的空间位于全局静态数据区，且其被赋值为0的初始化仅会被执行一次。这导致了下述两个结论：</p>
<ul>
<li>对于每次的func( )调用，函数内部操作的iCounter均是同一个对象；</li>
<li>iCounter可以在多次函数调用间保存其值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;5;i++)</span><br><span class="line">    func();</span><br></pre></td></tr></table></figure>

<p>第20 ~ 21行：循环执行了func( )函数5次。从执行结果可以看见，iCounter成功记录了该函数被调用执行的次数1，2，3，…</p>
<p>下述代码没有使用函数内的局部静态对象，而使用全局变量iCounter来记录func( )函数执行的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int iCounter = 0;</span><br><span class="line">void func()&#123;</span><br><span class="line">    iCounter++;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现方式实现了相同的功能，但代码质量要差很多：函数外部的iCounter变量成为func( )函数接口的一部分，这使得该函数的使用和维护都变得更加复杂；同时，全局变量iCounter的内存也”污染“了全局名字空间▲。</p>
<p>此外，除了普通变量外，函数也可以定义为static。下述函数private( )加上static属性之后，其仅被允许在包含它的源代码文件中使用。我们称该函数具有内部链接属性▲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static int private(float f)&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>按照面向对象程序设计的观点，万物皆对象，函数private( )也是一个对象。</p>
<h3 id="8-4-存储类型说明符"><a href="#8-4-存储类型说明符" class="headerlink" title="8.4 存储类型说明符"></a>8.4 存储类型说明符</h3><p>static即为存储类型说明符（storage class specifier）之一，它要求编译器将对象存储在全局静态数据区。</p>
<p>在C及C++ 11之前，register说明符（specifier）建议编译器将变量存储在寄存器中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">register int i = 0;</span><br></pre></td></tr></table></figure>

<p>寄存器是CPU内部超级快速的临时存储器，但数量有限。register说明符仅仅是对编译器的建议，当寄存器资源不足时，编译器会拒绝这种提义，为上述i对象分配普通的内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register int i = 0;</span><br><span class="line">printf(&quot;&amp;i = %p, i = %d&quot;, &amp;i, i);  //错误：不可以对register对象取地址</span><br></pre></td></tr></table></figure>

<p>上述代码的第2行在C语言当中是错误的，因为寄存器变量不存在普通意义上的内存地址。</p>
<p>在C++ 11之后，register被弃用，丧失了语法含义。</p>
<p>在C++ 11之前，auto说明符用于表示变量属于自动变量，正如读者理解的那样，这毫无意义。因为如果不加以static等说明符，不加auto的变量也是自动变量。所以，C++ 11之后，auto被用来表示类型推断。</p>
<p>mutable、extern、thread_local<strong>【C++ 11】</strong>这些存储类型说明符将在本书的后续章节中逐步讨论。</p>
<h2 id="9-位操作"><a href="#9-位操作" class="headerlink" title="9. 位操作"></a>9. 位操作</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>计算机内的数据存储和操作永远是二进制的。称一个占据4字节空间的对象为int，仅仅表明我们以int的形式去理解和操作那32个比特位。从电路层面上，储存一个int的4字节空间与存储一个float的4字节空间没有什么不同，都存储着32个0或者1。</p>
<p>当我们操作一个整数对象，比如给它赋值时，是把其32个比特位当成一个整体操作。有时，特别当我们的程序试图直接跟CPU外部电路打交道时，我们期望能够直接操作一个对象的单个比特位。C语言的位操作可以达成此目的。</p>
<h3 id="9-1-二进制及十六进制"><a href="#9-1-二进制及十六进制" class="headerlink" title="9.1 二进制及十六进制"></a>9.1 二进制及十六进制</h3><p>假设一个无符号短整数（unsigned short）由2字节共16比特构成，其每个比特的值如图9- 所示。</p>
<p><img src="http://codelearn.club/images/image-20200307104436966.png" alt="image-20200307104436966"></p>
<p>图9- 二进制示意图</p>
<p>在图9- 中， 16个二进制位来源于连续的两字节存储空间，从低到高依次标为第0位 ~ 第15位，然后每一位都对应位权20 ~ 215。</p>
<p>为了帮助读者理解，作者特意画了十进制的952710的结构作为参照。十进制数952710的值 &#x3D; 9 x 103 + 5 x 102 + 2 x 101 + 7 x 100。即，十进制数的值等于其每位的位值乘以对应的位权，再求和。</p>
<p>类似地，二进制数的值也等于其每位的位置乘以对应的位权，再求和。本例中，有：<br>01001111101100102&#x3D;0×215+1×214+0×213+0×212+1×211+1×210+1×29+1×28 +1×27+0×26+1×25+1×24+0×23+0×22+1×21+0×20 &#x3D;2040210(1)(1)01001111101100102&#x3D;0×215+1×214+0×213+0×212+1×211+1×210+1×29+1×28 +1×27+0×26+1×25+1×24+0×23+0×22+1×21+0×20 &#x3D;2040210<br>在编程时，如果直接书写二进制字面量是一件痛苦的工作，程序员要非常小心地反复确认那些0和1的数字有没有错漏。相对于二进制，那些长期与电路打交道的电气工程师更愿意使用十六进制。十六进制的每一位，可以表示0 ~ 15共16种组合，由于24恰好等于16，所以每个十六进制位正好对应4个二进制位，其对应关系如表9- 所示。</p>
<p>表9- 十六进制、十进制及二进制对应关系</p>
<table>
<thead>
<tr>
<th>十六进制</th>
<th>十进制</th>
<th>二进制（4位）</th>
<th>十六进制</th>
<th>十进制</th>
<th>二进制（4位）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0000</td>
<td>8</td>
<td>8</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0001</td>
<td>9</td>
<td>9</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0010</td>
<td>A</td>
<td>10</td>
<td>1010</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>0011</td>
<td>B</td>
<td>11</td>
<td>1011</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>0100</td>
<td>C</td>
<td>12</td>
<td>1100</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>0101</td>
<td>D</td>
<td>13</td>
<td>1101</td>
</tr>
<tr>
<td>6</td>
<td>6</td>
<td>0110</td>
<td>E</td>
<td>14</td>
<td>1110</td>
</tr>
<tr>
<td>7</td>
<td>7</td>
<td>0111</td>
<td>F</td>
<td>15</td>
<td>1111</td>
</tr>
</tbody></table>
<p>按照表9- ，我们很容易把二进制数换算成对应的十六进制。方法就是从低位往高位方向，将二进制位分为4位一组，然后按表9- 将每一组转成对应的十六进制符号即可。如图9- 所示，本例中的01001111101100102 &#x3D; 4FB216，按字面量表示为0x4FB2。</p>
<p><img src="http://codelearn.club/images/image-20200307113333369.png" alt="image-20200307113333369"></p>
<p>图9- 十六进制与二进制的互换</p>
<p>反过来，如果要把十六进制转换成二进制，则需要按表9- 将每个十六进制位转换成4位二进制，然后再串起来即可。</p>
<blockquote>
<p><strong>扩展阅读📕</strong> 本例中的unsigned short是由两个连续的字节构成的。其中第0<del>7位是低位字节，第8</del>15位是高位字节。在实际的内存布置中，是高位字节的地址高还是低位字节的地址高，不同的CPU有不同的规定。这个问题就是所谓的大小端（big endian&#x2F;small endian）问题。【这个问题提示我们，如果没有特殊技术优势，一定要区别人别人，自己独搞一套的都是王八蛋。此句话会删掉的，骂人解压】</p>
</blockquote>
<p>需要提醒读者，本章中所讨论的全部按位操作的讨论，均基于无符号整数。对于有符号整数，由于补码的存在，问题要稍显复杂。在实践中，对有符号整数进行按位操作的情况比较少。</p>
<h3 id="9-2-按位取反"><a href="#9-2-按位取反" class="headerlink" title="9.2 按位取反"></a>9.2 按位取反</h3><p>C语言中的按位（bitwise）操作符都用于整型对象，包括char、short、int、long、long long等。</p>
<p><del>操作符用于将操作数按位取反（not），即对于每个二进制位，1变0，0变1。下述C++程序演示了</del>操作符的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - NotOp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned char c = 0b01011101;</span><br><span class="line">    //二进制字面量是C++14引入的，早期版本中请用0x5d代替</span><br><span class="line">    unsigned char d = ~c;</span><br><span class="line">    cout &lt;&lt; &quot;c  = &quot; &lt;&lt; bitset&lt;8&gt;(c) &lt;&lt; endl; </span><br><span class="line">    //尖括号中的8是模板参数，意即要把c转为8位二进制字符串</span><br><span class="line">    cout &lt;&lt; &quot;~c = &quot; &lt;&lt; bitset&lt;8&gt;(d) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c  = 01011101</span><br><span class="line">~c = 10100010</span><br></pre></td></tr></table></figure>

<p>说明：C语言的printf( )函数不支持把对象按二进制格式输出。为了演示方便，本章中几乎全部使用C++程序来演示，C++标准模板库中的bitset类型可以方便地把对象转换成指定位数的二进制字符串。这些C++示例当中关于位操作的语法，与C语言完全相同。</p>
<p>从上述执行结果可以看到：~（01011101） &#x3D; 10100010。</p>
<h3 id="9-3-按位与"><a href="#9-3-按位与" class="headerlink" title="9.3 按位与"></a>9.3 按位与</h3><p>a &amp; b中的&amp;操作符将a对象与b对象的对应二进制位逐一进行按位与（and）运算。当且仅当a与b中的对应二进制位均为1时，结果位为1，否则为0。对于单个比特位的&amp;运算，可以总结其规则如下：</p>
<table>
<thead>
<tr>
<th>1 &amp; 1 &#x3D; 1</th>
<th>1 &amp; 0 &#x3D; 0</th>
</tr>
</thead>
<tbody><tr>
<td>0 &amp; 1 &#x3D; 0</td>
<td>0 &amp; 0 &#x3D; 0</td>
</tr>
</tbody></table>
<p>a &amp; b中的&amp;操作符是按位与操作符，它二元运算符，需要两个操作数。 &amp;b中的&amp;操作符是取地址操作符，它是一元操作符，只需要一个操作数。下述C++程序演示了按位与操作符&amp;的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - BitAnd</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int a = 0x8ffff37a;</span><br><span class="line">    unsigned int b = 0xfc7779f6;</span><br><span class="line"></span><br><span class="line">    unsigned int c = a &amp; b;</span><br><span class="line">    cout &lt;&lt; &quot;a     = &quot; &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl; //转为32位二进制字符串输出</span><br><span class="line">    cout &lt;&lt; &quot;b     = &quot; &lt;&lt; bitset&lt;32&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a &amp; b = &quot; &lt;&lt; bitset&lt;32&gt;(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a            = &quot; &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;0xfffffff7   = &quot; &lt;&lt; bitset&lt;32&gt;(0xfffffff7) &lt;&lt; endl;</span><br><span class="line">    a &amp;= 0xfffffff7;      //复合操作符，等价于a = a &amp; 0xfffffff7;</span><br><span class="line">    cout &lt;&lt; &quot;a &amp; fffffff7 = &quot; &lt;&lt; bitset&lt;32&gt;(a) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a     = 10001111111111111111001101111010</span><br><span class="line">b     = 11111100011101110111100111110110</span><br><span class="line">a &amp; b = 10001100011101110111000101110010</span><br><span class="line">a            = 10001111111111111111001101111010</span><br><span class="line">0xfffffff7   = 11111111111111111111111111110111</span><br><span class="line">a &amp; fffffff7 = 10001111111111111111001101110010</span><br></pre></td></tr></table></figure>

<p>执行结果的第1 ~ 3行反应了无符号整数a与b进行按位与运算的结果，请读者仔细逐一检查结果中每一个比特位的值与a，b对应位之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp;= 0xfffffff7;      //复合操作符，等价于a = a &amp; 0xfffffff7;</span><br></pre></td></tr></table></figure>

<p>第17行：&amp;&#x3D;是一个复合操作符，本行等价于a &#x3D; a &amp; 0xfffffff7。</p>
<p>请读者注意，0xfffffff7是一个很特别的数，在它的32个比特位中，只有第3位为0，其余位全为1。将unsigned int对象a与0xfffffff7进行按位与预算并赋值给a，将导致如下如果：</p>
<ul>
<li>a的第3位将被置为0，不论其第3位本来是0还是1；</li>
<li>a的其余位不会发生变化，因为任何值与1做与运算，值不变。</li>
</ul>
<p>请读者观察执行结果的第4 ~ 6行，检验上述分析是否正确。所以，<strong>通过按位与运算，可以达到将对象的特定位”置0“同时又保持其它位不变的目的</strong>。</p>
<h3 id="9-4-按位或"><a href="#9-4-按位或" class="headerlink" title="9.4 按位或"></a>9.4 按位或</h3><p>a | b中的|操作符将a对象与b对象的对应二进制位逐一进行按位或（or）运算。当且仅当a与b中的对应二进制位中有至少一个1时，结果位为1，否则为0。对于单个比特位的|运算，可以总结其规则如下：</p>
<table>
<thead>
<tr>
<th>1 | 1 &#x3D; 1</th>
<th>0 | 1 &#x3D; 1</th>
</tr>
</thead>
<tbody><tr>
<td>1 | 0 &#x3D; 1</td>
<td>0 | 0 &#x3D; 0</td>
</tr>
</tbody></table>
<p>下述C++程序演示了按位或操作符|的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - BitOr</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned short a = 0xf37a;</span><br><span class="line">    unsigned short b = 0x79f6;</span><br><span class="line"></span><br><span class="line">    unsigned short c = a | b;</span><br><span class="line">    cout &lt;&lt; &quot;a     = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl; //转为16位二进制字符串输出</span><br><span class="line">    cout &lt;&lt; &quot;b     = &quot; &lt;&lt; bitset&lt;16&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a | b = &quot; &lt;&lt; bitset&lt;16&gt;(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a          = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;0x0800     = &quot; &lt;&lt; bitset&lt;16&gt;(0x0800) &lt;&lt; endl;</span><br><span class="line">    a |= 0x0800;      //复合操作符，等价于a = a | 0x0800;</span><br><span class="line">    cout &lt;&lt; &quot;a | 0x0800 = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a     = 1111001101111010</span><br><span class="line">b     = 0111100111110110</span><br><span class="line">a | b = 1111101111111110</span><br><span class="line">a          = 1111001101111010</span><br><span class="line">0x0800     = 0000100000000000</span><br><span class="line">a | 0x0800 = 1111101101111010</span><br></pre></td></tr></table></figure>

<p>执行结果的第1 ~ 3行反应了无符号短整数a与b进行按位或运算的结果，请读者仔细逐一检查结果中每一个比特位的值与a，b对应位之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a |= 0x0800;      //复合操作符，等价于a = a | 0x0800;</span><br></pre></td></tr></table></figure>

<p>第17行：|&#x3D;是一个复合操作符，本行等价于a &#x3D; a | 0x0800。</p>
<p>请读者注意，0x0800是一个很特别的数，在它的16个比特位中，只有第11位为1，其余位全为0。将unsigned short对象a与0x0800进行按位或预算并赋值给a，将导致如下如果：</p>
<ul>
<li>a的第11位将被置为1，不论其第11位本来是0还是1；</li>
<li>a的其余位不会发生变化，因为任何值与0作或运算，值不变。</li>
</ul>
<p>请读者观察执行结果的第4 ~ 6行，检验上述分析是否正确。所以，<strong>通过按位或运算，可以达到将对象的特定位“置1”同时又保持其它位不变的目的</strong>。</p>
<h3 id="9-5-按位异或"><a href="#9-5-按位异或" class="headerlink" title="9.5 按位异或*"></a>9.5 按位异或*</h3><p>a ^ b中的^操作符将a对象与b对象的对应二进制位逐一进行按位异或（xor）运算。当且仅当a与b中的对应二进制位不同时，结果位为1，否则为0。对于单个比特位的^运算，可以总结其规则如下：</p>
<table>
<thead>
<tr>
<th>1 ^ 1 &#x3D; 0</th>
<th>1 ^ 0 &#x3D; 1</th>
</tr>
</thead>
<tbody><tr>
<td>0 ^ 1 &#x3D; 1</td>
<td>0 ^ 0 &#x3D; 0</td>
</tr>
</tbody></table>
<p>下述C++程序演示了按位或操作符|的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - BitXor</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned char a = 0xb4;</span><br><span class="line">    unsigned char b = 0x77;</span><br><span class="line"></span><br><span class="line">    unsigned char c = a ^ b;</span><br><span class="line">    cout &lt;&lt; &quot;a     = &quot; &lt;&lt; bitset&lt;8&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b     = &quot; &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a ^ b = &quot; &lt;&lt; bitset&lt;8&gt;(c) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a     = 10110100</span><br><span class="line">b     = 01110111</span><br><span class="line">a ^ b = 11000011</span><br></pre></td></tr></table></figure>

<p>请读者结合执行结果的每一位对照检查其与操作数a，b对应位之间的关系。类似地，a ^&#x3D; b中的^&#x3D;b是个复合操作符，等价于a &#x3D; a ^ b。</p>
<p>灵活地运用异或运算，也可以达成某些神奇的效果，见下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Project - BitXor2</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned char a = 0xaa;</span><br><span class="line">    unsigned char b = 0xf0;</span><br><span class="line">    cout &lt;&lt; &quot;a   = &quot; &lt;&lt; bitset&lt;8&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b   = &quot; &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;a^b = &quot; &lt;&lt; bitset&lt;8&gt;(a^b) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a   = 10101010</span><br><span class="line">b   = 11110000</span><br><span class="line">a^b = 01011010</span><br></pre></td></tr></table></figure>

<p>如果读者仔细观察执行结果的第3行和第1行，可以发现：</p>
<ul>
<li>b的高4位全是1，a^b的高4位相当于把a的高4位1010取反，得0101；</li>
<li>b的低4位全是0，a^b的低4位同a的低4位相同，仍为1010。</li>
</ul>
<p>客观上，上述程序达到了将a的高4位取反， 而低4位不变的目的。而哪些位取反， 哪些位不变，则由b的二进制值来确定：为1的对应位取反，为0的对应位不变。</p>
<h3 id="9-6-左移位"><a href="#9-6-左移位" class="headerlink" title="9.6 左移位"></a>9.6 左移位</h3><p>a &lt;&lt; n中的&lt;&lt;称为<strong>左移位操作符（left shift operator）</strong>，它将对象a的二进制位逐次左移n位，超出左端的二进制位丢弃，并用0填充右端空出的位置。下述C++示例演示了&lt;&lt;操作符的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Project - LeftShift</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned short a = 5;</span><br><span class="line">    cout &lt;&lt; &quot;a      = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; &quot;, value = &quot; &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">    a = a &lt;&lt; 3;    //等价于 a &lt;&lt;= 3;</span><br><span class="line">    cout &lt;&lt; &quot;a &lt;&lt; 3 = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; &quot;, value = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a      = 0000000000000101, value = 5</span><br><span class="line">a &lt;&lt; 3 = 0000000000101000, value = 40</span><br></pre></td></tr></table></figure>

<p>第9行代码将a左移3位，执行结果显示，在左移三位后，右方空出位全部填充了0。</p>
<p>对于10进制数52310，如果将其左移一位，右方补0，得523010，客观上，左移一位相当于把数字乘以10。同理，在<strong>不溢出的前提</strong>下，二进制数左移一位，右方补0，客观上相当于把该数乘以2。如果左移n位，则相当于把该数乘以2n。本例中，原值为5的a被左移了3位，相当于乘以23，变为原始的8倍，结果为40。</p>
<p>类似地，a &lt;&lt;&#x3D; n中的&lt;&lt;&#x3D;为复合操作符，其等价于a &#x3D; a &lt;&lt; n。请读者不要把左移位操作符与cout &lt;&lt; “a …”中的&lt;&lt;相混淆，它们具有完全不同的含义和用途。</p>
<h3 id="9-7-右移位"><a href="#9-7-右移位" class="headerlink" title="9.7 右移位"></a>9.7 右移位</h3><p>a &gt;&gt; n中的&gt;&gt;称为<strong>右移位操作符（right shift operator）</strong>，它将对象a的二进制位逐次右移n位，超出右端的二进制位丢弃。如果a是无符号整数，用0填充左端空位，如果a为有符号整数，填充值取决于具体的机器，可以是0，也可以是符号位。下述C++示例演示了&gt;&gt;操作符的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//Project - RightShift</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned short a = 2368;</span><br><span class="line">    cout &lt;&lt; &quot;a      = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; &quot;, value = &quot; &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">    a = a &gt;&gt; 5;    //等价于 a &gt;&gt;= 5;</span><br><span class="line">    cout &lt;&lt; &quot;a &gt;&gt; 5 = &quot; &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; &quot;, value = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a      = 0000100101000000, value = 2368</span><br><span class="line">a &gt;&gt; 5 = 0000000001001010, value = 74</span><br></pre></td></tr></table></figure>

<p>第9行代码将<strong>无符号</strong>短整数a右移5位，执行结果显示，在右移五位后，左方空出位全部填充了0。</p>
<p>与左移操作相反，在<strong>没有损失有效位</strong>（即没有1被移出丢弃）的情况下，将无符号整数右移1位，相当于将该数除以2，右移n位，相当于将该数除以2n。本例中，原值为2368的无符号短整数a右移5位，相当于除以25，即32，结果为74。</p>
<p>类似地，a &gt;&gt;&#x3D; n中的&gt;&gt;&#x3D;为复合操作符，其等价于a &#x3D; a &gt;&gt; n。请读者不要把右移位操作符与cin &gt;&gt; a中的&gt;&gt;相混淆，它们具有完全不同的含义和用途。</p>
<h3 id="9-8-置位与复位"><a href="#9-8-置位与复位" class="headerlink" title="9.8 置位与复位"></a>9.8 置位与复位</h3><p>将整数的指定位“置为1”称为<strong>置位（set bit）</strong>；将整数的指定位“置为0”称为<strong>复位（reset bit）</strong>。之前的讨论中，我们已经知道：通过按位与运算，可以达到将对象的特定位“置0”同时又保持其它位不变的目的；通过按位或运算，可以达到将对象的特定位“置1”同时又保持其它位不变的目的。</p>
<p>下述C++程序中的setBit( )及resetBit( )模板函数即是通过按位或及按位与操作实现置位和复位的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Project - SetResetBit</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void setBit(T&amp; v,  int bit)&#123;</span><br><span class="line">    v |= (0x01 &lt;&lt; bit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline void resetBit(T&amp;v, int bit)&#123;</span><br><span class="line">    v &amp;= (~(0x01 &lt;&lt; bit));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned short v = 0xff00;</span><br><span class="line">    cout &lt;&lt; &quot;before v = &quot; &lt;&lt; bitset&lt;16&gt;(v) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    setBit(v,6);</span><br><span class="line">    setBit(v,0);</span><br><span class="line">    setBit(v,11);    //置0，6，11位为1</span><br><span class="line">    resetBit(v,15);</span><br><span class="line">    resetBit(v,10);  //置10，15位为0</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;after  v = &quot; &lt;&lt; bitset&lt;16&gt;(v) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before v = 1111111100000000</span><br><span class="line">after  v = 0111101101000001</span><br></pre></td></tr></table></figure>

<p>第６ ~ 9行：setBit(T&amp; v，int bit)将v对象的第bit位置位。</p>
<p>第11 ~ 14行：resetBit(T&amp; v, int bit)将v对象的第bit位复位。</p>
<p>第20 ~ 22行：先后将v的第0、6及11位置位，执行结果可见，置位操作是成功的。同时，在置位前，v的第11位即为1，第11位的置位没有带来任何改变。</p>
<p>第23 ~ 24行：将v的第10、15位复位。执行结果可见，复位操作成功进行。</p>
<p><img src="http://codelearn.club/images/image-20200307220115823.png" alt="image-20200307220115823"></p>
<p>图9- setBit(v,6)的执行过程</p>
<p>图9- 以setBit(v,6)为例，来说明本程序的置位原理。本例中，程序首先使用0x01 &lt;&lt; 6来构造一个第6位为1，其它位全为0的unsigned short，然后再把这个临时对象与v作按位或运算，将v的第6位置位，其它位则保持不变。</p>
<p><img src="http://codelearn.club/images/image-20200307220153793.png" alt="image-20200307220153793"></p>
<p>图9- resetBit(v,10)的执行过程</p>
<p>图9- 以resetBit(v,10)为例，来说明本程序的复位原理。本例中，程序首先使用0x01 &lt;&lt; 10来构造一个第10位为1，其它位全为0的unsigned short，然后再按位取反，得到一个第10位为0，其它位全为1的unsigned short。然后，再把这个临时对象与v作按位与运算，将v的第10位复位，其它位则保持不变。</p>
<p>几乎所有CPU都没有提供直接操作单个比特位的机器指令，所以，C&#x2F;C++语言仅提供了基于单个字节、两个字节、四个字节及八个字节的整体位操作语法。单个比特位的操纵，只能通过上述运算来间接完成。</p>
<h3 id="微实践-地铁能够关门了吗？"><a href="#微实践-地铁能够关门了吗？" class="headerlink" title="微实践 - 地铁能够关门了吗？"></a>微实践 - 地铁能够关门了吗？</h3><p><img src="http://codelearn.club/images/image-20200307201330949.png" alt="image-20200307201330949"></p>
<p>图9- 地铁门障碍检测电路简图</p>
<p>地铁上完客，在关门前必须要确认没有人或者物品挡住门口，否则可能会造成人员夹伤或财产损失。图9- 展示了一种用于地铁门障碍物检测的电路：</p>
<ul>
<li>发光二极管D1装在门的左侧，它在电流驱动下发出不可见的红外光。</li>
<li>光敏三极管D2装在门的右侧，当门口没有障碍物时，D1发出的红外线照射在光敏三极管D2上，其集电极-发射极导通，其集电极信号S0与地导通，电压为低。</li>
<li>当门口有障碍物挡住了D1发射的红外线时，D2的集电极-发射极断开，此时，其集电极信号S0被上拉电阻拉高，电压为高。</li>
<li>S0信号与CPU的端口管脚相连，当有障碍物时，S0电压为高，CPU认为其值为1；当没有障碍物时，S0电压为低，CPU认为其值为0。</li>
</ul>
<p>假设一列地铁有8节车厢共16扇车门，每扇车门都安装了类似的障碍物检测电路，共了S0 ~ S15共16个传感器信号连接到CPU。现CPU通过输入指令读取了这个端口上的16个传感器信号，并将其存入了一个unsigned short类型的变量。现请通过位操作方法检测有哪几扇门存在障碍物，即对应的比特位为1？</p>
<p>读者如果看不懂上述检测电路图，并不影响对程序的理解。本程序的实质就是要检测一个unsigned short哪些位为1。作者编写了下述C++代码来实现上述功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Project - SubwayDoor</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void testDoorSensors(unsigned short s, bool r[])&#123;</span><br><span class="line">    for (int i=0;i&lt;16;i++)</span><br><span class="line">        r[i] = s &amp; (0x01 &lt;&lt; i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned short s = 0x4031;   //随意假设的测试值</span><br><span class="line">    bool blocked[16];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;s = &quot; &lt;&lt; bitset&lt;16&gt;(s) &lt;&lt; endl;</span><br><span class="line">    testDoorSensors(s,blocked);</span><br><span class="line">    for (int i=0;i&lt;16;i++)&#123;</span><br><span class="line">        if (blocked[i])</span><br><span class="line">            cout &lt;&lt; &quot;Door &quot; &lt;&lt; i &lt;&lt; &quot; is blocked.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = 0100000000110001</span><br><span class="line">Door 0 is blocked.</span><br><span class="line">Door 4 is blocked.</span><br><span class="line">Door 5 is blocked.</span><br><span class="line">Door 14 is blocked.</span><br></pre></td></tr></table></figure>

<p>第6 ~ 9行：testDoorSensors( )用于检测形参变量s的每一个二进制位，并将结果存入r数组，如果对应的二进制位为1，存入r数组的值为true，否则为false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r[i] = s &amp; (0x01 &lt;&lt; i);</span><br></pre></td></tr></table></figure>

<p>第8行：首先通过将0x01左移i位，形成一个仅第i位为1，其余位全为0的unsigned short。然后将这个临时变量与s作按位与运算，如果s的第i位为0，则结果对象的每一位都是0，整个与运算的运果为0，转换成布尔型，为false。如果s的第i位为1，则结果对象中的第i位为1，整个与运算的结果非0，按非零即真原则转换成布尔型，为true。下面以s的第4位的检测过程为例进行解释。</p>
<ul>
<li>0x01 &lt;&lt; 4，其结果为00000000000100002。</li>
<li>00000000000100002与s变量01000000001100012进行按位与运算，结果为00000000000100002。</li>
<li>该结果00000000000100002按非零即真原则转换成布尔型，结果为true。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;16;i++)&#123;</span><br><span class="line">    if (blocked[i])</span><br><span class="line">        cout &lt;&lt; &quot;Door &quot; &lt;&lt; i &lt;&lt; &quot; is blocked.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第17 ~ 20行：遍历传感器变量s检测的结果数组blocked，如果发现元素值为true，说明该门存在障碍物，将其打印出来。从打印结果看，上述程序成功地检测并报告了s变量的全部值为1的位。</p>
<p>看起来，地铁的控制CPU还需要发出额外的警告声，等几秒后再次检测。</p>
<h2 id="10-枚举与联合"><a href="#10-枚举与联合" class="headerlink" title="10. 枚举与联合"></a>10. 枚举与联合</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="10-1-枚举型"><a href="#10-1-枚举型" class="headerlink" title="10.1 枚举型"></a>10.1 枚举型</h3><p>对事物进行分类是人类的技能之一。人分男女，大学的学生则又分为专科生、本科生、硕士研究生和博士研究生。与现实世界相对应，在程序当中，我们也常常需要表达对象所属的类别。而枚举类型，则是完成该任务的主要工具。</p>
<p>下述C语言代码定义了一个名为ColorType的枚举（enumeration）类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Project - ColorType</span><br><span class="line">enum ColorType &#123;</span><br><span class="line">    red, orange, yellow=100, green, blue, violet</span><br><span class="line">&#125;; //注意末尾的分号不能少</span><br><span class="line">//   0     1      100         101    102   103</span><br></pre></td></tr></table></figure>

<p>对于编译器而言，枚举类型的实质就是整数。上述定义中，编译器会从0开始，给各个枚举项确定对应的整数值。同时，程序也可以给某些枚举项指定值，如本例中的yellow被指定为100。那些在yellow之后的枚举项，则依次被确定100+1，100+2，100+3。上述程序中的第5行注释列出了所有枚举项所对应的整数值。</p>
<p>上述定义之后，在C语言里便可以把enum ColorType当成一个新的数据类型来使用。在C++里，可以直接把ColorType当成数据类型使用，不必加上enum关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum ColorType color = blue;</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个名为color的对象&#x2F;变量，其类型为enum ColorType，初始值为blue，即整数102。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color = green;</span><br><span class="line">color = 999;    //编译器警告：999不在枚举范围内</span><br><span class="line">color = 1;      //等价于orange</span><br></pre></td></tr></table></figure>

<p>任何ColorType的枚举项都可以赋值给color对象，也可以直接整数值赋值给color对象。当把一个不在ColorType枚举值范围内的整数，比如999赋值给color时，编译器会给出警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color = (enum ColorType)103;   //等价于violet</span><br></pre></td></tr></table></figure>

<p>有的编译器可能不喜欢你直接把整数赋值给枚举类型的对象，会给出类型不一致的警告，因为严格地说，上述赋值语句的左边是enum ColorType类型，而103则是整数字面量。此时，可以通过类型转换消除这种警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;violet = %d\n&quot;, violet);</span><br></pre></td></tr></table></figure>

<p>所有的枚举项，均可视为整数类型的常量，上述代码的输出值应为103。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - ColorType</span><br><span class="line">const char* getColor(enum ColorType c)&#123;</span><br><span class="line">    switch (c)&#123;</span><br><span class="line">    case red:</span><br><span class="line">        return &quot;red&quot;;</span><br><span class="line">    case orange:</span><br><span class="line">        return &quot;orange&quot;;</span><br><span class="line">    case yellow:</span><br><span class="line">        return &quot;yellow&quot;;</span><br><span class="line">    case green:</span><br><span class="line">        return &quot;green&quot;;</span><br><span class="line">    case blue:</span><br><span class="line">        return &quot;blue&quot;;</span><br><span class="line">    case violet:</span><br><span class="line">        return &quot;violet&quot;;</span><br><span class="line">    default:</span><br><span class="line">        return &quot;error&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以把枚举类型的对象作为switch分支语句的”整数表达式”。上述getColor( )函数将enum ColorType对象转换成对应的英文字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;color = %s\n&quot;, getColor(green));</span><br></pre></td></tr></table></figure>

<p>借助于getColor( )函数，上行代码将枚举项green转换成字符串”green”并输出。</p>
<p>在作者的开发环境及编译器下，sizeof(color)及sizeof(enum ColorType)均为4，这说明编译器内部将该枚举类型按4字节整数处理。枚举型对应整数，但到底对应1个字节（unsigned char, char），2个字节（unsigned short, short），还是4个字节的整数（unsigned int, int）则取决于编译器的决定。但可以放心，编译器最终确定的整数类型一定可以容纳所有枚举项对应的整数值。</p>
<p>读者可能会问：既然枚举类型的实质就是整数，那直接用整数0，1，2，3 … 来表示红、橙、黄、绿不就可以了？要枚举型为何用？ 答案是<strong>枚举型可以改善程序的可读性</strong>，对程序的阅读者而言，red比0更容易理解和记忆。</p>
<h3 id="10-2-typedef语句"><a href="#10-2-typedef语句" class="headerlink" title="10.2 typedef语句"></a>10.2 typedef语句</h3><p>在编写单片机的C语言程序时，电气工程师特别喜欢清楚地了解每个整数类型的字节数，以及符号特性，即是有符号还是无符号整数。这个目的可以通过typedef语句实现。typedef源自英文type definition。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Project - TypeDef</span><br><span class="line">typedef unsigned char  UINT8;    //无符号8位整数  unsigned int of 8 bits</span><br><span class="line">typedef unsigned short UINT16;   //无符号16位整数</span><br><span class="line">typedef unsigned int   UINT32;   //无符号32位整数</span><br><span class="line"></span><br><span class="line">typedef char  INT8;              //有符号8位整数</span><br><span class="line">typedef short INT16;             //有符号16位整数</span><br><span class="line">typedef int   INT32;             //有符号32位整数</span><br></pre></td></tr></table></figure>

<p>相对于unsigned char，unsigned short这种类型名称，UINT8，UINT16具有更好的解释性。在上述typedef之后，UINT8、INT32等类型直接与unsigned char，int通用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UINT8 b = 0x77;             //b的类型实为unsigned char</span><br><span class="line">UINT16 s = 0xf900;          //s的类型实为unsigned short</span><br><span class="line">INT32 c = 0x1f2f3f4f;       //c的类型实为int</span><br></pre></td></tr></table></figure>

<p>如果用sizeof操作符求上述b、s、c对象的字节数，分别应为1，2和4。</p>
<p>在第7章中，我们曾经借助typedef定义了一个名为biggerFunc的函数指针类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef bool (*biggerFunc)(const string&amp;, const string&amp;);</span><br></pre></td></tr></table></figure>

<p>上述定义完成后，biggerFunc可以当成数据类型来使用，下述代码定义了类型为biggerFunc的函数指针f：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">biggerFunc f;</span><br></pre></td></tr></table></figure>

<p>借助于typedef，我们也可以简化枚举类型的使用语法。下述代码将一个枚举类型定义为一个名为GenderType的数据类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Project - GenderType</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    male, female   //依次取值0,1</span><br><span class="line">&#125; GenderType;</span><br></pre></td></tr></table></figure>

<p>在C语言里，前节中的枚举类型ColorType必须结合enum关键字来使用，而使用typedef定义的GenderType可以直接使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//enum ColorType color = red;   //必须结合enum关键字使用</span><br><span class="line">GenderType gender = female;     //直接当成数据类型使用</span><br></pre></td></tr></table></figure>

<h3 id="10-3-枚举类"><a href="#10-3-枚举类" class="headerlink" title="10.3 枚举类"></a>10.3 枚举类</h3><p>传统C&#x2F;C++语言中的枚举类型有个很大的缺点。在下述GenderType枚举类型引入后，male、female做为一个枚举项，被视为整数常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum GenderType &#123;</span><br><span class="line">	male, female</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>male、female这两个名字处于全局名字空间。male，female是很普通的命名，它们的存在“污染”了名字空间。</p>
<p><strong>【C++ 11】</strong>引入了<strong>enum class（枚举类）</strong>，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//Project - EnumClass</span><br><span class="line">enum class GenderType:unsigned char&#123;</span><br><span class="line">    male,female</span><br><span class="line">&#125;;  //注意末尾分号不能少</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个名为GenderType的枚举类（enum class），其有两个枚举项，分别为male和female。基于相似的规则，male和female分别与整数0和1对应。上述定义中，GenderType冒号之后的unsigned char则显式地指定了该枚举类按unsigned char进行存储。如果省略该冒号及其之后的存储类型指示，枚举类的存储格式将由编译器自行确定。</p>
<blockquote>
<p>域解析符：”::”称为域解析符。Rocket::Engine可以理解为火箭（Rocket）里的发动机（Engine），以区别于Car::Engine（轿车里的发动机），和Engine（发动机）。</p>
</blockquote>
<p>相较于传统的枚举类型，enum class带来诸多益处。首先，其枚举项不再“污染”空字空间，必须通过域解析符::来使用，见下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenderType gender = GenderType::male; //::为域解析符</span><br><span class="line">//gender = male;    //错误: male不在全局名字空间内</span><br></pre></td></tr></table></figure>

<p>作为一个整体，GenderType::male具有更好的自解释性且不容易意外导致重名。</p>
<p>此外，不同于传统枚举型，enum class不允许其枚举项与整数之间的隐式类型转换，但显式类型转换是允许的。这种更严格的类型要求可以减少因为疏忽而导致的软件缺陷。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//gender = 1;       //错误：不允许进行整数与enum class之间的隐式类型转换</span><br><span class="line">gender = GenderType(0);  //显式类型转换 整数 -&gt; 枚举项</span><br><span class="line">int i = int(GenderType::female); //显式类型转换 枚举项 -&gt; 整数</span><br></pre></td></tr></table></figure>

<p>如果对上述gender对象应用sizeof操作符，返回的字节数应为1，因为GenderType的定义过程中指定了背后的存储类型：unsigned char。</p>
<h3 id="10-4-联合"><a href="#10-4-联合" class="headerlink" title="10.4 联合"></a>10.4 联合</h3><p>C语言中的联合（union）类型为我们提供了操纵和解读“数据”的独特方式，它允许对同一块内存以不同的方式进行解读和操纵。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union UINT &#123;</span><br><span class="line">    unsigned int intValue;   //占4个字节</span><br><span class="line">    unsigned char bytes[4];  //占4个字节</span><br><span class="line">&#125;;  //注意末尾分号不能少</span><br></pre></td></tr></table></figure>

<p>上述代码定义了一个名为UINT的联合类型。该类型提供了两个成员，分别是unsigned int类型的intValue，以及元素类型unsigned char的长度为4的字符数组bytes。这两个成员的内存空间是共享的，即，一个union UNIT类型的对象只占4个字节的空间。当以成员intValue进行操作时，这4个字节的内存被当成一个unsigned int进行操纵和解读；当以成员bytes进行操作时，这4个字节的内存被当成一个4字节的字符数组进行操纵和解读。</p>
<p>我们通过下述C语言程序来解释联合类型的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - UnionExample</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union UINT &#123;</span><br><span class="line">    unsigned int intValue;   //占4个字节</span><br><span class="line">    unsigned char bytes[4];  //占4个字节</span><br><span class="line">&#125;;  //注意末尾分号不能少</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    union UINT v = &#123;.intValue=0x11223344&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;v = %p, &amp;v.intValue = %p, v.bytes = %p\n&quot;,</span><br><span class="line">           &amp;v, &amp;v.intValue, v.bytes);</span><br><span class="line"></span><br><span class="line">    printf(&quot;v.bytes[0..3] = 0x%x 0x%x 0x%x 0x%x\n&quot;,</span><br><span class="line">           v.bytes[0], v.bytes[1], v.bytes[2], v.bytes[3]);</span><br><span class="line"></span><br><span class="line">    v.bytes[0] = 0x55; v.bytes[1] = 0x66;  v.bytes[2] = 0x77;  v.bytes[3] = 0x88;</span><br><span class="line">    printf(&quot;v.intValue = 0x%x\n&quot;,v.intValue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;sizeof(v) = %lld&quot;,sizeof(v));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;v = 000000000061FE1C, &amp;v.intValue = 000000000061FE1C, v.bytes = 000000000061FE1C</span><br><span class="line">v.bytes[0..3] = 0x44 0x33 0x22 0x11</span><br><span class="line">v.intValue = 0x88776655</span><br><span class="line">sizeof(v) = 4</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<blockquote>
<p><strong>要点🎯</strong> “.”被称为<strong>成员操作符</strong>，a.b意为对象a的b成员。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union UINT v = &#123;.intValue=0x11223344&#125;;</span><br></pre></td></tr></table></figure>

<p>第10行：C语言中，union UINT作为一个整体，代表名为UNIT的联合类型。在C++语言中，使用UINT类型时，前面的union关键字可以省略。此处的v是一个对象，其类型为union UINT。因为联合对象的多个成员是内存共享的，所以v的初始值必须以{ }包裹起来，.intValue指明了v初始化的实际动作是把0x11223344赋值给v的intValue成员。作者在这里故意使用了十六进制，因为十六进制每位占4个比特，每两位占1个字节。v定义并初始化以后，其内存结构可以用图10- 表示。</p>
<p><img src="http://codelearn.club/images/image-20200308235422586.png" alt="image-20200308235422586"></p>
<p>图10- 联合对象v的内存结构</p>
<p>如图10- 所示，v占据了地址为0x0061FE1C、0x0061FE1D、0x0061FE1E和0x0061FE1F的连续4个字节的存储空间。v的所谓数据成员，无非这4字节内存的不同视图（view）而已。从v.intValue的角度看，这是一个地址为0x0061FE1C的32位无符号整数；从v.bytes的角度看，这是一个从地址0x0061FE1C开始的4个元素的字符数组。</p>
<p>读者可能注意到，图10- 中，4个字节从低地址往高地址方向读，依次是0x44、0x33、0x22和0x11，其顺序与作为无符号整数的v.intValue的值正好相反。这是因为，Intel的x86系列CPU执行<strong>Big Endian</strong>的字节顺序，<strong>高位字节(0x11)存高地址（0x0061FE1F）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;v = %p, &amp;v.intValue = %p, v.bytes = %p\n&quot;,</span><br><span class="line">       &amp;v, &amp;v.intValue, v.bytes);</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：依次打印v的地址，v.intValue的地址，v.bytes的地址（数组名即为地址）。从执行结果的第1行可见，3个地址值相同。这证实，联合对象v的不同成员间是共享内存的。此处的v.intValue应用了”.”操作符，读者可以形象的将其理解为“v对象<strong>的</strong>intValue”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;v.bytes[0..3] = 0x%x 0x%x 0x%x 0x%x\n&quot;,</span><br><span class="line">       v.bytes[0], v.bytes[1], v.bytes[2], v.bytes[3]);</span><br></pre></td></tr></table></figure>

<p>第15 ~ 16行：依次打印v.bytes的4个元素。这相当于从v.bytes的角度去解释v.intValue的数据。执行结果的第2行证实，v.intValue最高位字节的0x11存在了v.bytes[3]里。如刚才所述，这是Big Endian的字节顺序导致的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.bytes[0] = 0x55; v.bytes[1] = 0x66;  v.bytes[2] = 0x77;  v.bytes[3] = 0x88;</span><br><span class="line">printf(&quot;v.intValue = 0x%x\n&quot;,v.intValue);</span><br></pre></td></tr></table></figure>

<p>第18 ~ 19行：对v.bytes成员进行赋值，然后再以v.intValue成员解释数据。执行结果的第3行证实，对v.bytes的修改即是对v.intValue的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(v) = %lld&quot;,sizeof(v));</span><br></pre></td></tr></table></figure>

<p>第21行：打印sizeof(v)，执行结果证实，联合对象v占4个字节的空间。</p>
<p>请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - MoreUnion</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union UMore &#123;</span><br><span class="line">    double dValue;    //全部8个字节</span><br><span class="line">    char   cValue;    //8个字节中的前1个字节</span><br><span class="line">    int    iValue;    //8个字节中的前4个字节</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;sizeof(union UMore) = %d\n&quot;, sizeof(union UMore));</span><br><span class="line"></span><br><span class="line">    union UMore v = &#123;33.22&#125;;  //未指定初始化成员时默认赋值给第0个成员dValue</span><br><span class="line">    printf(&quot;v.dValue = %f\n&quot;,v.dValue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;v.dValue = %p, &amp;v.cValue = %p, &amp;v.iValue = %p\n&quot;,</span><br><span class="line">           &amp;v.dValue, &amp;v.cValue, &amp;v.iValue);</span><br><span class="line"></span><br><span class="line">    union UMore* p = &amp;v;</span><br><span class="line">    printf(&quot;p-&gt;iValue = %d&quot;, p-&gt;iValue);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof(union UMore) = 8</span><br><span class="line">v.dValue = 33.220000</span><br><span class="line">&amp;v.dValue = 000000000061FE10, &amp;v.cValue = 000000000061FE10, &amp;v.iValue = 000000000061FE10</span><br><span class="line">p-&gt;iValue = -171798692</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<blockquote>
<p><strong>要点🎯</strong> 指向操作符：”-&gt;”称为指向操作符，如果p是一个指针，p-&gt;a表示p所指向的对象的a成员。p-&gt;a与(*p).a等价。</p>
</blockquote>
<p>上述程序中，联合类型UMore的三个成员分别占据8个、1个及4个字节的空间。从执行结果看，UMore类型的联合对象v占据8个字节的空间，正好是各成员空间尺寸的最大值。同时，还应注意到v的三个成员的地址相同。这意味着，当我们操作v.cValue时，仅会影响v的第0个字节，其余7个字节不受影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union UMore v = &#123;33.22&#125;;  //未指定初始化成员时默认赋值给第0个成员dValue</span><br><span class="line">printf(&quot;v.dValue = %f\n&quot;,v.dValue);</span><br></pre></td></tr></table></figure>

<p>第13 ~ 14行：需要说明，当联合对象初始化时，如果没有指明初始化成员，则会默认初始化第1个成员。执行结果的第2行证实，v.dValue被初始化为33.22。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;v.dValue = %p, &amp;v.cValue = %p, &amp;v.iValue = %p\n&quot;,</span><br><span class="line">       &amp;v.dValue, &amp;v.cValue, &amp;v.iValue);</span><br></pre></td></tr></table></figure>

<p>第16 ~ 17行：打印v的dValue、cValue及iValue成员的地址。执行结果证实，三者的地址相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union UMore* p = &amp;v;</span><br><span class="line">printf(&quot;p-&gt;iValue = %d&quot;, p-&gt;iValue);</span><br></pre></td></tr></table></figure>

<p>第19 ~ 20行：定义了一个指向v的指针p。p-&gt;iValue表示指针p所指向的联合对象的iValue成员。从执行结果可见，将8个字节double数据的前4个字节当成int来解读，结果是“莫名其妙”的。</p>
<h2 id="11-结构"><a href="#11-结构" class="headerlink" title="11. 结构"></a>11. 结构</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>朵拉同学家里运营着一家工厂，她希望编写一个程序来管理员工档案。考虑到每个雇员都有姓名、ID、性别、月薪等信息，她组织了如下的数据结构来存储雇员信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125; GenderType;</span><br><span class="line"></span><br><span class="line">char idEmployees[1000][30];        //身份证号字符串数组</span><br><span class="line">char nameEmployees[1000][256];     //姓名字符串数组</span><br><span class="line">int  salaryEmployees[1000];        //月薪字符串数组</span><br><span class="line">GenderType genderEmployees[1000];  //性别数组</span><br></pre></td></tr></table></figure>

<p>在上述数据结构中，朵拉在内存中开辟了1000个员工档案的存储空间，其中，第i个员工的身份证号储存在idEmployees数组的下标i处，月薪存储在genderEmployees数组的下标i处 …</p>
<p>这种数据结构主要有两个缺点：</p>
<ul>
<li>数组的元素个数是固定的，当员工数量显著少于1000时，内存浪费，员工数量超过1000时，溢出。这个问题需要通过本书后半部分介绍的容器类▲来解决。</li>
<li>同一个员工的信息分散在不同的数组里，使用不便。这个问题可以通过C语言的<strong>结构（struct）</strong>类型来解决。</li>
</ul>
<h3 id="11-1-结构定义"><a href="#11-1-结构定义" class="headerlink" title="11.1 结构定义"></a>11.1 结构定义</h3><p>下述C语言程序定义并使用了一个名为Employee的结构类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - EmployeeStruct</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">typedef enum &#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125; GenderType;</span><br><span class="line"></span><br><span class="line">struct Employee &#123;</span><br><span class="line">    char sName[10];     //姓名</span><br><span class="line">    bool bRetired;      //是否已退休</span><br><span class="line">    int  iSalary;       //月薪</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">&#125;;  //注意末尾分号不能少</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    struct Employee e = &#123;.sName = &quot;Jack Ma&quot;, .iSalary = 9000,</span><br><span class="line">                         .gender = male, .bRetired = false&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;e = %p, size = %lld\n&quot;, &amp;e, sizeof(e));</span><br><span class="line">    printf(&quot;e.sName = %p, size = %lld\n&quot;, e.sName, sizeof(e.sName));</span><br><span class="line">    printf(&quot;&amp;e.bRetired = %p, size = %lld\n&quot;, &amp;e.bRetired, sizeof(e.bRetired));</span><br><span class="line">    printf(&quot;&amp;e.iSalary = %p, size = %lld\n&quot;, &amp;e.iSalary, sizeof(e.iSalary));</span><br><span class="line">    printf(&quot;&amp;e.gender = %p, size = %lld\n&quot;, &amp;e.gender, sizeof(e.gender));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;e = 000000000061FE00, size = 20</span><br><span class="line">e.sName = 000000000061FE00, size = 10</span><br><span class="line">&amp;e.bRetired = 000000000061FE0A, size = 1</span><br><span class="line">&amp;e.iSalary = 000000000061FE0C, size = 4</span><br><span class="line">&amp;e.gender = 000000000061FE10, size = 4</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Employee &#123;</span><br><span class="line">    char sName[10];     //姓名</span><br><span class="line">    bool bRetired;      //是否已退休</span><br><span class="line">    int  iSalary;       //月薪</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">&#125;;  //注意末尾分号不能少</span><br></pre></td></tr></table></figure>

<p>第9 ~ 14行：定义了一个名为Employee的结构（struct），它有4个<strong>数据成员（data member）</strong>，这4个数据成员分别负责记录一个雇员的姓名、是否已退休、月薪及性别信息。</p>
<p>在上述定义之后，在C语言中，struct Employee便可以当成一个数据类型来使用。从面向对象程序设计的角度看，struct Employee类型与int、float、char一样，都是数据类型，区别在于，后3个是语言原生的，struct Employee是程序员通过编程“介绍”给编译器的。</p>
<p>类似地，可以通过typedef定义一个名为Employee的数据类型，避免每次使用都必须带上struct关键字的烦恼：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[10];     //姓名</span><br><span class="line">    bool bRetired;      //是否已退休</span><br><span class="line">    int  iSalary;       //月薪</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">&#125; Employee;</span><br><span class="line">struct Employee e = &#123;.sName = &quot;Jack Ma&quot;, .iSalary = 9000,</span><br><span class="line">                     .gender = male, .bRetired = false&#125;;</span><br></pre></td></tr></table></figure>

<p>第17 ~ 18行：定义了一名类型为struct Employee的对象e，并对其进行了初始化。与联合对象类似，其初始化值必须包裹在{ }之中。本例中，通过”.”操作符分别给各成员赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Employee e = &#123;&quot;Jack Ma&quot;,false,9000,male&#125;; //各成员初始值必须按顺序提供</span><br></pre></td></tr></table></figure>

<p>如该行代码所示：当{ }内的成员值按结构内成员定义顺序给出时，{ }内的成员名称可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;e = %p, size = %lld\n&quot;, &amp;e, sizeof(e));</span><br><span class="line">printf(&quot;e.sName = %p, size = %lld\n&quot;, e.sName, sizeof(e.sName));</span><br><span class="line">printf(&quot;&amp;e.bRetired = %p, size = %lld\n&quot;, &amp;e.bRetired, sizeof(e.bRetired));</span><br><span class="line">printf(&quot;&amp;e.iSalary = %p, size = %lld\n&quot;, &amp;e.iSalary, sizeof(e.iSalary));</span><br><span class="line">printf(&quot;&amp;e.gender = %p, size = %lld\n&quot;, &amp;e.gender, sizeof(e.gender));</span><br></pre></td></tr></table></figure>

<p>第20 ~ 24行：分别打印e、e.sName、e.bRetired、e.iSalary和e.gender的地址及字节数。与联合类型不同，结构的不同成员之间并不共享内存，它们是同一块内存的不同组成部分，相互之间是独立的。根据执行结果，我们画出了结构对象e的内存结构，如图11- 所示。</p>
<p><img src="http://codelearn.club/images/image-20200309165429830.png" alt="image-20200309165429830"></p>
<p>图11- 结构对象e的内存结构</p>
<p>如图11- 所示，结构对象e占20个字节的空间，其数据成员按定义顺序依次排列在这20个字节的空间内。其中：</p>
<ul>
<li>e.sName类型为char[ ]，占10个字节；</li>
<li>e.bRetired类型为bool，占1个字节，编译器出于数据对齐▲的原因，在该成员后安排了1个字节的空白区域；</li>
<li>e.iSalary类型int，占4个字节；</li>
<li>e.gender类型为GenderType枚举型，占4个字节。</li>
</ul>
<h3 id="11-2-结构对象"><a href="#11-2-结构对象" class="headerlink" title="11.2 结构对象"></a>11.2 结构对象</h3><p>在完成定义之后，结构类型在理论上与其他数据类型，比如int没有什么不同。下述C语言代码进一步展示了结构类型对象的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Project - EmployeeInfo</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">typedef enum &#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125; GenderType;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[10];     //姓名</span><br><span class="line">    bool bRetired;      //是否已退休</span><br><span class="line">    int  iSalary;       //月薪</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">&#125; Employee;</span><br><span class="line"></span><br><span class="line">void printEmployee(const Employee* p)&#123;</span><br><span class="line">    printf(&quot;------Employee Information--------\n&quot;);</span><br><span class="line">    printf(&quot;Name:   \t%s\n&quot;,p-&gt;sName);</span><br><span class="line">    printf(&quot;Retired:\t%s\n&quot;,p-&gt;bRetired?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    printf(&quot;Salary: \t%d\n&quot;,p-&gt;iSalary);</span><br><span class="line">    printf(&quot;Gender: \t%s\n&quot;,p-&gt;gender==male?&quot;MALE&quot;:&quot;FEMALE&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Employee e = &#123;&quot;Jack Ma&quot;, false, 9000, male&#125;;</span><br><span class="line">    e.iSalary += 1000;</span><br><span class="line"></span><br><span class="line">    Employee* p = &amp;e;</span><br><span class="line">    p-&gt;bRetired = true;</span><br><span class="line">    (*p).bRetired = false;</span><br><span class="line"></span><br><span class="line">    printEmployee(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">------Employee Information--------</span><br><span class="line">Name:           Jack Ma</span><br><span class="line">Retired:        No</span><br><span class="line">Salary:         10000</span><br><span class="line">Gender:         MALE</span><br></pre></td></tr></table></figure>

<p>第25 ~ 26行：定义并初始化了一个名为e的Employee类型对象。第26行通过”.”操作符访问e的iSalary成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Employee* p = &amp;e;</span><br><span class="line">p-&gt;bRetired = true;</span><br></pre></td></tr></table></figure>

<p>第28 ~ 29行：定义了一个指向Employee结构的指针p。当通过指针p访问结构成员时，通过”-&gt;”操作符实现。p-&gt;bRetired表示p所指向的Employee类型结构对象的bRetired成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*p).bRetired = false;</span><br></pre></td></tr></table></figure>

<p>第30行：对p应用间接操作符*之后，(*p)即表示p所指向的结构对象，此处为e。然后再对e应用”.”操作符，访问该结构对象的bRetired成员。这种访问方法跟p-&gt;bRetired等效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printEmployee(p);</span><br></pre></td></tr></table></figure>

<p>第32行：将结构对象e的指针传递给printEmployee( )函数，该函数负责打印参数指针所指向的“雇员”信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void printEmployee(const Employee* p)&#123;</span><br><span class="line">    printf(&quot;------Employee Information--------\n&quot;);</span><br><span class="line">    printf(&quot;Name:   \t%s\n&quot;,p-&gt;sName);</span><br><span class="line">    printf(&quot;Retired:\t%s\n&quot;,p-&gt;bRetired?&quot;Yes&quot;:&quot;No&quot;);</span><br><span class="line">    printf(&quot;Salary: \t%d\n&quot;,p-&gt;iSalary);</span><br><span class="line">    printf(&quot;Gender: \t%s\n&quot;,p-&gt;gender==male?&quot;MALE&quot;:&quot;FEMALE&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第16 ~ 22行：printEmployee( )函数用于打印雇员信息。请读者注意形参e的类型为const Employee*，即指向常量Employee对象的指针。这个形参定义带来了三项益处。</p>
<ul>
<li>避免直接对Employee对象e进行传值。直接传值将“创建”一个e的品，该传值的代价为20个字节。而传递指针，无论对象本身有多大，指针的尺寸是固定的4字节（32位编译器）或者8字节（64位编译器）。</li>
<li>避免在函数内意外修改p所指向的对象。按照printEmployee( )函数的预期用途，这种”名不副实“的修改极其有害。</li>
<li>让printEmployee( )函数的使用者放心地将对象的指针传递给该函数使用。因为该函数”声称“不会修改参数指针指向的对象。</li>
</ul>
<p>当然，在C++里，我们更倾向于使用常量型的引用，而不是指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e = &#123;&quot;Jack Ma&quot;, false, 9000, male&#125;;</span><br><span class="line">Employee f;</span><br><span class="line">f = e;        //e，f类型相同</span><br></pre></td></tr></table></figure>

<p>C语言允许在同类型结构对象间进行整体赋值，上述代码的第3行将e完整地到f。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float computeTax(Employee obj)&#123;   //用于计算员工的个税</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">computeTax(e);</span><br></pre></td></tr></table></figure>

<p>上述computeTax( )函数的形参obj将导致传值（call by value）行为的发生。computeTax(e)将实参e传递给形参obj，本例中的代价为20个字节。</p>
<h3 id="11-3-复合字面量"><a href="#11-3-复合字面量" class="headerlink" title="11.3 复合字面量"></a>11.3 复合字面量</h3><p>复合字面量（compound literals），顾名思义，是由多个普通字面量组合而得。如果需要一个临时的结构对象，复合字面量很好用。下述C语言代码演示了复合字面量的相关用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - CompoundLiteral</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    float width;</span><br><span class="line">    float height;</span><br><span class="line">&#125; Rect;   //表示一个矩形的结构体</span><br><span class="line"></span><br><span class="line">float computeArea1(Rect r)&#123;  //矩形面积计算函数1</span><br><span class="line">    return r.width * r.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float computeArea2(const Rect* r)&#123; //矩形面积计算函数2</span><br><span class="line">    return r-&gt;width * r-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Rect r;</span><br><span class="line">    r = (Rect)&#123;15,10&#125;;  //复合字面量</span><br><span class="line"></span><br><span class="line">    float fArea1 = computeArea1((Rect)&#123;3,2&#125;);   //生成临时对象并传值</span><br><span class="line">    float fArea2 = computeArea2(&amp;(Rect)&#123;3,2&#125;);  //对临时对象取地址</span><br><span class="line"></span><br><span class="line">    printf(&quot;fArea1 = %f, fArea2 = %f\n&quot;, fArea1, fArea2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fArea1 = 6.000000, fArea2 = 6.000000</span><br><span class="line">r = (Rect)&#123;15,10&#125;;  //复合字面量</span><br></pre></td></tr></table></figure>

<p>第20行：(Rect){15,10}即为一个Rect类型的复合字面量，注意类似于显式类型转换语法的(Rect)部分在这里是不可或缺的。该行创建了一个Rect类型的临时对象，然后把它赋值给r。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float fArea1 = computeArea1((Rect)&#123;3,2&#125;);   //生成临时对象并传值</span><br></pre></td></tr></table></figure>

<p>第22行：使用复合字面量做为函数的实际参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float fArea2 = computeArea2(&amp;(Rect)&#123;3,2&#125;);  //对临时对象取地址</span><br></pre></td></tr></table></figure>

<p>第23行：对复合字面量临时对象取地址，传地址调用函数。</p>
<h3 id="11-4-结构对象数组"><a href="#11-4-结构对象数组" class="headerlink" title="11.4 结构对象数组"></a>11.4 结构对象数组</h3><p>对于编译器而言， 下述两个数组本质相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct Employee a[3];</span><br><span class="line">int b[3];</span><br></pre></td></tr></table></figure>

<p>a，b都是3个元素的数组，其数组名均为数组首元素的地址。唯一的区别是，a中的元素类型为struct Employee，b的元素类型则为int。</p>
<p>下述C语言程序演示了结构对象数组的使用语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">typedef enum &#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125; GenderType;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[20];     //姓名</span><br><span class="line">    int  iSalary;       //月薪</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">&#125; Employee;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Employee es0[3] = &#123; //3个数组元素初始化，提供3个复合字面量</span><br><span class="line">        &#123;&quot;Jack Ma&quot;, 9000, male&#125;,</span><br><span class="line">        &#123;&quot;Dorothy Henry&quot;, 5000, female&#125;,</span><br><span class="line">        &#123;&quot;Frank Bush&quot;, 6000, male&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Employee* es1 = (Employee*)calloc(3,sizeof(Employee));</span><br><span class="line">    for (int i=0;i&lt;3;i++)</span><br><span class="line">        es1[i] = es0[i];</span><br><span class="line"></span><br><span class="line">    es0[1].iSalary += 200;     //es0[1]指Dorothy</span><br><span class="line">    //es0.iSalary[1] += 200;   //错误语法</span><br><span class="line"></span><br><span class="line">    Employee* p = es1;</span><br><span class="line">    p++;               //p向右滑动一个对象，指向es1[1]，即Dorothy</span><br><span class="line">    p-&gt;iSalary += 200; //修改的是es1[1]，即Dorothy的Salary</span><br><span class="line"></span><br><span class="line">    printf(&quot;Name:  %s,  Salary: %d\n&quot;, es0[1].sName,es0[1].iSalary);</span><br><span class="line">    printf(&quot;Name:  %s,  Salary: %d\n&quot;, es1[1].sName,es1[1].iSalary);</span><br><span class="line"></span><br><span class="line">    free(es1);         //释放calloc取得的动态内存空间</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Name:  Dorothy Henry,  Salary: 5200</span><br><span class="line">Name:  Dorothy Henry,  Salary: 5200</span><br><span class="line">Employee es0[3] = &#123; //3个数组元素初始化，提供3个复合字面量</span><br><span class="line">    &#123;&quot;Jack Ma&quot;, 9000, male&#125;,</span><br><span class="line">    &#123;&quot;Dorothy Henry&quot;, 5000, female&#125;,</span><br><span class="line">    &#123;&quot;Frank Bush&quot;, 6000, male&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第16 ~ 20行：定义并初始化了包含3个Employee结构类型元素的数组es0。由于元素是结构对象，所以提供初始始的{ }内包含了3个复合字面量。请注意Employee是经由typedef定义的结构类型，在使用时可以省略前边的struct关键字。es0数组属于自动变量，其内存分配在栈里，生命周期由编译器负责管理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee* es1 = (Employee*)calloc(3,sizeof(Employee));</span><br></pre></td></tr></table></figure>

<p>第22行：通过calloc( )函数在堆里申请了3个sizeof(Employee)的空间，然后赋值给指针es1。根据第6章中的讨论，指向Employee对象的指针es1，可以当成数组名使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;3;i++)</span><br><span class="line">    es1[i] = es0[i];</span><br></pre></td></tr></table></figure>

<p>第23 ~ 24行：通过循环，把数组es0中的三个结构体对象赋值给es1“数组”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">es0[1].iSalary += 200;     //es0[1]指Dorothy</span><br><span class="line">//es0.iSalary[1] += 200;   //错误语法</span><br></pre></td></tr></table></figure>

<p>第26 ~ 27行：es0是包含Employee对象的数组的数组名，es0[1]即为该数组下标为1的元素，它是一个结构体对象。es0[1].iSalary即为该结构对象的iSalary成员，本例中，指Dorothy的Salary。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee* p = es1;</span><br><span class="line">p++;               //p向右滑动一个对象，指向es1[1]，即Dorothy</span><br><span class="line">p-&gt;iSalary += 200; //修改的是es1[1]，即Dorothy的Salary</span><br></pre></td></tr></table></figure>

<p>第29 ~ 31行：按第6章指针运算部分的讨论，p++并不是把p的值（地址）加1，而是增加一个sizeof(Employee)。p++执行后，p事实上指向es1”数组“的下标1的元素，即Dorothy。p-&gt;iSalary即为p所指向的结构体对象Dorothy的iSalary成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Name:  %s,  Salary: %d\n&quot;, es0[1].sName,es0[1].iSalary);</span><br><span class="line">printf(&quot;Name:  %s,  Salary: %d\n&quot;, es1[1].sName,es1[1].iSalary);</span><br></pre></td></tr></table></figure>

<p>第33 ~ 34行：分别打印es0，es1数组的第1个元素的sName及iSalary。执行结果反应了前述数据修改的成果，Dorothy的工资由5000变成了5200。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(es1);         //释放calloc取得的动态内存空间</span><br></pre></td></tr></table></figure>

<p>第36行：释放通过calloc( )函数申请的堆空间。请注意，上述程序中，作者为了演示指向Employee的指针运算（p++），有意新增了一个指针变量p，而没有直接对es1++。这很重要，动态内存的地址宜妥善保管，因为它们是内存收回（free, delete）的唯一依据。</p>
<h3 id="11-5-结构的嵌套"><a href="#11-5-结构的嵌套" class="headerlink" title="11.5 结构的嵌套"></a>11.5 结构的嵌套</h3><p>前述结构体包含了char[ ]、bool、int等各种类型的数据成员。当一个结构的成员类型也是一个结构时，称为结构的嵌套。下述C语言程序演示了一个结构嵌套的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Project - CircleStruct</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Point &#123; //平面上的一个点，(x,y)为坐标</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    struct Point ptCenter;  //圆心</span><br><span class="line">    float fRadius;          //半径</span><br><span class="line">&#125; Circle;</span><br><span class="line"></span><br><span class="line">void horizontalMove(Circle* c, int offset)&#123;</span><br><span class="line">    c-&gt;ptCenter.x += offset; //圆在水平方向上移动offset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Circle c = &#123;&#123;0,100&#125;,4.1F&#125;;</span><br><span class="line"></span><br><span class="line">    c.ptCenter = (struct Point)&#123;0,0&#125;;</span><br><span class="line">    c.ptCenter.y = 0;</span><br><span class="line"></span><br><span class="line">    horizontalMove(&amp;c, -12);</span><br><span class="line"></span><br><span class="line">    printf(&quot;center = (%d, %d), radius = %f&quot;,</span><br><span class="line">           c.ptCenter.x, c.ptCenter.y, c.fRadius);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">center = (-12, 0), radius = 4.100000</span><br></pre></td></tr></table></figure>

<p>第4 ~ 12行：定义了一个Circle类型的结构，其包含两个成员，分别是圆心ptCenter以及半径fRadius。其中，ptCenter的类型为Point结构，这属于结构嵌套的范畴。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c = &#123;&#123;0,100&#125;,4.1F&#125;;</span><br></pre></td></tr></table></figure>

<p>第19行：定义并初始化了Circle结构对象c。请注意{ }包裹的初始值的格式，其中，{0,100}部分用于初始化c的ptCenter成员，4.1F用于初始化fRadius成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.ptCenter = (struct Point)&#123;0,0&#125;;</span><br></pre></td></tr></table></figure>

<p>第21行：c.ptCenter代表c的ptCenter成员，而该成员是Point结构类型的对象，可以直接把一个struct Point类型的复合字面量赋值给它。该赋值完成后，ptCenter的x和y成员都被置为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.ptCenter.y = 0;</span><br></pre></td></tr></table></figure>

<p>第22行：c.ptCenter.y代表c的ptCenter成员的y成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">horizontalMove(&amp;c, -12);</span><br></pre></td></tr></table></figure>

<p>第24行：调用horizontalMove( )函数将c横向移动-12个坐标单位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void horizontalMove(Circle* c, int offset)&#123;</span><br><span class="line">    c-&gt;ptCenter.x += offset; //圆在水平方向上移动offset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 16行：形参c是一个指针，它指向被移动的Circle对象，offset代表移动偏移量。c-&gt;ptCenter.x代表指针c所指向的结构对象的ptCenter成员的x成员。由于这个函数预期要修改c所指向的圆，因此c的类型定义为Circle<em>，而不是const Circle</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;center = (%d, %d), radius = %f&quot;,</span><br><span class="line">       c.ptCenter.x, c.ptCenter.y, c.fRadius);</span><br></pre></td></tr></table></figure>

<p>第26 ~ 27行：打印c的值。从执行结果看，调用horizontalMove( )函数对c的横向移动是成功的，其圆心坐标变成了(-12, 0)。</p>
<h3 id="11-6-柔性数组成员"><a href="#11-6-柔性数组成员" class="headerlink" title="11.6 柔性数组成员**"></a>11.6 柔性数组成员**</h3><p>考虑如下问题： 我们试图定义一个名为Student的结构，这个结构应包括学生的姓名，学生已修课程的数量以及已修课程各科的分数。</p>
<p>实践中，每个学生已修课程的数目是不一样的，这使得我们在定义用于存储分数的结构成员时面临两难的局面：</p>
<ul>
<li>如果将该数组定义得比较小，会存在某学生所修课程数量较多，存不下的情况。</li>
<li>如果将该数组定义得很大，比如10000，则对于大多数学生而言，内存空间浪费严重。而且， 无论将该数组定义得再大，理论上都存在实际数据超量，存不下的可能。</li>
</ul>
<p>解决方案之一是把分数数组成员定义为一个指向float的指针，如下述C语言代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - StudentScores</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[20]; //学生姓名</span><br><span class="line">    int  n;         //已修课程数量</span><br><span class="line">    float* scores;  //指针作为结构成员，分数数组</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Student s = &#123;&quot;Dorothy Henry&quot;, 4, NULL&#125;;</span><br><span class="line">    printf(&quot;sizeof(s) = %lld, sizeof(s.sName) = %lld, &quot;</span><br><span class="line">           &quot;sizeof(s.n) = %lld, sizeof(s.scores) = %lld\n&quot;,</span><br><span class="line">           sizeof(s),sizeof(s.sName),sizeof(s.n),sizeof(s.scores));</span><br><span class="line"></span><br><span class="line">    s.scores = calloc(s.n,sizeof(float));</span><br><span class="line"></span><br><span class="line">    s.scores[0] = 80;  s.scores[1] = 90; s.scores[2] = 90; s.scores[3] = 80;</span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (int i=0;i&lt;s.n;i++)</span><br><span class="line">        fSum += s.scores[i];</span><br><span class="line">    printf(&quot;Average score of %s: %f&quot;,s.sName,fSum/s.n);</span><br><span class="line"></span><br><span class="line">    free(s.scores);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(s) = 32, sizeof(s.sName) = 20, sizeof(s.n) = 4, sizeof(s.scores) = 8</span><br><span class="line">Average score of Dorothy Henry: 85.000000</span><br></pre></td></tr></table></figure>

<p>第5 ~ 9行：定义了Student结构，其包含3个数据成员，分别是20个字节的学生姓名sName，4个字节的已修课程数量n，8个字节的分数”数组“指针scores。其3个成员的字节数相加，等于一个Student对象的尺寸32个字节。</p>
<p>对于Student结构而言，scores跟其它成员一样，只是数据成员，只不过类型特殊，是float*。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s = &#123;&quot;Dorothy Henry&quot;, 4, NULL&#125;;</span><br></pre></td></tr></table></figure>

<p>第12行：s对象的初始化中，将s.n初始化为4，s.scores初始化为空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.scores = calloc(s.n,sizeof(float));</span><br></pre></td></tr></table></figure>

<p>第17行：s.scores只是一个指针，要往s.scores”数组“里存分数前，需要手动申请需要的内存空间。这行代码为其申请了s.n，即4个float的空间。必要时，如果希望往s.scores“数组”中存入超过4个的分数，可以通过realloc( )函数重新调整其动态内存的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s.scores[0] = 80;  s.scores[1] = 90; s.scores[2] = 90; s.scores[3] = 80;</span><br><span class="line">float fSum = 0;</span><br><span class="line">for (int i=0;i&lt;s.n;i++)</span><br><span class="line">    fSum += s.scores[i];</span><br><span class="line">printf(&quot;Average score of %s: %f&quot;,s.sName,fSum/s.n);</span><br></pre></td></tr></table></figure>

<p>第19 ~ 23行：在分配了内存空间之后，s.scores指针便可以当成”数组“来使用。使用过程中，程序员会注意避免下标越界。这几行代码先把4个分数填入s.scores”数组”，然后再计算平均分并打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(s.scores);</span><br></pre></td></tr></table></figure>

<p>第25行：释放calloc( )申请的动态内存。</p>
<p>这种使用指针成员来管理不定尺寸空间的方法需要程序员手动申请及释放内存，程序会变得比较零散。另外一个解决方案是使用结构的柔性数组成员（flexible array member）。请阅读下述C语言程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Project - FlexMember</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[20];  //学生姓名</span><br><span class="line">    int  n;          //已修课程数量</span><br><span class="line">    float scores[];  //柔性数组成员必须是结构的最后一个成员</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    unsigned int nBytes = sizeof(Student) + 4*sizeof(float);</span><br><span class="line">    Student* s = malloc(nBytes);</span><br><span class="line">    printf(&quot;sizeof(*s) = %lld, sizeof(s-&gt;sName) = %lld, &quot;</span><br><span class="line">           &quot;sizeof(s-&gt;n) = %lld, nBytes = %lld\n&quot;,</span><br><span class="line">           sizeof(*s),sizeof(s-&gt;sName),sizeof(s-&gt;n), nBytes);</span><br><span class="line"></span><br><span class="line">    printf(&quot;s = %p, s-&gt;scores = %p\n&quot;, s, s-&gt;scores);</span><br><span class="line"></span><br><span class="line">    s-&gt;n = 4;</span><br><span class="line">    s-&gt;scores[0] = 80;  s-&gt;scores[1] = 90; s-&gt;scores[2] = 90; s-&gt;scores[3] = 80;</span><br><span class="line">    float fSum = 0;</span><br><span class="line">    for (int i=0;i&lt;s-&gt;n;i++)</span><br><span class="line">        fSum += s-&gt;scores[i];</span><br><span class="line">    printf(&quot;Average score: %f&quot;,fSum/s-&gt;n);</span><br><span class="line"></span><br><span class="line">    free(s);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sizeof(*s) = 24, sizeof(s-&gt;sName) = 20, sizeof(s-&gt;n) = 4, nBytes = 40</span><br><span class="line">s = 0000000000711480, s-&gt;scores = 0000000000711498</span><br><span class="line">Average score: 85.000000</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char sName[20];  //学生姓名</span><br><span class="line">    int  n;          //已修课程数量</span><br><span class="line">    float scores[];  //柔性数组成员必须是结构的最后一个成员</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure>

<p>第5 ~ 9行：scores数组成员即为Student结构的柔性数组成员。柔性数组成员的定义要满足如下要求。</p>
<ul>
<li>该成员必须是结构的最后一个成员；</li>
<li>该成员在语法上定义了一个不指定元素数量的“空”数组。</li>
</ul>
<p>事实上，对于一个Student类型的对象而言， 只有sName及n成员会被分配空间，scores成员是不占空间的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int nBytes = sizeof(Student) + 4*sizeof(float);</span><br><span class="line">Student* s = malloc(nBytes);</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：现假设我们要存4门课程的分数，通过一个Student的对象大小加上4个float的对象大小得到需要的内存字节数nBytes。然后，通过malloc( )函数分配nBytes的堆空间，并把地址传给指针s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(*s) = %lld, sizeof(s-&gt;sName) = %lld, &quot;</span><br><span class="line">       &quot;sizeof(s-&gt;n) = %lld, nBytes = %lld\n&quot;,</span><br><span class="line">       sizeof(*s),sizeof(s-&gt;sName),sizeof(s-&gt;n), nBytes);</span><br></pre></td></tr></table></figure>

<p>第14 ~ 16行：通过执行结果可以看到，sName成员占20个字节，n成员占4个字节。虽然我们事实上给s所指向的Student对象申请了nBytes &#x3D; 40个字节的空间，但在编译器看来，*s，即s所指向的Student对象的大小只有24个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;s = %p, s-&gt;scores = %p\n&quot;, s, s-&gt;scores);</span><br></pre></td></tr></table></figure>

<p>第18行：把s，s-&gt;scores按地址格式输出。根据执行结果，我们可以画出该Student对象的内存结构图11- 。</p>
<p><img src="http://codelearn.club/images/image-20200310153953618.png" alt="image-20200310153953618"></p>
<p>图11- 带柔性数组成员的Student对象的内存结构</p>
<p>如果把s-&gt;scores的地址值减去s的地址值，差为24 &#x3D; sizeof(Student)。这说明，结构的柔性数组成员事实上是一个指针，它指向紧随该对象的内存地址，其值**恒等于对象地址+sizeof(类型)**。换句话说：如果我们实际分配给结构对象的空间大于sizeof(Student)，那么多出来的内存可以通过其柔性数组成员来访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1;</span><br><span class="line">printf(&quot;\n%p - %p&quot;,&amp;s1,s1.scores);</span><br></pre></td></tr></table></figure>

<p>如果我们直接定义类型为Student的变量s1，编译器会为s1分配sizeof(Student) &#x3D; 24个字节的空间。但即便如此，s1.scores仍然会等于s1的地址+24。如果我们强行通过s1.scores进行数据访问，事实上访问的是不属于s1对象的空间，这是程序员需要小心避免的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;n = 4;</span><br><span class="line">s-&gt;scores[0] = 80;  s-&gt;scores[1] = 90; s-&gt;scores[2] = 90; s-&gt;scores[3] = 80;</span><br><span class="line">float fSum = 0;</span><br><span class="line">for (int i=0;i&lt;s-&gt;n;i++)</span><br><span class="line">    fSum += s-&gt;scores[i];</span><br><span class="line">printf(&quot;Average score: %f&quot;,fSum/s-&gt;n);</span><br></pre></td></tr></table></figure>

<p>第20 ~ 25行：给s的柔性数组成员赋值，然后计算平均分并打印。由于我们确信s-&gt;scores所对应的内存空间属于s指向的结构对象，上述操作是安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(s);</span><br></pre></td></tr></table></figure>

<p>第27行：一定不要忘了释放动态分配的内存空间。</p>
<p>请读者注意，将带有柔性数组成员的结构对象赋值给另外一个同类型对象是危险的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1;</span><br><span class="line">s1 = *s;      //*s是存有4个分数的占40个字节空间的结构对象</span><br></pre></td></tr></table></figure>

<p>对于编译器而言，s1和<em>s都只有sizeof(Student) &#x3D; 24字节的空间。从</em>s到s1的赋值，只会拷贝前24个字节。同样的危险也会发生在函数传值时，函数的传值，可以认为是从实际参数到形式参数的赋值。</p>
<p>【？缺： 结构体内带函数指针成员，模仿C++中的类】</p>
<h2 id="12-编译及构建"><a href="#12-编译及构建" class="headerlink" title="12. 编译及构建"></a>12. 编译及构建</h2><p>【？缺】</p>
<p>【？ 危险的宏】</p>
<h2 id="13-类与抽象"><a href="#13-类与抽象" class="headerlink" title="13. 类与抽象"></a>13. 类与抽象</h2><p>在程序设计语言的早期（1990年以前），大多数的程序设计都采用<strong>结构化编程</strong>：程序中遍布着全局函数、数组以及变量。从1990年代起，<strong>面向对象程序设计</strong>（Object Oriented Programming） 逐渐成为主流。</p>
<p>面向对象程序设计属于<strong>【C++】</strong>的内容。从本章开始，除非特别说明，所述内容仅适用于C++。</p>
<h3 id="13-1-面向对象"><a href="#13-1-面向对象" class="headerlink" title="13.1 面向对象"></a>13.1 面向对象</h3><p><strong>本章只讨论一件事情：如何定义和使用新的数据类型。</strong>面向对象程序设计可以在程序设计的过程中模拟人类在现实世界的思维。</p>
<p>说到人本身，人是个概念也是个名词， 我们称“人”是一个类（class），以区别于大象、手机和彗星。具体到程序设计的范畴，类和数据类型（data type）是同义词。</p>
<p>一个具体的人，例如你、我、Mr Lee，是人这个概念的外延，是若干个类型为“人”的具体对象（Object）。我们也称某个具体的对象，例如Mark Zackberg，为“人”这个类型的实例（instance）。在面向对象程序设计语言中，变量（variable）、对象（object）以及实例（instance）这3个术语的含义大致相同。</p>
<p>凡是人类，皆有姓名、性别、血压、肤色、身高、体重等性质，这些性质被称为类型的<strong>属性</strong>（attribute），有时也称为<strong>数据成员</strong>（data member）。</p>
<p>人除了具备上述身高、肤色等属性外，还能做很多事情，例如说话（speak）、进食（eat）、思考（think）、走路（walk），这些行为是这个类型的<strong>方法</strong>（method），也可以称为<strong>成员函数</strong>（member function）。</p>
<p>在程序设计中，我们通过设计新的类型来刻画某类对象的共性，例如，定义一个新类（Person）。然后将这个类型实例化成一个对象，例如定义一个Person类型的变量a。 a既然属于Person类型，那么a自然就有了姓名、性别这些属性，有了eat、speak、think这些方法。</p>
<p>为了避免把读者搞糊涂，我们专门列了几个表格来总结上述术语。</p>
<p>表13- 类与数据类型的关系</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>同义术语</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>类(class)</td>
<td>数据类型(data type)</td>
<td>Person（表示人，需要自定义）、 char、int、float</td>
</tr>
</tbody></table>
<p>表13- 中，自定义的新类型Person与字符、整数这些系统提供的类型并列。在面向对象程序设计的范畴中，它们都是数据类型，其区别在于，有的是系统自带的，而有的（如Person），需要自定义。</p>
<p>表13- 则总结了对象、属性和方法的各种同义术语。</p>
<p>表13- 对象及其相关术语</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>同义术语</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>对象（object）</td>
<td>变量（variable） 实例（instance）</td>
<td>Person p1 ， int i &#x3D; 3， float f {3.14}； 这里的p1、i、以及f都是对象，区别仅在于他们所属的类型不同，p1类型是Person，是Person类型的实例（instance），i类型是int，是int类型的实例。</td>
</tr>
<tr>
<td>属性(attribute)</td>
<td>数据成员（data member）</td>
<td>Person::sName（人的姓名）， Person::iAge（人的年龄）， 数组的长度，浮点数的值</td>
</tr>
<tr>
<td>方法（method）</td>
<td>成员函数（member function）</td>
<td>Person::speak（人说话），Person::eat（人进食），float(3)（将整数3转换成float对象）</td>
</tr>
</tbody></table>
<p>还有一个术语有必要提及，执行一个对象的方法，也称为向这个对象发送一个<strong>消息</strong>（message）。这正如你为晚归的室友准备了霄夜时，无论是通过语言，或是表情，你肯定会向室友发送消息：收下这碗爱心！</p>
<p>在本书的后续部分，将频繁使用下述三个操作符，现列表予以解释。</p>
<p>表13- 三个操作符</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>域解析符 <strong>::</strong></td>
<td>Person::sName</td>
<td>表示Person类型的sName成员。</td>
</tr>
<tr>
<td>成员运算符 <strong>.</strong></td>
<td>peter.sName</td>
<td>peter对象的sName成员。其中，peter的类型为Person。</td>
</tr>
<tr>
<td>指向运算符 <strong>-&gt;</strong></td>
<td>dora-&gt;sName</td>
<td>指针dora指向的Person对象的sName成员。其中，dora的类型为Person*。</td>
</tr>
</tbody></table>
<h3 id="13-2-创建类"><a href="#13-2-创建类" class="headerlink" title="13.2 创建类"></a>13.2 创建类</h3><p>回到人的案例，我们可以用类图（class diagram）来描述人这个类型的概要，见图13- 。这个类图属于统一建模语言 (<strong>U</strong>nified <strong>M</strong>odeling <strong>L</strong>anguage)的范畴。我们知道，“人”其实还有很多别的属性和方法，比如头发颜色、思考、走路、开车之类，到底要在程序里描述这个类型的哪些属性和方法，以及描述到什么程度，取决于应用软件的实际需要。在一个图书馆管理系统里，我们需要知道这个人的ID和姓名，他的血压通常不是系统所关心的。在一个医疗档案系统里，我们多半需要记录这个人的血压甚至血压变化的过程及细节。</p>
<p><img src="http://codelearn.club/images/image-20200311111013354.png" alt="image-20200311111013354"></p>
<p>图13- Person类图</p>
<p>有了这个图纸，我们就可以照图施工，当然，是先画图还是直接施工，决定权在你。下述C++代码定义实现了图13- 所述的Person类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//Project - SimplePerson</span><br><span class="line">enum class GenderType&#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;           //姓名</span><br><span class="line">    string sID;             //身份证号</span><br><span class="line">    GenderType gender = GenderType::male; //性别</span><br><span class="line">    int iWeight &#123;50000&#125;;    //体重，以克为单位</span><br><span class="line"></span><br><span class="line">    Person(const string&amp; id = &quot;N/A&quot;, const string&amp; name = &quot;N/A&quot; )&#123;</span><br><span class="line">        sID = id;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Person::Person(), sName = &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void speak()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::speak()&quot; &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; &quot;I am &quot; &lt;&lt; sName &lt;&lt;&quot;, Nice to meet you here.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        iWeight += weight;</span><br><span class="line">        cout &lt;&lt; &quot;I just ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string description()&#123;</span><br><span class="line">        char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">        sprintf(buffer,&quot;ID:     %s\nName:   %s\nGender: %s\nWeight: %d&quot;,</span><br><span class="line">                sID.c_str(),sName.c_str(),</span><br><span class="line">                gender==GenderType::male?&quot;Male&quot;:&quot;Female&quot;,iWeight);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  //注意末尾的分号不能少</span><br></pre></td></tr></table></figure>

<p>第6行以class开始的代码块定义了一个名为Person的新数据类型。C++里定义一个新类的语法格式大体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">	类型 数据成员名称1;</span><br><span class="line">	...</span><br><span class="line">	类型 数据成员名称n;</span><br><span class="line"></span><br><span class="line">	返回值类型 成员函数名1(...);</span><br><span class="line">	...</span><br><span class="line">	返回值类型 成员函数名n(...);</span><br><span class="line">&#125;;  //注意末尾的分号不能少</span><br><span class="line">public:</span><br></pre></td></tr></table></figure>

<p>第7行：公有成员▲声明。在该声明之后定义的属性&#x2F;数据成员和方法&#x2F;成员函数都是公开的。公有成员的含义我们在14.2节中讨论。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string sName;           //姓名</span><br><span class="line">string sID;             //身份证号</span><br><span class="line">GenderType gender = GenderType::male; //性别</span><br><span class="line">int iWeight &#123;50000&#125;;    //体重，以克为单位</span><br></pre></td></tr></table></figure>

<p>第8 ~ 11行：定义了Person类的4个属性&#x2F;数据成员。 这意味着，一个Person类型的对象由4个分别名为sName、sID、gender和iWeight的子对象构成。其中，gender和iWeight指定了初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person(const string&amp; id = &quot;N/A&quot;, const string&amp; name = &quot;N/A&quot; )&#123;</span><br><span class="line">    sID = id;</span><br><span class="line">    sName = name;</span><br><span class="line">    cout &lt;&lt; &quot;Person::Person(), sName = &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第13 ~ 17行：定义了Person类型的<strong>构造函数（constructor）</strong>。构造函数是特殊的成员函数。</p>
<ul>
<li>构造函数的函数名与类型相同；</li>
<li>构造函数声明&#x2F;定义时返回值类型必须空缺 ；</li>
<li>当程序员没有为类型定义构造函数时，编译器会”内部“为该类生成一个零参数的，什么都不做构造函数；</li>
<li>当创建一个类的对象时，编译器会自动执行构造函数；</li>
<li>类定义中给属性指定的默认值到属性的赋值事实上是在构造函数中执行的。</li>
</ul>
<p>本例中，该构造函数包含了id（身份证号）及name（姓名）两个带默认值的形参。当创建Person类的对象时，如果不提供对应的实参，id和name将取默认值”N&#x2F;A”。函数体初始化了对象的4个属性，其中，sID和sName用形参赋值，gender赋值为男性，iWeight赋值为50000，即50Kg。最后，该构造函数还打印输出了一行字符，表明该函数的执行结果。第16行Person::Person( )，表示Person类型的成员函数Person( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void speak()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Person::speak()&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;I am &quot; &lt;&lt; sName &lt;&lt;&quot;, Nice to meet you here.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 22行：定义了成员函数speak( )，该函数无形参，无返回值，仅打印两行文字表示其执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void eat(int weight)&#123;</span><br><span class="line">    iWeight += weight;</span><br><span class="line">    cout &lt;&lt; &quot;I just ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第24 ~ 27行：定义了成员函数eat( )，形参weight表示该次进食的重量。作为进食的成果，进食的对象体重增加了weight。最后，函数打印一行文字表示其执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string description()&#123;</span><br><span class="line">    char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">    sprintf(buffer,&quot;ID:     %s\nName:   %s\nGender: %s\nWeight: %d&quot;,</span><br><span class="line">            sID.c_str(),sName.c_str(),</span><br><span class="line">            gender==GenderType::male?&quot;Male&quot;:&quot;Female&quot;,iWeight);</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第29 ~ 35行：定义了成员函数description( )。该函数返回Person对象的描述性字符串。由于C++的标准模板库没有提供占位符格式化功能，我们这里不得不使用C语言的sprintf( )函数来完成占位符格式化。与printf( )将格式化字符串打印输出不同，第31行的sprintf( )函数将格式化字符串保存在字符数组buffer当中。由于sprintf( )函数并不接受string类型的值，所以我们还需要将string类型的sID及sName通过其成员函数c_str( )转换成const char<em>，即C风格的字符数组供sprintf( )函数使用。c_str( )是string类型的成员函数，该函数将string对象内部的字符串内容转换成const char</em>。</p>
<p>在执行sprintf( )函数的过程中，需要保证用于存储结果字符串的字符数组足够大，否则，可能会因为下标超界而破坏其它数据。</p>
<p>第34行将字符数组buffer作为返回值返回。读者可能注意到，buffer的类型为char[ ]，而返回值类型为string，理论上两者类型不一致，应被编译器拒绝。但是，string类型存在一个构造函数，该构造函数可以通过char *（char [ ]）构造出一个string对象。编译器接受了这个选项，通过string类型的构造函数创建了一个临时的string对象，然后返回。当然，直接将第37行改成return string(buffer)，显式地调用string的构造函数将buffer转换成string对象也是可以的。</p>
<p>在<strong>【C++ 20】</strong>标准里，终于定义了标准模板库的占位符格式化功能。但因为本书写作时，绝大多数的编译器都还不支持C++ 20标准，只能选择忽略。</p>
<h3 id="13-3-创建对象"><a href="#13-3-创建对象" class="headerlink" title="13.3 创建对象"></a>13.3 创建对象</h3><p>在定义了新的类&#x2F;数据类型后，就可以通过实例化（instantialize）该类来创建该类对象了。下述C++程序使用了前节中定义的Person类型来构造对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - SimplePerson</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">...</span><br><span class="line">class Person&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person peter(&quot;3604020001&quot;, &quot;Peter Lee&quot;);</span><br><span class="line">    peter.eat(100);</span><br><span class="line">    peter.speak();</span><br><span class="line">    cout &lt;&lt; peter.description() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person dora;</span><br><span class="line">    dora.sID = &quot;3604020002&quot;;</span><br><span class="line">    dora.sName = &quot;Dora Henry&quot;;</span><br><span class="line">    dora.speak();</span><br><span class="line">    cout &lt;&lt; dora.description() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Person::Person(), sName = Peter Lee</span><br><span class="line">I just ate 100 gram&#x27;s food.</span><br><span class="line">Person::speak()</span><br><span class="line">I am Peter Lee, Nice to meet you here.</span><br><span class="line">ID:     3604020001</span><br><span class="line">Name:   Peter Lee</span><br><span class="line">Gender: Male</span><br><span class="line">Weight: 50100</span><br><span class="line">-----------------------------------------</span><br><span class="line">Person::Person(), sName = N/A</span><br><span class="line">Person::speak()</span><br><span class="line">I am Dora Henry, Nice to meet you here.</span><br><span class="line">ID:     3604020002</span><br><span class="line">Name:   Dora Henry</span><br><span class="line">Gender: Male</span><br><span class="line">Weight: 50000</span><br></pre></td></tr></table></figure>

<p>上述程序的main( )函数中，总共定义并使用了两个Person类型的对象，分别是peter和dora。这两个对象都是自动变量，均存储在栈里。<strong>两个对象各自拥有的数据成员分别存储在各自的存储空间之内，互不相关</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   Person peter(&quot;3604020001&quot;, &quot;Peter Lee&quot;);</span><br><span class="line">int i(0);</span><br></pre></td></tr></table></figure>

<p>第10行：定义了Person类型的对象peter。在语法上，上述peter对象的定义语法与整数i的定义语法没什么不同。</p>
<p>peter是Person类型的对象，第10行导致Person的构造函数Person::Person( )被执行，以”3604020001”，”Peter Lee”为参数。该构造函数的执行初始化了peter对象的数据成员。并导致了执行结果第1行的输出。</p>
<p>i是int类型的对象，int i(0)在语法上可以理解为以0为参数执行int类型的构造函数，该构造函数的执行初始化了int类型的对象i，将其值设置为0。当然，这只是语法上的解读，事实上对i的初始化只是一次简单的赋值，不会有真实的函数调用发生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peter.eat(100);</span><br></pre></td></tr></table></figure>

<p>第11行：执行peter对象的eat( )成员函数，以100为参数。显然，Peter吃东西应该只会导致Peter体重增加，跟Dora没关系，所以，eat( )函数所修改的iWeight数据成员对应的是Peter的iWeight。第11行代码对应执行结果的第2行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peter.speak();</span><br></pre></td></tr></table></figure>

<p>第12行：执行peter对象的speak( )方法。执行结果的第3 ~ 4行显示，说话的是Peter Lee，不是Dora。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; peter.description() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第13行：执行peter的description( )成员函数，并将返回的string对象输出给cout。执行结果的第5 ~ 8行即为对应的输出信息。可以看到，Peter的体重由50000变成了50100，因为在代码的第11行，Peter吃了100克的食物。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person dora;</span><br></pre></td></tr></table></figure>

<p>第17行：定义了Person类型的对象dora。本行代码也会调用Person的构造函数Person::Person( )来初始化dora对象，其参取值默认值”N&#x2F;A”。执行结果的第10行即为构造函数的输出，请注意结果中的姓名为”N&#x2F;A”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dora.sID = &quot;3604020002&quot;;</span><br><span class="line">dora.sName = &quot;Dora Henry&quot;;</span><br></pre></td></tr></table></figure>

<p>第18 ~ 19行：对dora对象的sID和sName数据成员进行赋值。因为dora是Person类型的对象，所以dora对象包含Person类型所定义的全部属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dora.speak();</span><br></pre></td></tr></table></figure>

<p>第20行：执行dora对象的speak( )函数。其输出对应执行结果的第11 ~ 12行，结果显示，说话的是Dora，不是Peter。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dora.description() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第21行：输出dora对象description( )成员函数返回的字符串，对应执行如果的第13 ~ 16行。请注意，输出的结果当中，Dora的体重仍为50000，因为Dora没有吃（eat）东西。</p>
<h3 id="13-4-内存故事"><a href="#13-4-内存故事" class="headerlink" title="13.4 内存故事"></a>13.4 内存故事</h3><p>关于对象的数据成员，请读者记住下述两个结论：</p>
<ul>
<li>每个对象拥有独立的存储空间，存储自己的数据成员。</li>
<li>相同类型的对象所拥有的数据成员，其类型、数量和名称相同。例如，dora和peter都是Person类型的对象，所以他们都有姓名、身份证号、性别、体重等属性。</li>
</ul>
<p>下述C++程序通过对一个Person对象的解析，来说明一个Person类型的对象是如何由其他子对象来构成，以及这些子对象是如何存储在一个Person对象的内部的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Project - PersonMemory</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">...</span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;       //姓名</span><br><span class="line">    string sID;         //身份证号</span><br><span class="line">    GenderType gender;  //性别</span><br><span class="line">    int iWeight;        //体重，以克为单位</span><br><span class="line">	...</span><br><span class="line">&#125;;  //注意末尾的分号不能少</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;sizeof(Person) = sizeof(string) x 2 + sizeof(GenderType) &quot;</span><br><span class="line">           &quot;+ sizeof(int)\n= %lld x 2 + %lld + %lld \n= %lld\n&quot;,</span><br><span class="line">           sizeof(string),sizeof(GenderType),sizeof(int),sizeof(Person));</span><br><span class="line"></span><br><span class="line">    Person a(&quot;3604020001&quot;, &quot;Peter Lee&quot;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;&amp;a         = %p, sizeof(a)        = %lld\n&quot;,</span><br><span class="line">           &amp;a, sizeof(a));</span><br><span class="line">    printf(&quot;&amp;a.sName   = %p, sizeof(a.sName)  = %lld\n&quot;,</span><br><span class="line">           &amp;a.sName, sizeof(a.sName));</span><br><span class="line">    printf(&quot;&amp;a.sID     = %p, sizeof(a.sID)    = %lld\n&quot;,</span><br><span class="line">           &amp;a.sID, sizeof(a.sID));</span><br><span class="line">    printf(&quot;&amp;a.gender  = %p, sizeof(a.gender) = %lld\n&quot;,</span><br><span class="line">           &amp;a.gender, sizeof(a.gender));</span><br><span class="line">    printf(&quot;&amp;a.iWeight = %p, sizeof(iWeight)  = %lld\n&quot;,</span><br><span class="line">           &amp;a.iWeight, sizeof(a.iWeight));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Person) = sizeof(string) x 2 + sizeof(GenderType) + sizeof(int)</span><br><span class="line">= 32 x 2 + 4 + 4</span><br><span class="line">= 72</span><br><span class="line">Person::Person(), sName = Peter Lee</span><br><span class="line">&amp;a         = 000000000062fd60, sizeof(a)        = 72</span><br><span class="line">&amp;a.sName   = 000000000062fd60, sizeof(a.sName)  = 32</span><br><span class="line">&amp;a.sID     = 000000000062fd80, sizeof(a.sID)    = 32</span><br><span class="line">&amp;a.gender  = 000000000062fda0, sizeof(a.gender) = 4</span><br><span class="line">&amp;a.iWeight = 000000000062fda4, sizeof(iWeight)  = 4</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。此外，不同的编译器下，string类型的大小，GenderType类型的大小也可能与本书不同。</p>
<p>第6 ~ 13行：一个Person类型的对象，依次包含sName、sID、gender及iWeight共4个数据成员，其类型分别为string、string、GenderType和int。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(Person) = sizeof(string) x 2 + sizeof(GenderType) &quot;</span><br><span class="line">       &quot;+ sizeof(int)\n= %lld x 2 + %lld + %lld \n= %lld\n&quot;,</span><br><span class="line">       sizeof(string),sizeof(GenderType),sizeof(int),sizeof(Person));</span><br></pre></td></tr></table></figure>

<p>第16 ~ 18行：打印Person、string、GenderType及int类型的字节数。执行结果的第1 ~ 3行证实，一个Person对象的大小正好等于两个string对象、1个GenderType对象及1个int对象的大小之和。即，<strong>对象的尺寸等于构成该对象的全部子对象尺寸之和</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person a(&quot;3604020001&quot;, &quot;Peter Lee&quot;);</span><br></pre></td></tr></table></figure>

<p>第20行：定义Person类型的对象a，并调用Person::Person( )对a进行了初始化。</p>
<p>第22 ~ 31行：打印了a的全部数据成员的地址及大小。根据输出结果，我们绘制了对象a的内存结构，见图13- 。</p>
<p><img src="http://codelearn.club/images/image-20200312163548181.png" alt="image-20200312163548181"></p>
<p>图13- 对象a的内存结构</p>
<p>如图13- 所示，Person类型的对象a占据了从0x0062fd60开始的连续72个字节的空间。由于a属于自动变量，因此，其内存空间位于栈内。a的4个数据成员按定义顺序依次排列在这72个字节的空间内，其中，sName和sID各占32个字节，gender占4个字节，iWeight占4个字节。</p>
<p>如第5章所述，string类型的对象尺寸是固定的（如本例中的32个字节），但却可以存储几乎长度不限的字符串。其秘密在于：</p>
<ul>
<li>string对象内部并不存储实际的字符数组，对象内部所存储的只是用于管理实际字符数组的数据结构，例如指向实际字符数组的指针；</li>
<li>string对象将实际的字符数组安排在堆（heap）里，并使用对象内部的指针指向申请的动态内存。此外，string对象还会根据实际存储的字符串的长度来动态调整所占用的堆空间，以避免浪费。</li>
</ul>
<p>从图13- 可见，a.sName，a.sID的实际字符串事实上并不在对象内部，而是在堆里。在作者的计算机上，sizeof(Person)以及sizeof(a)均为固定的72个字节，不论a.sName以及a.sID所包含的字符串实际有多长。也就是说，<strong>使用sizeof操作符获得的对象尺寸不包含对象动态创建的部分</strong>。</p>
<h3 id="13-5-隐藏的this指针"><a href="#13-5-隐藏的this指针" class="headerlink" title="13.5 隐藏的this指针"></a>13.5 隐藏的this指针</h3><p>Dora和Peter都是Person类型的对象，他们的属性各自独立，互不相关。但是，他们的行为却是相似的：无论是Dora，还是Peter，在吃完100克的食物后，体重都会增加100克。</p>
<p>显而易见，为Person类型的各个对象分别存储各种独立的成员函数代码是不必要且严重浪费的。事实上，无论是执行dora.eat( )还是peter.eat( )，执行的都是同一个函数Person::eat( )，程序通过一个秘密传递的this指针来区分吃东西的是Dora还是Peter，或者是其他人。</p>
<p>事实上，类型的每一个成员函数（静态成员函数除外▲），包括构造函数，都包含一个隐藏的名为this的形式参数，这个this参数为指向该类型的指针，用于指明被执行该成员函数的对象。</p>
<p>下述C++程序帮助我们理解this指针的工作机制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Project - ThisPerson</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;       //姓名</span><br><span class="line">    int iWeight;        //体重，以克为单位</span><br><span class="line"></span><br><span class="line">    Person()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::Person(), this = &quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">        this-&gt;sName = &quot;N/A&quot;; //sName = &quot;N/A&quot;;</span><br><span class="line">        this-&gt;iWeight = 50000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::eat(), this = &quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">        iWeight += weight;</span><br><span class="line">        //this-&gt;iWeight += weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  //注意末尾的分号不能少</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person tom;</span><br><span class="line">    Person dora;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;tom = &quot; &lt;&lt; &amp;tom &lt;&lt; &quot;, &amp;dora = &quot; &lt;&lt; &amp;dora &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tom.sName = &quot;Tom&quot;;</span><br><span class="line">    dora.sName = &quot;Dora&quot;;</span><br><span class="line">    dora.eat(100);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; tom.sName &lt;&lt; &quot;, Weight: &quot; &lt;&lt; tom.iWeight &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Name: &quot; &lt;&lt; dora.sName &lt;&lt; &quot;, Weight: &quot; &lt;&lt; dora.iWeight &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person::Person(), this = 0x61fde0</span><br><span class="line">Person::Person(), this = 0x61fdb0</span><br><span class="line">&amp;tom = 0x61fde0, &amp;dora = 0x61fdb0</span><br><span class="line">Person::eat(), this = 0x61fdb0</span><br><span class="line">Name: Tom, Weight: 50000</span><br><span class="line">Name: Dora, Weight: 50100</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person tom;</span><br><span class="line">Person dora;</span><br><span class="line">cout &lt;&lt; &quot;&amp;tom = &quot; &lt;&lt; &amp;tom &lt;&lt; &quot;, &amp;dora = &quot; &lt;&lt; &amp;dora &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第24 ~ 26行：定义并构建了两个Person类型的对象，分别是tom和dora；输出两个对象的地址。</p>
<p>事实上，tom和dora对象的构建包含如下过程：</p>
<ul>
<li>编译器生成的代码为对象分配存储空间，并取得地址；对象的存储空间固定为sizeof(Person)；</li>
<li>执行Person::Person( )构造函数，并将对象存储空间的地址作为this参数“秘密”地传递给构造函数；</li>
<li>构造函数以这个this指针为依据，访问并初始化对象的数据成员。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Person::Person(), this = &quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">    this-&gt;sName = &quot;N/A&quot;; //sName = &quot;N/A&quot;;</span><br><span class="line">    this-&gt;iWeight = 50000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 14行：在Person的构造函数里，第11行将那个秘密的this指针按地址格式输出，第12 ~ 13行则通过this指针初始化对象的数据成员。事实上，在成员函数内对本对象数据成员的访问，总是通过this指针进行的。具体到本例，this-&gt;sName与直接写sName等价，都指当前被构造的对象的sName数据成员。事实上，<strong>程序通过对象的地址再加上数据成员在对象内的偏移量来确定数据成员的地址</strong>。</p>
<p>本例中，tom的构造函数先执行，其输出对应执行结果的第1行。可以看到，tom构造函数中输出的this指针地址与执行结果第3行里tom对象的地址相同。同理，后执行的dora对象的构造函数中输出的this指针地址与dora对象的地址相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tom.sName = &quot;Tom&quot;;</span><br><span class="line">dora.sName = &quot;Dora&quot;;</span><br></pre></td></tr></table></figure>

<p>第28 ~ 29行：修改tom和dora的sName属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dora.eat(100);</span><br></pre></td></tr></table></figure>

<p>第30行：执行dora对象的eat( )方法。同理，eat( )成员函数也有秘密的this指针参数。本行代码事实上指明了要执行eat( )成员函数的对象，即dora。编译器会生成“秘密”代码，取得dora的地址并传递给Person::eat( )函数。读者可以按如下方式理解第30行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person::eat(&amp;dora, 100);    //示意代码，并非编译器认可的“合法”代码</span><br></pre></td></tr></table></figure>

<p>对于所有Person类型对象的eat( )方法，编译器调用的是同一个函数。该函数的第0个参数是被执行对象的地址，即this指针，第1个参数才是100。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void eat(int weight)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Person::eat(), this = &quot; &lt;&lt; this &lt;&lt; endl;</span><br><span class="line">    iWeight += weight;</span><br><span class="line">    //this-&gt;iWeight += weight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第16 ~ 20行：Person::eat( )函数中，我们也输出了this指针的地址。第18行的iWeight事实上是this-&gt;iWeight的简写形式，程序会自动地通过this指针来确定iWeight数据成员的真实地址并进行操作。执行结果的第4行显示，dora.eat( )函数所输出的this指针的值，就是dora对象的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; tom.sName &lt;&lt; &quot;, Weight: &quot; &lt;&lt; tom.iWeight &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Name: &quot; &lt;&lt; dora.sName &lt;&lt; &quot;, Weight: &quot; &lt;&lt; dora.iWeight &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第32 ~ 33行：输出tom和dora的姓名及体重。执行结果的第6行可见，作为吃了100克食物的结果，dora的体重变成了50100，而tom的体重仍为50000。</p>
<h3 id="13-6-析构函数"><a href="#13-6-析构函数" class="headerlink" title="13.6 析构函数"></a>13.6 析构函数</h3><p>构造函数（constructor）负责初始化新对象，<strong>析构函数（destructor）</strong>则负责在对象生命周期结束，其内存被释放<strong>前</strong>做清理（cleanup）工作：</p>
<ul>
<li>如果对象生命周期内申请了动态内存，尚未释放，可在析构函数中释放；</li>
<li>其他：保存尚未保存的数据；释放除内存之外的其它资源，比如网络连接等。</li>
</ul>
<p>只要对象被销毁，编译器会主动调用对象的析构函数并提供this指针表明被析构的对象。<strong>程序中不必也不能主动执行对象的析构函数</strong>。</p>
<p>为了简化程序，突出重点，我们设计了一个称为Fish的类，并为之设计了特殊的构造及析构函数，以便演示对象析构函数的“调用”方法。请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Project - Fish</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    Fish(const string&amp; name)&#123;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fish()&#123;</span><br><span class="line">        sName = &quot;N/A&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Fish()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Destructor called: &quot;  &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">        //同样存在this指针，sName事实上通过this指针访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Fish tom(&quot;tom&quot;);</span><br><span class="line">    Fish dora(&quot;dora&quot;);</span><br><span class="line">    Fish nameless;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fish Constructor called: tom</span><br><span class="line">Fish Constructor called: dora</span><br><span class="line">Fish Constructor called: N/A</span><br><span class="line">Fish Destructor called: N/A</span><br><span class="line">Fish Destructor called: dora</span><br><span class="line">Fish Destructor called: tom</span><br></pre></td></tr></table></figure>

<p>上述程序中，Fish类有两个构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish::Fish(const string&amp; name);</span><br><span class="line">Fish::Fish();</span><br></pre></td></tr></table></figure>

<p>一个有参数，一个零参数。其中，带参数的构造函数用形参name初始化Fish的名称（.sName），零参数构造函数则将Fish的名称初始化为N&#x2F;A。同名的多个成员函数也是一种函数名重载形式，编译器会根据构建对象时提供的实际参数来选择对应的构造函数并执行之。严格地说，Fish::Fish( )也不是零参数，因为它还有秘密参数this。这两个构造函数都向cout输出了表示构造函数被执行的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Fish()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Fish Destructor called: &quot;  &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    //同样存在this指针，sName事实上通过this指针访问</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第18 ~ 20行：定义了Fish类型的析构函数。</p>
<p>一个类型的析构函数应满足如下要求：</p>
<ul>
<li>析构函数名为<del>类型名，如本例中的</del>Fish；</li>
<li>构析函数必须为零参数，因为C++并不支持显式地调用执行对象析构函数，当然也不可能向析构函数传递除了this指针之外的其他参数；</li>
<li>析构函数不能有返回值；</li>
<li>每个类型只能有一个析构函数。</li>
</ul>
<p>本例中，Fish类型的析构函数~Fish( )只是打印了一行表示析构函数被执行的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fish tom(&quot;tom&quot;);</span><br><span class="line">Fish dora(&quot;dora&quot;);</span><br><span class="line">Fish nameless;</span><br></pre></td></tr></table></figure>

<p>第25 ~ 27行：顺序构建了tom鱼、dora鱼和无名（nameless）鱼。其中，tom鱼和dora鱼执行的是带参数的构造函数，无名鱼执行的是零参数的构造函数。三次构造函数的输出见执行结果的第1 ~ 3行。</p>
<p>到了main( )函数的结尾，tom、dora和nameless这3个对象的生命周期结束，在收缩栈指针释放这3个对象的内存前，程序会自动调用执行这3个对象的析构函数。按照第8章的讨论，nameless鱼最靠近栈顶，收缩栈顶指针时，理论上，最先释放nameless鱼的内存。所以，nameless鱼的析构函数先被执行，然后是dora鱼和tom鱼。一般地，自动变量的析构顺序与构造顺序相反。见执行结果的第4 ~ 6行。</p>
<h3 id="13-7-动态对象"><a href="#13-7-动态对象" class="headerlink" title="13.7 动态对象"></a>13.7 动态对象</h3><p>与语言原生的数据类型一样，自定义类型也可以通过new操作符来创建对象。请见下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//Project - NewFish</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    Fish(const string&amp; name)&#123;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fish()&#123;</span><br><span class="line">        sName = &quot;N/A&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Fish()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Destructor called:  &quot;  &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Fish tom = Fish(&quot;tom&quot;);    //等价于Fish tom(&quot;tom&quot;)</span><br><span class="line"></span><br><span class="line">    Fish* dora = new Fish(&quot;dora&quot;);</span><br><span class="line">    Fish* nameless = new Fish; //new Fish等价于new Fish()</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;&amp;tom = &quot; &lt;&lt; &amp;tom &lt;&lt; &quot;, dora = &quot; &lt;&lt; dora</span><br><span class="line">         &lt;&lt; &quot;, nameless = &quot; &lt;&lt; nameless &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;3 Fish objects: &quot; &lt;&lt; tom.sName &lt;&lt; &quot;,  &quot;</span><br><span class="line">         &lt;&lt; dora-&gt;sName &lt;&lt; &quot;,  &quot; &lt;&lt; nameless-&gt;sName &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    delete dora;</span><br><span class="line">    delete nameless;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fish Constructor called: tom</span><br><span class="line">Fish Constructor called: dora</span><br><span class="line">Fish Constructor called: N/A</span><br><span class="line">---------------------------------</span><br><span class="line">&amp;tom = 0x61fd80, dora = 0x1f1790, nameless = 0x1f1b00</span><br><span class="line">3 Fish objects: tom,  dora,  N/A</span><br><span class="line">---------------------------------</span><br><span class="line">Fish Destructor called:  dora</span><br><span class="line">Fish Destructor called:  N/A</span><br><span class="line">Fish Destructor called:  tom</span><br><span class="line">Fish tom = Fish(&quot;tom&quot;);    //等价于Fish tom(&quot;tom&quot;)</span><br></pre></td></tr></table></figure>

<p>第24行：构建了栈对象tom。如注释所示，这种写法的实际效果与Fish tom(“tom”)等同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish* dora = new Fish(&quot;dora&quot;);</span><br><span class="line">Fish* nameless = new Fish; //new Fish等价于new Fish()</span><br></pre></td></tr></table></figure>

<p>第26 ~ 27行：第26行代码的执行过程简述如下。</p>
<ul>
<li>在栈内为作为自动对象的指针dora分配空间；</li>
<li>new操作符通过操作系统API申请sizeof(Fish)大小的堆空间并取得地址；</li>
<li>以上述对象地址为this指针，调用执行构造函数Fish::Fish(const string&amp; name)，初始化该对象；</li>
<li>将对象地址赋值给指针dora。</li>
</ul>
<p>nameless鱼的构建过程类似，唯一区别在于执行的是零参数的构造函数Fish::Fish( )。三次构造函数的输出请见执行结果的第1 ~ 3行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;&amp;tom = &quot; &lt;&lt; &amp;tom &lt;&lt; &quot;, dora = &quot; &lt;&lt; dora</span><br><span class="line">     &lt;&lt; &quot;, nameless = &quot; &lt;&lt; nameless &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;3 Fish objects: &quot; &lt;&lt; tom.sName &lt;&lt; &quot;,  &quot;</span><br><span class="line">     &lt;&lt; dora-&gt;sName &lt;&lt; &quot;,  &quot; &lt;&lt; nameless-&gt;sName &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第30 ~ 33行：输出3个Fish对象的地址及3条鱼的姓名。tom.sName表示tom鱼对象的sName数据成员；dora-&gt;sName表示dora指针指向的鱼对象的sName数据成员。</p>
<p>执行结果的第5行证实，dora鱼和nameless鱼的地址很近，它们都在堆里；tom鱼的地址与dora鱼相去甚远，它在栈里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete dora;</span><br><span class="line">delete nameless;</span><br></pre></td></tr></table></figure>

<p>第36 ~ 37行：第36行的执行过程简述如下。</p>
<ul>
<li>如果dora指针为空，直接返回；</li>
<li>由于dora的类型为Fish*，程序调用执行Fish类型的析构函数Fish::~Fish( )，以dora为this指针，以完成dora鱼对象的清理（cleanup）工作；</li>
<li>通过操作系统API释放dora指向的动态内存。</li>
</ul>
<p>请注意，第36行执行结束后，dora仍然是一个有值非空的指针。谨慎起见，我们建议程序员随后将其置为空，以免误用。</p>
<p>如果不delete dora，会导致两个后果：</p>
<ul>
<li>对象的析构函数不会被执行；</li>
<li>内存不会被释放，造成泄漏。</li>
</ul>
<p>执行结果的第8 ~ 9行证实，因为dora先释放，所以dora鱼的析构输出早于nameless鱼的析构输出。</p>
<p>同样地，自动变量tom的析构与内存回收由编译器生成指令来保证。在输出结果的最后，我们看到了tom鱼的析构输出。</p>
<h3 id="13-8-对象数组"><a href="#13-8-对象数组" class="headerlink" title="13.8 对象数组"></a>13.8 对象数组</h3><p>与语言原生的数据类型一样，自定义类型也可以创建对象数组。请见下述C++示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//Project - FishArray</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">public:</span><br><span class="line">    int iNumber;</span><br><span class="line">    Fish()&#123;</span><br><span class="line">        static int iCounter = 0; //静态对象可以在函数的多次调用间保存其值</span><br><span class="line">        iNumber = iCounter++;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; iNumber &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Fish()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Destructor called:  &quot;  &lt;&lt; iNumber &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Fish stackFishes[3];</span><br><span class="line">    for (auto&amp; f:stackFishes)</span><br><span class="line">        cout &lt;&lt; f.iNumber &lt;&lt; &quot;, &quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;\n---------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Fish* heapFishes = new Fish[4];  //也可写作new Fish[4]()</span><br><span class="line">    cout &lt;&lt; heapFishes[0].iNumber &lt;&lt; &quot;, &quot; &lt;&lt; heapFishes[1].iNumber &lt;&lt; &quot;, &quot;</span><br><span class="line">         &lt;&lt; heapFishes[2].iNumber &lt;&lt; &quot;, &quot; &lt;&lt; heapFishes[3].iNumber &lt;&lt; endl;</span><br><span class="line">    delete []heapFishes;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Fish Constructor called: 0</span><br><span class="line">Fish Constructor called: 1</span><br><span class="line">Fish Constructor called: 2</span><br><span class="line">0, 1, 2,</span><br><span class="line">---------------------------------------</span><br><span class="line">Fish Constructor called: 3</span><br><span class="line">Fish Constructor called: 4</span><br><span class="line">Fish Constructor called: 5</span><br><span class="line">Fish Constructor called: 6</span><br><span class="line">3, 4, 5, 6</span><br><span class="line">Fish Destructor called:  6</span><br><span class="line">Fish Destructor called:  5</span><br><span class="line">Fish Destructor called:  4</span><br><span class="line">Fish Destructor called:  3</span><br><span class="line">--------------------------------------</span><br><span class="line">Fish Destructor called:  2</span><br><span class="line">Fish Destructor called:  1</span><br><span class="line">Fish Destructor called:  0</span><br></pre></td></tr></table></figure>

<p>第9行：iCounter是位于Fish构造函数之内的静态对象。</p>
<ul>
<li>iCounter被初始化为0的赋值操作只会进行一次；</li>
<li>iCounter的生命周期一直持续在程序运行结束， 它可以在多次函数调用间保持其值；</li>
<li>Fish::Fish( )借助于iCounter为每条鱼生成一个递增的编号并存入iNumber属性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fish stackFishes[3];</span><br></pre></td></tr></table></figure>

<p>第20行：除了类型不同外，本行的语法等同于int a[3]。stackFishes是包含三个元素的栈内数组，其构建过程包含如下步骤。</p>
<ul>
<li>程序在栈内分配3个sizeof(Fish)大小的空间；</li>
<li>从下标0开始至最后一个元素，从前往后逐一调用Fish类型的构造函数Fish::Fish( )，以元素地址为this指针，初始化每一个元素对象。</li>
</ul>
<p>执行结果的第1 ~ 3行对应上述构造函数的输出。可以看到，3条鱼的编号依次为0，1，2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; f:stackFishes)</span><br><span class="line">    cout &lt;&lt; f.iNumber &lt;&lt; &quot;, &quot;;</span><br></pre></td></tr></table></figure>

<p>第21 ~ 22行：遍历stackFishes数组，打印每条鱼的编号。执行结果的第4行证实，3个数组元素的构造顺序确实是从下标0开始从前往后顺序进行的。请读者注意这里的循环元素f的类型为Fish&amp;，而不是Fish，以避免从数组元素到f的赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fish* heapFishes = new Fish[4];  //也可写作new Fish[4]()</span><br></pre></td></tr></table></figure>

<p>第26行：除了类型不同外，本行的代码等同于int* p &#x3D; new int[4]。heapFishes是包含4个元素的动态（堆）数组，其构建过程包含如下步骤。</p>
<ul>
<li>在栈内为作为自动对象的指针heapFishes分配空间；</li>
<li>new操作符通过操作系统API申请4个sizeof(Fish)大小的堆空间并取得地址；</li>
<li>从下标0开始，从前往后逐一调用执行Fish的构造函数Fish::Fish( )，将元素地址作为this指针，用于初始化动态数组的全部元素；</li>
<li>将堆空间地址，即数组首元素的地址赋值给heapFishes。</li>
</ul>
<p>执行结果的第6 ~ 9行对应上述4次构造函数执行的输出。从中可见，编号为3，4，5，6的鱼被构建出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; heapFishes[0].iNumber &lt;&lt; &quot;, &quot; &lt;&lt; heapFishes[1].iNumber &lt;&lt; &quot;, &quot;</span><br><span class="line">     &lt;&lt; heapFishes[2].iNumber &lt;&lt; &quot;, &quot; &lt;&lt; heapFishes[3].iNumber &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第27 ~ 28行：顺次打印heapFishes数组内元素的iNumber。执行结果的第10行表明，数组中下标为0的鱼最先被构造，数组元素的构造顺序确实是从前往后的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete []heapFishes;</span><br></pre></td></tr></table></figure>

<p>第29行：使用delete [ ] 释放heapFishes动态数组。相关执行过程包含下述步骤。</p>
<ul>
<li>如果heapFishes为空指针，直接返回；</li>
<li>heapFishes的类型为Fish*，程序从后往前依次执行heapFishes动态数组所有元素的析构函数~Fish( )，以元素地址为this指针；</li>
<li>释放heapFishes指针所指向的堆内存。</li>
</ul>
<p>执行结果的第11 ~ 14行对应heapFishes数组元素的析构。可见，6号鱼，也就是数组的最后一个元素，最先被析构，析构顺序为从后往前。</p>
<p>再次提醒，new与delete，new [ ]与delete [ ]必须配对使用。</p>
<blockquote>
<p><strong>扩展阅读📕</strong> delete [ ]如何知道指针所指向的动态数组包含多少个元素？ <a target="_blank" rel="noopener" href="http://codelearn.club/2020/03/delete/">http://codelearn.club/2020/03/delete/</a></p>
</blockquote>
<p>执行结果的第16 ~ 18行对应自动对象数组stackFishes的元素析构。可以看到，析构的顺序与构造的顺序相反。</p>
<h2 id="14-隐藏的实现"><a href="#14-隐藏的实现" class="headerlink" title="14. 隐藏的实现"></a>14. 隐藏的实现</h2><p>点完菜后坐下就好，菜一会儿就上来。至于菜是从哪个市场买的，在锅里炒多久，油温多少，我们来操心就好。</p>
<p>— “面向对象”餐厅服务员</p>
<hr>
<h3 id="14-1-接口与封装"><a href="#14-1-接口与封装" class="headerlink" title="14.1 接口与封装"></a>14.1 接口与封装</h3><p><strong>封装（encapsulation）</strong>也是面向对象程序设计的一个重要概念。作者在下面写了一段不完整、不能执行的示意代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Engine&gt;</span><br><span class="line">#include &lt;Wheel&gt;</span><br><span class="line">#include &lt;Window&gt;</span><br><span class="line">#include &lt;Seat&gt;</span><br><span class="line"></span><br><span class="line">class Car&#123;</span><br><span class="line">public:</span><br><span class="line">    Engine e(2000);</span><br><span class="line">    Wheel wheels[4];</span><br><span class="line">    Window frontWindows[2];</span><br><span class="line">    Window backWindows[2];</span><br><span class="line">    Seat seats[5];</span><br><span class="line">    int iWeight = 2300;</span><br><span class="line"></span><br><span class="line">    void pushSpeedPedal(int offset)&#123;</span><br><span class="line">        if (offset &gt; 0)</span><br><span class="line">            cout &lt;&lt; &quot;Speed Up.&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;Speed Down.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pushBrake()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Car is slowing down.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段不完整的代码试图描述一个轿车(Car)类。这个型号的轿车有一个发动机，排量2000，整车自重2300Kg，有四个轮子，前后各两个车窗，五把座椅。</p>
<p>我们看到，文件开始就引入了发动机(Engine)、车轮(Wheel)、车窗(Window)、座椅(Seat)这些类。这些类可能是自己写的，也可能是别人写的；这些类可能是专门为这个项目设计的，也可能是很多年前的某人设计出来用于别的目的的。没关系，反正能利用的尽量利用。这种利用他人代码的方式我们称为**复用(reuse)**。可以看出，面向对象程序设计给代码的复用提供了极大的便利。我们引入别人写的头文件，就是在复用别人的代码。</p>
<p>人类之所以能不断得到进步，其中一个重要原因就是利用他人的劳动成果。一个智能手机的设计师，在设计一款手机时，其中一个重要决定就是选用哪家供应商的哪款CPU作为手机的大脑。在选型时，设计师会考虑CPU的性能、功耗、接口、封装大小，甚至价格，但一般不需要考虑这款CPU是如何制造的，内部的晶体管是如何排列的，甚至，设计师可以根本不需要了解半导体光刻加工工艺的任何细节。设计师需要了解的是：CPU有什么功能，CPU怎么跟外部设备通信，跟存储器怎么联接？跟摄像头怎么连接？ 这些部分，我们称为这个CPU的**接口(interface)<strong>，接口告诉我们器件的功能及使用方法。那些设计师不需要了解的部分，半导体加工工艺，器件内部晶体管布局，称之为</strong>实现(implementation)**。作者相信，正是因为这种社会分工的细化，以及将接口与实现分离的思路，促进了人类社会的进步。想象一下，如果设计师需要全盘了解半导体加工的全部细节，需要全盘了解一个液晶屏设计、加工的全部细节，需要了解手机操作系统的全部细节，这个世界上还有手机设计师么？等到一个手机设计并制造出来，作为使用者的我们，就更简单了，触屏操作，用手指按就好了，至于里面是什么型号的CPU，Android操作系统包含多少行代码，根本不需要我们关心。我们只关心接口：怎么用，有什么用！至于手机内部复杂的实现 ，就让那些需要操心的人去操心吧。更为关键的是，不同厂家的手机，在使用方法上大同小异，基本上不需要阅读说明书，我们就能够使用手机的大部分功能。</p>
<p>这种借助于已有的子系统和零部件，借助于现代工程化方法，将一个复杂系统实现并将复杂的系统实现的细节隐藏起来，只向使用者提供一个简洁易用的接口的工作模式，我们称之为**封装(encapsuation)**。</p>
<p>再回到轿车这个例子，借助于Engine、Window、Seat这些已有的子系统和零部件，我们可以设计一个轿车(Car)类。本例中描述了一辆轿车由发动机、4个轮胎、4个车窗、5个座椅构成，这种将某些自定义类型的对象作为对象的属性&#x2F;构成部分的方法，也是一种代码复用的手段，称为**组合(composition)**。</p>
<p>现代燃油轿车内部是极其复杂的，绝大多数驾驶者都不了解其工作细节。但所有驾驶者都掌握一辆自动档汽车的基本使用方法，也就是<strong>接口</strong>：踩油门，速度变快；踩刹车，速度变慢甚至停下。正是因为使用者只需要了解接口，而不是背后的实现细节，我们才有机会开上车。</p>
<p>在上述Car类里，我们设计了两个成员函数。其中一个叫pushSpeedPedal(int offset)，这就是踩油门函数，offset为正，表明油门往下踩了，要加速，offset为负，表明油门往上松了，要减速。 作为这个类的使用者，你或者他只需要了解这些信息就够了。至于这个函数内部是如何实现的，不必关心。可以想象，其内部实现应该极其复杂，可能涉及喷油量大小的调整、火花塞点火频率的快慢、变速器档位的变化等等。另外一个函数叫pushBrake() ，这是刹车。踩刹车汽车速度会减慢甚至停止。同样，使用者只需要知道踩刹车就减速，至于汽车车载计算机收到刹车传感器的指令后是减少油量还是给变速器降档，还是兼而有之，就不需要使用者操心了。</p>
<p>我们做个总结，作为类的设计者的你，应该朝下述目标努力：<br><strong>类设计者的任务</strong></p>
<ul>
<li>尽量复用或者重用前人的代码，不要重新发明轮子。</li>
<li>使用你认为好的算法以及代码实现类的功能，尽管这些实现部分可能是相当复杂的。</li>
<li>用尽可能简单的函数及属性向使用者提供使用这个类型的<strong>简洁的易于理解的接口</strong>，并尽可能兼容人们已经习惯的通用接口；也就是说，你设计出来的汽车，还应该是油门在右边，刹车在左边。</li>
<li>把实现的细节隐藏起来。这样，将来，你就有机会在接口不变的情况下，通过修改内部实现而提高类型的性能，比如执行速度。</li>
</ul>
<p>作为类的使用者的你，应该朝下述目标努力，既使这个类就是半小时前的你设计的：</p>
<p><strong>类使用者的任务</strong></p>
<ul>
<li>尽量使用别人设计好的类，仅在必要时设计新类。</li>
<li>只管用，不管别人如何实现的。除非你对类的性能不够满意，期望修改它以提升性能。</li>
</ul>
<h3 id="14-2-访问控制"><a href="#14-2-访问控制" class="headerlink" title="14.2 访问控制"></a>14.2 访问控制</h3><p>要实现简洁的接口，就需要把复杂的实现隐藏起来。这些复杂的实现，包括：</p>
<ul>
<li>不希望被类的使用者访问的数据成员；</li>
<li>不希望被类的使用者访问的成员函数。</li>
</ul>
<p>C++借助于下述三个访问控制符来隐藏实现：</p>
<table>
<thead>
<tr>
<th>访问控制符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>私有，说明该成员（数据&#x2F;函数）仅允许在类的内部访问。</td>
</tr>
<tr>
<td>protected</td>
<td>保护，该成员：1. 允许在类的内部访问；2.也允许在该类的继承类▲中访问。</td>
</tr>
<tr>
<td>public</td>
<td>公有，该成员可以随意访问。</td>
</tr>
</tbody></table>
<p>下述C++程序演示了private，public两个访问控制符的用途：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//Project - AccessControl</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">private:                         //可略去不写，默认为private</span><br><span class="line">    float fIncome &#123;0.0f&#125;;        //月收入</span><br><span class="line">    float computeIncomeTax()&#123;    //计算收入税</span><br><span class="line">        return fIncome*0.2F;     //收入税=月收入 x 20%</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    string sID;</span><br><span class="line">    string sName;</span><br><span class="line"></span><br><span class="line">    void setIncome(float fIncome)&#123;  //设置月收入</span><br><span class="line">        this-&gt;fIncome = fIncome;    //在类里访问本类私有属性</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string description()&#123;</span><br><span class="line">        auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数</span><br><span class="line"></span><br><span class="line">        char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">        sprintf(buffer,&quot;ID:         %s\nName:       %s\nIncome:&quot;</span><br><span class="line">                &quot;     %.2f\nIncome Tax: %.2f&quot;,</span><br><span class="line">                sID.c_str(), sName.c_str(), fIncome, fIncomeTax);</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person dora;</span><br><span class="line">    dora.sID = &quot;3604020001&quot;; //访问公有数据成员</span><br><span class="line">    dora.sName = &quot;Dora Henry&quot;;</span><br><span class="line"></span><br><span class="line">    //dora.fIncome = 3000;   //错误：不可以访问私有成员</span><br><span class="line">    //auto fIncomeTax = dora.computeIncomeTax();</span><br><span class="line"></span><br><span class="line">    dora.setIncome(5000);    //访问公有成员函数</span><br><span class="line">    cout &lt;&lt; dora.description();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ID:         3604020001</span><br><span class="line">Name:       Dora Henry</span><br><span class="line">Income:     5000.00</span><br><span class="line">Income Tax: 1000.00</span><br><span class="line">private:                         //可略去不写，默认为private</span><br><span class="line">    float fIncome &#123;0.0f&#125;;        //月收入</span><br><span class="line">    float computeIncomeTax()&#123;    //计算收入税</span><br><span class="line">        return fIncome*0.2F;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第6 ~ 10行：fIncome及computeIncomeTax( )位于private访问控制符之后，说明fIncome属于私有数据成员，computeIncomeTax( )则是私有成员函数。请注意，private关键之后的冒号不可或缺。</p>
<p>在定义类成员时，如果没有指定访问控制符，默认为private。这意味着，本例第6行的private可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    string sID;</span><br><span class="line">    string sName;</span><br><span class="line"></span><br><span class="line">    void setIncome(float fIncome)&#123;  //设置月收入</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>第11 ~ 27行：数据成员sID，sName位于public访问控制符之后，属于公有数据成员；setIncome( )及description( )位于public访问控制符之后，属于公有成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void setIncome(float fIncome)&#123;  //设置月收入</span><br><span class="line">    this-&gt;fIncome = fIncome;    //在类里访问本类私有属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第15 ~ 17行：fIncome（月收入）属于私有成员，在外部无法访问。为了设置这个值，我们专门编写了公有成员函数setIncome( )。setIncome( )函数在类的内部，可以访问私有数据成员fIncome。setIncome(float fIncome)负责把形参fIncome赋值给对象的属性fIncome。由于形参名恰巧与属性名重名，如果直接写成fIncome &#x3D; fIncome，编译器无法正确区分谁是谁，将属性名fIncome改为this-&gt;fIncome可以解决这种表达歧义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string description()&#123;</span><br><span class="line">    auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>第19 ~ 27行：description( )函数在类的内部，它不是类的使用者，它可以访问对象的私有成员函数computeIncomeTax( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person dora;</span><br><span class="line">dora.sID = &quot;3604020001&quot;; //访问公有数据成员</span><br><span class="line">dora.sName = &quot;Dora Henry&quot;;</span><br></pre></td></tr></table></figure>

<p>第31 ~ 33行：sID，sName属于公有属性，类的使用者（此处为main( )函数）可以直接访问dora对象的sID及sName属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//dora.fIncome = 3000;   //错误：不可以访问私有成员</span><br></pre></td></tr></table></figure>

<p>第35行：类的使用者（此处为main( )函数），或者说在类的外部，不可以访问对象的私有数据成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//auto fIncomeTax = dora.computeIncomeTax();</span><br></pre></td></tr></table></figure>

<p>第36行：在类的外部，不可以访问对象的私有成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dora.setIncome(5000);    //访问公有成员函数</span><br></pre></td></tr></table></figure>

<p>第38行：在类的外部，访问对象的公有成员函数setIncome( )设置对象的私有属性（月收入）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dora.description();</span><br></pre></td></tr></table></figure>

<p>第39行：在类的外部，访问对象的公有成员函数description( )。如前所述，该公有成员函数内部访问了对象的私有成员函数computeIncomeTax( )。</p>
<p>粗略地，一个类型的公有成员（包括数据成员及成员函数）构成了该类的对外接口，这个接口应尽可能简洁，容易理解；一个类型的私有成员（包括数据成员及成员函数）构成了该类的隐藏的实现。</p>
<h3 id="14-3-标准类实现"><a href="#14-3-标准类实现" class="headerlink" title="14.3 标准类实现"></a>14.3 标准类实现</h3><p>从第13章到目前为止，出于节省篇幅的目的，我们一直使用一种非标准的方式来定义类。事实上，常规的应用程序通常包括几十、几百甚至几万个自定义类型。</p>
<p>通常，我们需要把一个或者多个紧密相关的类型定义在一对.h及.cpp文件中。这样做有如下益处：</p>
<ul>
<li>便于项目管理及团队协作，一个大型项目的数百位程序员不可能同时在一个文件里编程。</li>
<li>实现成员函数代码的隐藏。类的使用者要了解一个类的接口，只要阅读头文件就够了，至于放置成员函数详细代码的cpp文件，非必要情况下不必关心。</li>
</ul>
<p>为了帮助读者理解如何在项目如何创建新类型所对应的“一对.h及.cpp文件”，我们以Qt Creator为例，进行演示说明。</p>
<p>①. 在Qt Creator中创建一个Non-Qt Project&#x2F;Plain C++ Application，项目名称为HeaderCpp。</p>
<p><img src="http://codelearn.club/images/image-20200314154453537.png" alt="image-20200314154453537"></p>
<p>②. 鼠标右击项目名称HeaderCpp，在弹出菜单中选择“Add New…”。</p>
<p><img src="http://codelearn.club/images/image-20200314154536284.png" alt="image-20200314154536284"></p>
<p>③. 选择C++, C++ Class，然后再选“Choose…”。</p>
<p><img src="http://codelearn.club/images/image-20200314154602264.png" alt="image-20200314154602264"></p>
<p>④. 类名（Class name）栏中输入Person，然后选“下一步”，接下来选“完成”。</p>
<p><img src="http://codelearn.club/images/image-20200314154655035.png" alt="image-20200314154655035"></p>
<p>⑤. 随会可以看到项目树形列表中Headers文件夹下多了一个名为person.h的文件，Sources文件夹下多了一个名为person.cpp的文件。同时，原有的main.cpp还在。</p>
<p><img src="http://codelearn.club/images/image-20200314154801749.png" alt="image-20200314154801749"></p>
<p>接下来，我们把上一节的程序用标准类的方式重写。person.h的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PERSON_H</span><br><span class="line">#define PERSON_H</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">private:                         //可略去不写，默认为private</span><br><span class="line">    float fIncome &#123;0.0f&#125;;        //月收入</span><br><span class="line">    float computeIncomeTax()&#123;    //计算收入税 - 内联成员函数</span><br><span class="line">        return fIncome*0.2F;     //收入税=月收入 x 20%</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    string sID;</span><br><span class="line">    string sName;</span><br><span class="line"></span><br><span class="line">    void setIncome(float fIncome); //设置月收入</span><br><span class="line">    string description();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // PERSON_H</span><br></pre></td></tr></table></figure>

<p>头文件的职责是对类进行声明。这种类声明包含如下内容：</p>
<ul>
<li>类名称；</li>
<li>声明类的数据成员；</li>
<li>声明类的方法，通常不定义函数体。</li>
</ul>
<p>person.h即提供了Person类的声明。如果.h&#x2F;.cpp文件中只声明&#x2F;定义了一个类，习惯上我们会让文件与类同名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PERSON_H</span><br><span class="line">#define PERSON_H</span><br><span class="line">...</span><br><span class="line">#endif // PERSON_H</span><br></pre></td></tr></table></figure>

<p>第1 ~ 2， 21行：这三行代码由Qt Creator自动帮我们创建，用于避免person.h的类声明部分多次被引入同一个.cpp文件。</p>
<p>根据第12章的讨论，这三行代码属于预处理指令，其语法意义大约等同于下述伪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果 PERSON_H 还没有定义</span><br><span class="line">&#123;</span><br><span class="line">   定义 PERSON_H</span><br><span class="line">   [进行Person类声明 ... ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缺乏上述预处理指令的保护，在特定条件下，某些cpp文件（例如person.cpp），可能会引入person.h多于一次。此时，即相当于在person.cpp中重复对Person类型进行了多次声明，这是不允许的。我们举例说明这种特定条件：a.cpp引入person.h; a.cpp引入b.h， b.h又引入person.h。上述预处理指令的存在，使得Person的类声明部分只能被引入一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>第4行：引入Person类声明中需要使用到的string类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float computeIncomeTax()&#123;    //计算收入税 - 内联成员函数</span><br><span class="line">    return fIncome*0.2F;     //收入税=月收入 x 20%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 12行：通常，类声明中只提供类方法声明，函数体应在对应的.cpp文件中提供。本例中，computeIncomeTax( )的函数体直接写在了类声明里，这事实上是另一种形式的<strong>内联函数</strong>。它告诉编译器，在可能的情况下，将这个成员函数内联。</p>
<p>person.cpp内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;person.h&quot;</span><br><span class="line"></span><br><span class="line">void Person::setIncome(float fIncome)&#123;</span><br><span class="line">    this-&gt;fIncome = fIncome;    //在类里访问本类私有属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Person::description()&#123;</span><br><span class="line">    auto fIncomeTax = computeIncomeTax(); //在类里访问本类私有函数</span><br><span class="line"></span><br><span class="line">    char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">    sprintf(buffer,&quot;ID:         %s\nName:       %s\nIncome:&quot;</span><br><span class="line">            &quot;     %.2f\nIncome Tax: %.2f&quot;,</span><br><span class="line">            sID.c_str(), sName.c_str(), fIncome, fIncomeTax);</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.cpp文件用于类方法定义。person.cpp定义了person.h中声明的两个成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;person.h&quot;</span><br></pre></td></tr></table></figure>

<p>第1行：包含person.h头文件。这是必须的，因为person.cpp中定义的类成员函数必须在person.h中进行了声明。同时，person.h类声明中的成员函数如果不是内联的，也必须在person.cpp中进行定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void Person::setIncome(float fIncome)&#123;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>第3行：请注意，person.cpp进行函数类定义时使用了域解析符。Person::setIncome意为Person类型中的名为setIncome的成员函数。</p>
<p>main.cpp内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Project - HeaderCpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;person.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person dora;</span><br><span class="line">    dora.sID = &quot;3604020001&quot;; //访问公有数据成员</span><br><span class="line">    dora.sName = &quot;Dora Henry&quot;;</span><br><span class="line">    dora.setIncome(5000);    //访问公有成员函数</span><br><span class="line">    cout &lt;&lt; dora.description();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序（即main( )函数）的执行结果与前节完全相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ID:         3604020001</span><br><span class="line">Name:       Dora Henry</span><br><span class="line">Income:     5000.00</span><br><span class="line">Income Tax: 1000.00</span><br></pre></td></tr></table></figure>

<p>main.cpp是Person类型的使用者，它通过引入person.h头文件才了解Person类型的接口。有了接口（属性的名称，成员函数的名称，形参，返回值类型等）之后，main.cpp就知道应该如何使用Person类型及其对象。</p>
<p>而Person类型的实现部分，至少是成员函数的实现部分，则位于person.cpp。对于整个程序而言，person.cpp与main.cpp分属两个不同的编译单元，main.cpp当中对Person类型的成员函数的调用解析，是在链接阶段完成的。</p>
<p>考虑到描述的简便性，本书后续部分，多数时候仍然会将类的定义与使用放在同一个cpp文件中。但请读者注意，在正式的软件项目中，务必使用本节所描述的标准类实现方法，将类声明和类方法定义组织在一对.h及.cpp文件中。</p>
<h3 id="14-4-友元"><a href="#14-4-友元" class="headerlink" title="14.4 友元"></a>14.4 友元</h3><p>使用private访问控制符可以把对象成员私有。这种私有是对所有外部对象而言的，并不能达成我们对访问控制的所有需要。例如，多数家庭的银行账户密码对家庭以外成员是保密的，但对妻子&#x2F;丈夫却是公开的。C++通过友元（friend）语法实现这种存在例外的访问控制。</p>
<blockquote>
<p>复数：不同于普通的实数，一个复数由实部和虚部两个部分构成。两个复数相加的结果等于另一个复数，结果复数的实部等于两个操作数的实部的和，虚部等于两个操作数的虚部的和。</p>
</blockquote>
<p>下述C++程序设计实现了复数类Complex。在该类中，通过将add( )及main( )函数设定为该类的<strong>友元函数（friend class）</strong>，允许这两个函数访问Complex类的私有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Project - FriendFunction</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex&#123;          //复数类</span><br><span class="line">private:</span><br><span class="line">    float fReal;        //私有的实部和虚部</span><br><span class="line">    float fImage;</span><br><span class="line">public:</span><br><span class="line">    Complex(float real, float img)&#123;</span><br><span class="line">        fReal = real;</span><br><span class="line">        fImage = img;</span><br><span class="line">    &#125;</span><br><span class="line">    friend Complex add(const Complex&amp;, const Complex&amp;);</span><br><span class="line">    friend int main();  //声明友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Complex add(const Complex&amp; a, const Complex&amp; b)&#123;</span><br><span class="line">    float fReal = a.fReal + b.fReal;    //友元函数访问对象的私有成员</span><br><span class="line">    float fImage = a.fImage + b.fImage;</span><br><span class="line">    return Complex(fReal,fImage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(3,2);</span><br><span class="line">    Complex c = add(a,Complex(2,3));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;(3+2i)+(2+3i)= &quot; &lt;&lt; c.fReal &lt;&lt; &quot;+&quot; &lt;&lt; c.fImage &lt;&lt; &quot;i&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(3+2i)+(2+3i)= 5+5i</span><br></pre></td></tr></table></figure>

<p>第6 ~ 8行：Complex类型将实部fReal及虚部fImage声明为私有数据成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">friend Complex add(const Complex&amp;, const Complex&amp;);</span><br><span class="line">friend int main();  //声明友元函数</span><br></pre></td></tr></table></figure>

<p>第14 ~ 15行：Complex类型将add( )及main( )函数声明为类型的友元函数。请注意这种声明不仅包括友元函数的函数名，还包括了返回类型，形参列表等，因为函数名重载的原因，仅凭函数名不能确定性地标识一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex add(const Complex&amp; a, const Complex&amp; b)&#123;</span><br><span class="line">    float fReal = a.fReal + b.fReal;    //友元函数访问对象的私有成员</span><br><span class="line">    float fImage = a.fImage + b.fImage;</span><br><span class="line">    return Complex(fReal,fImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第18 ~ 22行：add( )接受两个Complex对象的常量型引用作为参数，然后将两个复数对象相加，返回结果复数。请注意，函数体内，该函数访问了Complex对象的私有数据成员，这是作为友元函数的特权。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    Complex a(3,2);</span><br><span class="line">    Complex c = add(a,Complex(2,3));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;(3+2i)+(2+3i)= &quot; &lt;&lt; c.fReal &lt;&lt; &quot;+&quot; &lt;&lt; c.fImage &lt;&lt; &quot;i&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第24 ~ 30行：main( )函数也是Complex类的友元函数，所以第28行对c的私有成员的访问是合法的。 请注意，由于add( )函数，main( )函数中需要使用到Complex类型，本例中Complex类型的声明必须早于add( )及main( )函数的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c = add(a,Complex(2,3));</span><br></pre></td></tr></table></figure>

<p>第26行：Complex(2,3)通过Complex的构造函数构造了一个临时对象并作为实参传递给add( )函数。这个临时对象也是自动变量，在该函数执行完成后，编译器会自动执行其析构函数。</p>
<p>进一步，我们还可以将另一个类的某个成员函数指定为本类的友元成员函数。下述代码第21行，Complex类型将Computer类型的成员函数void Computer::output(const Complex&amp;)设为友元成员函数，允许其访问本类的私有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Project - FriendMemberFunction</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex;</span><br><span class="line"></span><br><span class="line">class Computer&#123;         //计算器类</span><br><span class="line">public:</span><br><span class="line">    void output(const Complex&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Complex&#123;          //复数类</span><br><span class="line">private:</span><br><span class="line">    float fReal;        //私有的实部和虚部</span><br><span class="line">    float fImage;</span><br><span class="line">public:</span><br><span class="line">    Complex(float real, float img)&#123;</span><br><span class="line">        fReal = real;</span><br><span class="line">        fImage = img;</span><br><span class="line">    &#125;                   //友元成员函数</span><br><span class="line">    friend void Computer::output(const Complex&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Computer::output(const Complex&amp; c)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Complex(&quot; &lt;&lt; c.fReal &lt;&lt; &quot; + &quot;</span><br><span class="line">         &lt;&lt; c.fImage &lt;&lt; &quot;i)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(3,2);</span><br><span class="line"></span><br><span class="line">    Computer c;</span><br><span class="line">    c.output(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(3 + 2i)</span><br></pre></td></tr></table></figure>

<p>第24 ~ 27行：Computer类型的output( )函数是Complex类的友元成员函数，其函数体对Complex对象c的私有成员的访问是合法的。</p>
<p><img src="http://codelearn.club/images/image-20200315155145078.png" alt="image-20200315155145078"></p>
<p>图14- 声明的顺序</p>
<p>上述程序使用了非常奇怪的声明&#x2F;定义顺序来保证代码的合法性，我们借助图14- 来进行说明。</p>
<p>①. Complex类型在声明友元成员函数时，必须先声明Computer类以及该类的output( )成员函数。为了解决这个问题，我们把Computer的类声明放在前面。</p>
<p>②. Computer类的成员函数output( )有一个类型为const Complex&amp;的形参，根据语法要求，Complex类型必须在该处之前先行声明。为了解决这个先有鸡还是先有蛋的问题，我们在程序开头通过代码class Complex“简易”声明了一个名为Complex的类型，然后再在Computer类声明之后给出Complex类型的详细声明。</p>
<p>③. Computer的output( )成员函数的函数体要使用到Complex类的数据成员，所以，Computer::output( )成员方法定义只能位于Complex的详细声明之后。</p>
<p>更进一步，我们还可以把其它类整体声明为本类的<strong>友元类（friend class）</strong>。下述C++代码中，Complex类型声明Computer类型为本类的友元类，授权Computer类的所有成员函数访问Complex类型的私有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Project - FriendClass</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex&#123;          //复数类</span><br><span class="line">private:</span><br><span class="line">    float fReal;        //私有的实部和虚部</span><br><span class="line">    float fImage;</span><br><span class="line">public:</span><br><span class="line">    Complex(float real, float img)&#123;</span><br><span class="line">        fReal = real;</span><br><span class="line">        fImage = img;</span><br><span class="line">    &#125;                   //友元成员函数</span><br><span class="line">    friend class Computer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Computer&#123;         //计算器类</span><br><span class="line">public:</span><br><span class="line">    void output(const Complex&amp; c)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Complex(&quot; &lt;&lt; c.fReal &lt;&lt; &quot; + &quot;</span><br><span class="line">             &lt;&lt; c.fImage &lt;&lt; &quot;i)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex add(const Complex&amp; a, const Complex&amp; b)&#123;</span><br><span class="line">        return Complex(a.fReal+b.fReal, a.fImage+b.fImage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Computer c;</span><br><span class="line">    Complex r = c.add(Complex(1,2),Complex(1,2));</span><br><span class="line">    c.output(r);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex(2 + 4i)</span><br></pre></td></tr></table></figure>

<p>第14行：将Computer声明为Complex类的友元类。程序中可见，Computer类的成员函数output( )，add( )都因此获得了对Complex类私有成员的访问权。</p>
<h3 id="14-5-静态数据成员"><a href="#14-5-静态数据成员" class="headerlink" title="14.5 静态数据成员"></a>14.5 静态数据成员</h3><p>第8章中讨论的静态对象存储于全局静态数据区，其生存周期一直持续到程序运行结束。如果将静态对象定义了类的数据成员，便为类的静态数据成员。</p>
<p>下述C++程序中的Tomato类型试图通过静态数据成员来记录“切水果”游戏当中剩余的番茄数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//Project - TomatoCount</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Tomato &#123;</span><br><span class="line">private:</span><br><span class="line">    static int objectCount;   //静态数据成员</span><br><span class="line">    float fSize &#123;10&#125;;         //番茄的尺寸</span><br><span class="line">public:</span><br><span class="line">    Tomato()&#123;</span><br><span class="line">        objectCount++;        //每构造一个对象，数量加1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Tomato()&#123;</span><br><span class="line">        objectCount--;        //每析构一个对象，数量减1</span><br><span class="line">    &#125;</span><br><span class="line">    friend int main();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Tomato::objectCount = 0;  //给静态数据成员赋初始值</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(Tomato) = &quot; &lt;&lt; sizeof(Tomato) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Tomato t1;</span><br><span class="line">    printf(&quot;&amp;t1: %p, &amp;Tomato::objectCount: %p\n&quot;, &amp;t1, &amp;Tomato::objectCount);</span><br><span class="line"></span><br><span class="line">    Tomato t2[10];</span><br><span class="line">    Tomato* t3 = new Tomato;</span><br><span class="line"></span><br><span class="line">    printf(&quot;t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\n&quot;,</span><br><span class="line">           t1.objectCount,t3-&gt;objectCount,Tomato::objectCount);</span><br><span class="line">    printf(&quot;&amp;t1.objectCount = %p, &amp;t3-&gt;objectCount = %p\n&quot;,</span><br><span class="line">           &amp;t1.objectCount,&amp;t3-&gt;objectCount);</span><br><span class="line"></span><br><span class="line">    delete t3;</span><br><span class="line">    printf(&quot;t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\n&quot;,</span><br><span class="line">           t1.objectCount,t3-&gt;objectCount,Tomato::objectCount);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Tomato) = 4</span><br><span class="line">&amp;t1: 000000000061fe04, &amp;Tomato::objectCount: 000000000040c030</span><br><span class="line">t1.objectCount=12, t3-&gt;objectCount=12, Tomato::objectCount=12</span><br><span class="line">&amp;t1.objectCount = 000000000040c030, &amp;t3-&gt;objectCount = 000000000040c030</span><br><span class="line">t1.objectCount=11, t3-&gt;objectCount=11, Tomato::objectCount=11</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    static int objectCount;   //静态数据成员</span><br><span class="line">    float fSize &#123;10&#125;;         //番茄的尺寸</span><br></pre></td></tr></table></figure>

<p>第7 ~ 9行：Tomato类中定义静态数据成员objectCount。普通数据成员fSize的初始值可以直接在类声明中给出，但非常量型静态数据成员必须在类声明之外进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Tomato::objectCount = 0;  //给静态数据成员赋初始值</span><br></pre></td></tr></table></figure>

<p>第21行：在类声明之外对静态数据成员进行定义和初始化。如果类型是按照14.3节中描述的”标准类“方法实现的，则对静态数据成员定义和初始化必须在相应的.cpp文件中完成，与那些类方法定义在一起。</p>
<p>具体到本例，语法上，上述静态数据成员的定义可以不给objectCount赋初始值，但<strong>定义本身不可或缺</strong>。因为在物理上，objectCount事实上不属于任何Tomato对象，其内存应该单独分配。这种额外的强制定义确保了该静态数据成员被恰当地分配存储空间。</p>
<p><img src="http://codelearn.club/images/image-20200315204541949.png" alt="image-20200315204541949"></p>
<p>图14- 静态数据成员的存储</p>
<p>事实上，Tomato类型的普通数据成员fSize与静态数据成员objectCount，在数据存储上有本质区别。如图14- 所示，非静态的普通数据成员fSize在每一个Tomato对象内均分配存储空间，各对象的fSize成员相互独立。但是，静态数据成员Tomato::objectCount仅在全局静态数据区存储一个副本，无论是1号番茄还是3号番茄，它们的objectCount成员代表同一个int类型的对象，即Tomato::objectCount。</p>
<p>只有类的静态数据成员可以使用类名::成员名的形式来使用，例如本例中的Tomato::objectCount，因为objectCount不依赖于具体的Tomato对象而存在。对于普通数据成员fSize，Tomato::fSize是错误的使用形式，因为fSize属于具体的Tomato对象，编译器需要通过其所属对象的地址再加上其在对象内的偏移量来确定其内存地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    Tomato()&#123;</span><br><span class="line">        objectCount++;        //每构造一个对象，数量加1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Tomato()&#123;</span><br><span class="line">        objectCount--;        //每析构一个对象，数量减1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 17行：每构造一个对象，静态数据成员objectCount+1；每析构一个对象，静态数据成员objectCount-1。考虑到静态数据成员Tomato::objectCount只有一个副本，+1或-1都是在操作同一个objectCount，理论上，objectCount的值即为当前仍处于“生存”状态的Tomato对象的个数。</p>
<p>事实上，考虑到拷贝构造函数▲的存在，特定情况下，本例中的objectCount并不能完美记录Tomato对象的“生存”个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;sizeof(Tomato) = &quot; &lt;&lt; sizeof(Tomato) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第24行：打印一个Tomato对象的大小。执行结果的第1行显示，该值为4个字节。这证实，1个Tomato对象内部仅存储了其普通数据成员fSize（float，4个字节），静态数据成员objectCount未占用对象内的空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tomato t1;</span><br><span class="line">printf(&quot;&amp;t1: %p, &amp;Tomato::objectCount: %p\n&quot;, &amp;t1, &amp;Tomato::objectCount);</span><br></pre></td></tr></table></figure>

<p>第26 ~ 27行：定义了自动变量t1，t1存储在栈内。执行结果的第2行显示，栈对象t1地址0x0061fe04与Tomato::objectCount的地址0x0040c030相去甚远，后者存储于全局静态数据存储区，不在栈内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tomato t2[10];</span><br><span class="line">Tomato* t3 = new Tomato;</span><br></pre></td></tr></table></figure>

<p>第29 ~ 30行：t2数组有包含10个Tomato，t3指针指向1个Tomato，再加上t1，第30行代码执行后，内存中共有12个番茄。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\n&quot;,</span><br><span class="line">       t1.objectCount,t3-&gt;objectCount,Tomato::objectCount);</span><br></pre></td></tr></table></figure>

<p>第32 ~ 33行：通过t1.objectCount，t3-&gt;objectCount, Tomato::objectCount三种途径输出静态数据成员objectCount值。执行结果的第3行显示，三种途径均得到12的值，与内存中存在12个番茄的事实相符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;&amp;t1.objectCount = %p, &amp;t3-&gt;objectCount = %p\n&quot;,</span><br><span class="line">       &amp;t1.objectCount,&amp;t3-&gt;objectCount);</span><br></pre></td></tr></table></figure>

<p>第34 ~ 35行：打印t1.objectCount，t3-&gt;objectCount的地址。执行结果的第4行证实，它们的地址与Tomato::objectCount完全相同，事实上代表同一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete t3;</span><br><span class="line">printf(&quot;t1.objectCount=%d, t3-&gt;objectCount=%d, Tomato::objectCount=%d\n&quot;,</span><br><span class="line">       t1.objectCount,t3-&gt;objectCount,Tomato::objectCount);</span><br></pre></td></tr></table></figure>

<p>第37 ~ 39行：释放指针t3指向的对象后，再次打印objectCount。执行结果的第5行显示，Tomato::objectCount的值变成了11，与事实相符。</p>
<p>至于t2数组所包含的10个Tomato，以及t1，需要等到main( )函数的结尾处才会由编译器自动析构回收。</p>
<h3 id="14-6-静态成员函数"><a href="#14-6-静态成员函数" class="headerlink" title="14.6 静态成员函数"></a>14.6 静态成员函数</h3><p>类的成员函数也可以是静态的，下述C++程序演示了静态成员函数的基本用法。相对于普通成员函数，静态成员函数有如下特点：</p>
<ul>
<li>没有秘密的this指针参数，其执行不依赖于任何具体的对象。</li>
<li>在静态成员函数的函数体内，只能访问类的静态数据成员及其他静态成员函数，不能访问类的非静态成员。这是因为：非静态成员的访问依赖于具体的对象，需要通过this指针进行，但静态成员函数没有this指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//Project - LivingTomato</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Tomato &#123;</span><br><span class="line">private:</span><br><span class="line">    static int iConstructed;   //构造数量</span><br><span class="line">    static int iDestructed;    //析构数量</span><br><span class="line">    float fSize &#123;10&#125;;          //番茄的尺寸</span><br><span class="line">public:</span><br><span class="line">    Tomato()&#123;</span><br><span class="line">        iConstructed++;        //构造数量+1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Tomato()&#123;</span><br><span class="line">        iDestructed++;         //析构数量+1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static int livingCount()&#123;</span><br><span class="line">        //fSize *= 2;         //错误：不可以访问非静态成员</span><br><span class="line">        //this-&gt;fSize -= 2;   //错误：静态成员函数没有this指针</span><br><span class="line">        //存活数量  = 构造数量 - 析构数量</span><br><span class="line">        return iConstructed - iDestructed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Tomato::iConstructed &#123;0&#125;;  //给静态数据成员赋初始值</span><br><span class="line">int Tomato::iDestructed  &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Tomato t1;</span><br><span class="line">    Tomato t2[10];</span><br><span class="line">    Tomato *t3 = new Tomato[3];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; Tomato::livingCount() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t2[3].livingCount() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t3-&gt;livingCount() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    delete[] t3;</span><br><span class="line">    cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t1.livingCount() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Number of living tomatoes = 14</span><br><span class="line">Number of living tomatoes = 14</span><br><span class="line">Number of living tomatoes = 14</span><br><span class="line">Number of living tomatoes = 11</span><br><span class="line">static int livingCount()&#123;</span><br><span class="line">    //fSize *= 2;         //错误：不可以访问非静态成员</span><br><span class="line">    //this-&gt;fSize -= 2;   //错误：静态成员函数没有this指针</span><br><span class="line">    //存活数量  = 构造数量 - 析构数量</span><br><span class="line">    return iConstructed - iDestructed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 24行：定义了“内联”的静态成员函数livingCount( )，该函数通过构造数量减去析构数量的方法求得当前仍“存活”的番茄数量，然后返回。</p>
<p>第20行代码错误：fSize属于类的非静态成员，其它属于某个特定的番茄对象。livingCount( )因为没有this指针，故无法访问该成员。</p>
<p>第21行代码错误：livingCount( )函数没有this指针。</p>
<p>第23行：可以访问iConstructed及iDestructed数据成员，因为它们是静态的，不依赖任何具体的番茄对象而存在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tomato t1;</span><br><span class="line">Tomato t2[10];</span><br><span class="line">Tomato *t3 = new Tomato[3];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; Tomato::livingCount() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t2[3].livingCount() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t3-&gt;livingCount() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第31 ~ 37行：先创建了番茄对象t1、番茄对象数组t2以及动态番茄数组t3，共14个番茄，然后通过三种途径调用执行livingCount( )静态成员函数。执行结果的前3行证实，无论是直接调用类的静态成员函数（Tomato::livingCount( )），还是通过对象来调用其静态成员函数（t3-&gt;livingCount( )），实际执行的都是同一个函数，其结果相同。事实上，t3-&gt;livingCount( )这种调用形式，在语法上虽然可以解释为执行t3所指向的Tomato对象的livingCount( )成员函数，但因为livingCount( )是静态的，所以编译器并不会向livingCount( )传递this指针。静态成员函数的执行不依赖于任何具体的对象，即便一个类型从未被实例化，其静态成员函数依然可以执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete[] t3;</span><br><span class="line">cout &lt;&lt; &quot;Number of living tomatoes = &quot; &lt;&lt; t1.livingCount() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第39 ~ 40行：在删除动态数组t3后，再次执行livingCount( )，执行结果的第4行显示，存活的番茄个数变成了11个，与事实相符。</p>
<h3 id="微实践-单件模式"><a href="#微实践-单件模式" class="headerlink" title="微实践 - 单件模式**"></a>微实践 - 单件模式**</h3><p><strong>设计模式（design patterns）</strong>是软件体系结构中一个比较深入的话题。其中，<strong>单件（singleton）模式</strong>是其中最简单的一种，它描述了下述应用场景其及解决方案：在程序中，有些类型我们最多只需要一个对象，比如数据库连接、错误日志记录器等等。单件模式试图通过特殊的类设计确保该类型最多只能被实例化一次。</p>
<p>下述C++程序演示了一个名为Daemon的单件类，它是通过静态成员函数来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//Project - Singleton</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Daemon &#123;</span><br><span class="line">private:</span><br><span class="line">    static Daemon* instance;</span><br><span class="line">    Daemon()&#123;&#125; //将构造函数私有</span><br><span class="line">    Daemon(const Daemon&amp;)&#123;&#125; //将拷贝构造函数私有</span><br><span class="line">public:</span><br><span class="line">    static Daemon* Instance()&#123;</span><br><span class="line">        if (instance==nullptr)</span><br><span class="line">            instance = new Daemon();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Daemon* Daemon::instance &#123;nullptr&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    //Daemon d;  //错误：私有的构造函数不能执行</span><br><span class="line">    //Daemon* d = new Daemon();</span><br><span class="line"></span><br><span class="line">    Daemon* d1 = Daemon::Instance();</span><br><span class="line">    //借助于d1指针使用唯一的Daemon对象...</span><br><span class="line">    Daemon* d2 = Daemon::Instance();</span><br><span class="line">    //借助于d2指针使用唯一的Daemon对象...</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;d1 = &quot; &lt;&lt; d1 &lt;&lt; &quot;, d2 = &quot; &lt;&lt; d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    delete Daemon::Instance(); //释放唯一的Daemon对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d1 = 0xe517b0, d2 = 0xe517b0</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    static Daemon* instance;</span><br><span class="line">    Daemon()&#123;&#125; //将构造函数私有</span><br><span class="line">    Daemon(const Daemon&amp;)&#123;&#125; //将拷贝构造函数私有</span><br></pre></td></tr></table></figure>

<p>第6 ~ 9行：Daemon类型的构造函数被私有，这意味着类型的使用者无法直接定义Daemon对象。</p>
<p>Daemon类型的拷贝构造函数（copy constructor）▲也被私有，这意味着类型的使用者无法通过对象的拷贝赋值来创建Daemon对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    static Daemon* Instance()&#123;</span><br><span class="line">        if (instance==nullptr)</span><br><span class="line">            instance = new Daemon();</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 15行：公有的静态成员函数Instance( )用于返回唯一的Daemon对象的指针。该指针保存在静态数据成员instance里，当instance为空时，说明当前程序中不存在Daemon对象，第13行通过new操作符新建一个Daemon对象并将其地址赋值给instance。由于Instance( )是Daemon类的成员函数，所以此处对Daemon的构造函数的调用是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Daemon d;  //错误：私有的构造函数不能执行</span><br><span class="line">//Daemon* d = new Daemon();</span><br></pre></td></tr></table></figure>

<p>第21 ~ 22行：任何常规的对象创建方法都需要调用Daemon的构造函数，但其构造函数是私有的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Daemon* d1 = Daemon::Instance();</span><br><span class="line">//借助于d1指针使用唯一的Daemon对象...</span><br><span class="line">Daemon* d2 = Daemon::Instance();</span><br><span class="line">//借助于d2指针使用唯一的Daemon对象...</span><br></pre></td></tr></table></figure>

<p>第24 ~ 27行：类的使用者仅被允许通过Instance( )获取唯一的Daemon对象的指针，然后再借助于获取的指针来使用该对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;d1 = &quot; &lt;&lt; d1 &lt;&lt; &quot;, d2 = &quot; &lt;&lt; d2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第29行：执行结果证实，每次调用Instance( )函数所获取的指针，都是同一个值。它们都指向那个“唯一”的Daemon对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete Daemon::Instance(); //释放唯一的Daemon对象</span><br></pre></td></tr></table></figure>

<p>第31行：唯一的Daemon对象必须被释放，否则会造成内存泄漏。</p>
<p>借助于单件模式，在类的设计阶段就保证了该类最多只可能被实例化一次，以避免类的使用者不小心犯错（意外创建多个类对象）。</p>
<h3 id="14-7-常量成员函数"><a href="#14-7-常量成员函数" class="headerlink" title="14.7 常量成员函数"></a>14.7 常量成员函数</h3><p>可以将类的成员函数设定为常量型。执行一个对象的常量型成员函数<strong>不可以</strong>导致对对象的任何修改，这意味着：</p>
<ul>
<li>常量型成员函数不可以修改对象的任何数据成员，mutable类型的数据成员除外。</li>
<li>常量型成员函数不可以调用执行对象的任何非常量型成员函数，因为这些函数的执行，可能会导致对象状态的改变。</li>
</ul>
<p>mutable在英文中意为“易变的”，用mutable修饰的数据成员不受对象及其成员函数常量性的约束。</p>
<p>常量型成员函数执行预期不会修改对象的状态，那么非常量型成员函数的执行则有可能修改对象的状态。因此：<strong>不能执行常量型对象的非常量型成员函数；对于常量型对象，仅可执行其常量型成员函数</strong>。</p>
<p>我们通过下述C++程序来解释常量型成员函数的应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//Project - ConstMemberFunction</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">private:</span><br><span class="line">    float fReal;</span><br><span class="line">    float fImage;</span><br><span class="line">    mutable bool bAbsComputed = false;</span><br><span class="line">public:</span><br><span class="line">    Complex(float real, float image)&#123;</span><br><span class="line">        fReal = real;</span><br><span class="line">        fImage = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Complex&amp; add(const Complex&amp; v)&#123;</span><br><span class="line">        fReal += v.fReal;</span><br><span class="line">        fImage += v.fImage;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    float abs() const &#123;</span><br><span class="line">        bAbsComputed = true;  //正确：可以修改mutable类型的数据成员</span><br><span class="line">        //fReal += 10;        //错误：不可以修改非mutable类型的数据成员</span><br><span class="line">        //add(Complex(1,2));  //错误：不可以调用非const类型的成员函数</span><br><span class="line">        return sqrt(fReal*fReal + fImage*fImage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex c(2,3);</span><br><span class="line">    c.add(Complex(1,1));</span><br><span class="line"></span><br><span class="line">    const Complex* p = &amp;c;</span><br><span class="line">    const Complex&amp; r = c;</span><br><span class="line">    //p-&gt;add(Complex(1,1));  //错误：不可以执行常量型对象的非常量型成员函数</span><br><span class="line">    //r.add(Complex(1,1));   //错误：不可以执行常量型对象的非常量型成员函数</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;abs(r) = &quot; &lt;&lt; r.abs() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abs(r) = 5</span><br><span class="line">const Complex&amp; add(const Complex&amp; v)&#123;</span><br><span class="line">    fReal += v.fReal;</span><br><span class="line">    fImage += v.fImage;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第17 ~ 21行：add( )是一个非常量型的成员函数，该函数把形参v累加到复数对象，然后返回该对象的常量型引用。第17行的const用于修饰函数的返回值类型，并非修饰函数本身。我们看到，第18 ~ 19行，该函数修改了对象的数据成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float abs() const &#123;</span><br><span class="line">    bAbsComputed = true;  //错误：可以修改mutable类型的数据成员</span><br><span class="line">    //fReal += 10;        //错误：不可以修改非mutable类型的数据成员</span><br><span class="line">    //add(Complex(1,2));  //错误：不可以调用非const类型的成员函数</span><br><span class="line">    return sqrt(fReal*fReal + fImage*fImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第23 ~ 28行：abs( )是Complex类的常量型成员函数，它用于计算复数的模。理论上，计算一个复数的模不应该导致这个复数被修改，因此，该函数被设定为常量型成员函数。第23行中的const修饰的是函数本身。</p>
<p>第24行对bAbsComputed的修改是合法的，因为它是mutable类型的数据成员；第25行对fReal的修改是非法的，常量型成员函数不可以导致对象属性的改变；第26行对add( )函数的调用是非法的，因为该函数不是常量型的，其预期会导致对象属性的改变；第28行按照复数的求模公式（实部虚部平方和的平方根）计算复数的模并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c(2,3);</span><br><span class="line">c.add(Complex(1,1));</span><br></pre></td></tr></table></figure>

<p>第32 ~ 33行：c是一个非常量类型的对象，可以执行其非常量型成员函数add( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Complex* p = &amp;c;</span><br><span class="line">const Complex&amp; r = c;</span><br><span class="line">//p-&gt;add(Complex(1,1));  //错误：不可以执行常量型对象的非常量型成员函数</span><br><span class="line">//r.add(Complex(1,1));   //错误：不可以执行常量型对象的非常量型成员函数</span><br></pre></td></tr></table></figure>

<p>第35 ~ 38行：p指向一个常量型Complex对象；r是一个常量型Complex对象的引用。不可以通过p或者r执行对象的非常量型成员函数add( )，因为add( )预期可能会修改对象，而常量对象，不应被修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;abs(r) = &quot; &lt;&lt; r.abs() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第40行：对一个常量型对象，执行其常量型成员函数，本例中为abs( )，是合法的。因为常量型成员函数的执行，不会导致对象的修改（mutable类型的数据成员除外）。</p>
<h2 id="15-代码复用"><a href="#15-代码复用" class="headerlink" title="15. 代码复用"></a>15. 代码复用</h2><p>不要重新发明轮子。 — 大家都这么说</p>
<hr>
<p>优秀的程序员擅长两项工作：在设计轮子的时候，努力设计出好轮子。在设计汽车的时候，挑选出好轮子，很好地使用挑选出来的轮子。本章主要讨论后一项工作，如何利用现有的类设计出新的类型，即代码复用（code use）。</p>
<p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<h3 id="15-1-万物皆对象"><a href="#15-1-万物皆对象" class="headerlink" title="15.1 万物皆对象"></a>15.1 万物皆对象</h3><p>Alan Kay总结了第一种面向对象程序设计语言SmallTalk的5个特点，这些特点深刻地刻画了画向对象程序设计的精髓。对于C++, 它们也基本适用。</p>
<p><strong>面向对象程序设计五大特征</strong></p>
<p>① 万物皆对象（Everything is an object）。</p>
<p>② 对象皆有类型（Every object has a type）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = int(0);</span><br><span class="line">Person dora = Person(&quot;Dora Henry&quot;)</span><br></pre></td></tr></table></figure>

<p>在语法意义上，上述代码中的i和dora都是对象，只是类型不同：i为int类型，dora为Person类型。Person(“Dora Henry”)是执行Person类型的构造函数，int(0)则是执行int类型的构造函数，以字面量0为参数。当然，所谓int(0)的构造函数，仅是语法意义上的，编译器实际生成的二进制代码里不存在这样对原生数据类型的构造函数调用。</p>
<p>③ 程序就是由一堆对象构成，对象间通过发送消息协同工作（ A program is a bunch of objects telling each other what to do by sending messages）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dora.eat(100);</span><br></pre></td></tr></table></figure>

<p>在面向对象的术语体系里，执行一个对象的方法，例如执行dora对象的eat( )方法，也称为向该对象发送消息。</p>
<p>④ 每个对象均有自己的存储空间，并由其它对象来构成（Each object has its own memory made up of other objects）。</p>
<p>本书中，我们称作为数据成员参与构成其它对象的对象为<strong>成员对象</strong>。</p>
<p>⑤ 相同类型的对象可以接受相同类型的消息（All objects of a particular type can receive the same messages）。</p>
<h3 id="15-2-组合"><a href="#15-2-组合" class="headerlink" title="15.2 组合"></a>15.2 组合</h3><p>将一台发动机、4个车窗、五把座椅以及其他部件装配起来，可以<strong>组合</strong>出一台轿车。在面向对象程序设计的术语体系里，我们把使用多个不同类型的<strong>成员对象</strong>来构成新类型对象的代码重用方法，称之为组合（composition）。</p>
<p>下述C++代码展示了通过组合方法来构造极简版本轿车的方法，该轿车仅由一个发动机、四个轮胎及一个整数来构成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//Project - CarComposition</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Wheel &#123;</span><br><span class="line">public:</span><br><span class="line">    short iWheelSize;  //轮胎尺寸</span><br><span class="line">    Wheel()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Wheel Constructed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Wheel()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Wheel Destructed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Engine &#123;</span><br><span class="line">private:</span><br><span class="line">    int iCapacity;   //发动机排量</span><br><span class="line">public:</span><br><span class="line">    Engine(int capacity)&#123;</span><br><span class="line">        iCapacity = capacity;</span><br><span class="line">        cout &lt;&lt; &quot;Engine Constructed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Engine()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Engine Destructed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Car &#123;</span><br><span class="line">public:</span><br><span class="line">    Engine e;</span><br><span class="line">    Wheel wheels[4];</span><br><span class="line">    int iWeight;    //整车重量</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    Car(int weight):e(1800), iWeight(weight)&#123;</span><br><span class="line">        //e.start() ...</span><br><span class="line">        cout &lt;&lt; &quot;Car Constructed.&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Car()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Car Destructed.&quot; &lt;&lt; endl;</span><br><span class="line">        //e.stop() ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)\n&quot;);</span><br><span class="line">    printf(&quot;= %d + 4 x %d + %d\n&quot;, sizeof(Engine), sizeof(Wheel), sizeof(int));</span><br><span class="line">    printf(&quot;= %d\n&quot;,sizeof(Car));</span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Car c(2300);</span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    printf(&quot;&amp;c = %p, &amp;c.e = %p\nc.wheels = %p, &amp;c.iWeight = %p\n&quot;,</span><br><span class="line">           &amp;c, &amp;c.e, c.wheels, &amp;c.iWeight);</span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)</span><br><span class="line">= 4 + 4 x 2 + 4</span><br><span class="line">= 16</span><br><span class="line">--------------------------------------</span><br><span class="line">Engine Constructed.</span><br><span class="line">Wheel Constructed.</span><br><span class="line">Wheel Constructed.</span><br><span class="line">Wheel Constructed.</span><br><span class="line">Wheel Constructed.</span><br><span class="line">Car Constructed.</span><br><span class="line">--------------------------------------</span><br><span class="line">&amp;c = 000000000061fe00, &amp;c.e = 000000000061fe00</span><br><span class="line">c.wheels = 000000000061fe04, &amp;c.iWeight = 000000000061fe0c</span><br><span class="line">--------------------------------------</span><br><span class="line">Car Destructed.</span><br><span class="line">Wheel Destructed.</span><br><span class="line">Wheel Destructed.</span><br><span class="line">Wheel Destructed.</span><br><span class="line">Wheel Destructed.</span><br><span class="line">Engine Destructed.</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同。</p>
<p>上述程序中，一个Car类型的对象c由：1个Engine类型的子对象e，4个Wheel类型的子对象数组wheels以及1个int类型的子对象iWeight构成。根据执行结果的第12 ~ 13行，我们绘制了c对象的内存结构，见下图。</p>
<p><img src="http://codelearn.club/images/image-20200317133012191.png" alt="image-20200317133012191"></p>
<p>图15- Car类型对象c的内存结构</p>
<p>如图15- 所示，程序第53行所构造的Car类型的对象c占据从0x0061fe00开始的连续16个字节的空间。编译器以非常节约的方式安排c的成员对象，在作者的计算机上，成员对象按定义顺序依次排列。其中，c.e占据最开始的4个字节；c.wheels占据接下来的8个字节，每个Wheel成员两个字节；c.iWeight占据最后的4个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;sizeof(Engine) + 4 x sizeof(Wheel) + sizeof(int)\n&quot;);</span><br><span class="line">printf(&quot;= %d + 4 x %d + %d\n&quot;, sizeof(Engine), sizeof(Wheel), sizeof(int));</span><br><span class="line">printf(&quot;= %d\n&quot;,sizeof(Car));</span><br></pre></td></tr></table></figure>

<p>第48 ~ 50行：打印各成员对象的尺寸。执行结果的第1 ~ 3行证实，Car对象的尺寸等其全部成员对象的尺寸之和。需要说明的是，由于数据对齐的关系，有时对象的尺寸可能会略大于其成员对象的尺寸之和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car(int weight):e(1800), iWeight(weight)&#123;</span><br><span class="line">    //e.start() ...</span><br><span class="line">    cout &lt;&lt; &quot;Car Constructed.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第36 ~ 39行：根据面向对象程序设计的理论，每个对象的都需要通过构造函数来初始化，成员对象也不例外。当一个Car对象被构造时，其成员对象的构造函数由Car对象的构造函数在函数执行的最开始阶段”隐式“地逐一调用执行。执行结果的第5 ~ 10行显示了因Car的构造而间接被执行的成员对象的构造函数的输出，包括1个Engine成员对象及4个Wheel成员对象，请注意第38行的输出“Car Constructed.”位于各成员对象的构造函数输出之后。</p>
<p>本例中，Wheel的构造函数没有参数，Car的构造函数很容易自动调用其4个Wheel成员对象的构造函数。与此不同，Engine的构造函数有一个名为capacity（发动机排量）的形参，要执行成员对象e的构造函数，必须显式地提供其所需的实参。</p>
<p>语法上，在Car构造函数的函数体开始处，即本例中的第37行，Car对象的全部成员对象，包括e，应该处于已经构造完毕的可用状态。这意味着，成员对象的构造应在第37行之前执行。当成员对象存在零参数的构造函数时，编译器会自动完成这项工作。</p>
<blockquote>
<p><strong>要点🎯</strong> 当成员对象的构造函数要求提供参数时，程序员需要在<strong>构造函数初始化列表（constructor initializer list）</strong>中提供这些参数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car(int weight):e(1800), iWeight(weight)&#123; ...</span><br></pre></td></tr></table></figure>

<p>本例中，第36行冒号之后的部分即为Car的构造函数初始化列表。在该列表中，可以为多个成员对象提供指定构造参数，成员成象之间以逗号分隔。e(1800)表示以实参1800调用成员对象e的构造函数；iWeight(weight)表示以Car构造函数的形参weight作为实参调用成员对象iWeight的构造函数。根据定义，成员对象iWeight的类型为int，这种原生类型在事实上不存在实际的构造函数，但这种语法是允许的。</p>
<blockquote>
<p><strong>注意📢</strong> 需要为成员对象提供构造参数只是我们使用构造函数初始化列表的情形之一。当成员对象是一个引用时，也需要通过构造函数初始化列表将该引用与确定的对象相绑定，因为到了构造函数的函数体，该引用类型的成员对象应该处于初始化完毕的可用状态。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~Car()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Car Destructed.&quot; &lt;&lt; endl;</span><br><span class="line">    //e.stop() ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第41 ~ 44行：根据面向对象程序设计的理论，每个对象的内存被释放前都需要执行其析构函数来完成“清理”，成员对象也不例外。本例中，当变量c超出作用域后，编译器生成的指令会执行c的析构函数。c的构析函数会在函数执行的最后阶段”隐式”地调用执行每个成员对象的析构函数。由于析构函数一定是零参数的，所以这里我们并不需要“析构函数析构列表”的协助。</p>
<p>理论上，在Car的析构函数体的最后一行，对应本例中的第43行，Car对象的全部成员对象应处于尚未被析构的可用状态。因此，Car的成员成员的析构函数的执行一定发生在析构函数的最后阶段，本例中，读者可以认为这些隐式的析构函数调用发生在第44行。</p>
<p>执行结果的第15 ~ 20行反应了Car类型对象c的析构函数的执行结果：先输出了”Car Destructed.”之后，各成员对象的析构函数才在c析构函数的最后阶段被“隐式”执行。在作者的计算机上，成员对象的析构顺序正好与构造顺序相反。</p>
<p>借助于其它类型来组合新的类型是非常有效的代码重用方法。当轿车的油门踏板被踩下时，车控计算机可能一方面增大发动机的喷油量，一方面又提高火花赛的点火频率，来达到将车加速的目的。借助于成员对象的接口及其背后隐藏的实现，站在前人的肩膀上，该任务可以简洁地完成，请参考下述伪代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Car &#123;</span><br><span class="line">...</span><br><span class="line">	void pushSpeedPedal()&#123;</span><br><span class="line">		e.oilPumpIncrease()     //加大喷油量</span><br><span class="line">		e.igniteFreqIncrease()  //提高点火频率</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个轿车对象拥有1台发动机，拥有4个轮胎，这种关系称之为<strong>has-a</strong>关系。<strong>has-a关系最适宜的表达形式就是组合</strong>。</p>
<h3 id="15-3-继承"><a href="#15-3-继承" class="headerlink" title="15.3 继承"></a>15.3 继承</h3><p><strong>继承（inheritence）</strong>是另一种代码重用的方法。当我们试图定义一个雇员类型时，并不需要从身份证号和姓名定义起。在已经有了Person（人）类型之后，我们借助于继承来定义Employee（雇员）类型：</p>
<ul>
<li>雇员是人， 雇员具备人的全部属性和方法；</li>
<li>雇员跟不是雇员的其他人有区别，比如雇员有岗位，有工资，有工号。</li>
</ul>
<p>按照这一思路，我们画出了下述UML类图。</p>
<p><img src="http://codelearn.club/images/image-20200317160720055.png" alt="image-20200317160720055">·图15- 雇员类图</p>
<p>这个类图中，两个框之间的三角形箭头描述了Employee类与Person类之间的继承关系，按该UML类图，我们称Person为<strong>父类</strong>，Employee为<strong>子类</strong>。除了父类与子类之外，还有一些同义术语广泛应用于程序设计范畴，请见下表。</p>
<p>表15- 继承相关术语</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>同义术语</th>
</tr>
</thead>
<tbody><tr>
<td>父类(parent class)</td>
<td>超类(super class)， 基类(base class)</td>
</tr>
<tr>
<td>子类(sub class)</td>
<td>扩展类(derived class)， 继承类(inherited class)</td>
</tr>
</tbody></table>
<p>本节的演示程序分三步实现。</p>
<p><strong>第1步.</strong> 按照14.3节所介绍的标准类实现方法，我们首先在名为EmployeeClass的Non-Qt Project&#x2F;Plain C++ Application中导入了“假装”是别人编写的类型Person，它包含person.h及person.cpp两个文件。</p>
<p>person.h用于存放类声明，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#ifndef PERSON_H</span><br><span class="line">#define PERSON_H</span><br><span class="line"></span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">enum class GenderType&#123;</span><br><span class="line">    male = 0, female = 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">private:</span><br><span class="line">    int iWeight &#123;50000&#125;;    //体重，以克为单位</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    string sName;           //姓名</span><br><span class="line">    string sID;             //身份证号</span><br><span class="line">    GenderType gender = GenderType::female; //性别</span><br><span class="line">    void speak();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Person(const string&amp; id, const string&amp; name);</span><br><span class="line">    void eat(int weight);</span><br><span class="line">    string description();</span><br><span class="line">    ~Person();</span><br><span class="line">&#125;;  //注意末尾的分号不能少</span><br><span class="line"></span><br><span class="line">#endif // PERSON_H</span><br></pre></td></tr></table></figure>

<p>第15 ~ 19行：上述Person类声明与第13章中的Person类相似，区别在于：sName、sID、gender被声明为保护数据成员；speak( )被声明为保护成员函数。 按照语义，保护类成员在类的外部无法访问，但可以在类的继承类&#x2F;子类中访问。</p>
<p>第22行：Person类型的构造函数有两个形参。</p>
<p>person.cpp用于存放类方法定义，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;person.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Person::Person(const string&amp; id, const string&amp; name )&#123;</span><br><span class="line">    sID = id;</span><br><span class="line">    sName = name;</span><br><span class="line">    cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person::~Person()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Person::~Person()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::speak()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Person::speak()&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;I am &quot; &lt;&lt; sName &lt;&lt;&quot;, Nice to meet you here.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::eat(int weight)&#123;</span><br><span class="line">    iWeight += weight;</span><br><span class="line">    cout &lt;&lt; &quot;I just ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Person::description()&#123;</span><br><span class="line">    char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">    sprintf(buffer,&quot;ID:     %s\nName:   %s\nGender: %s\nWeight: %d&quot;,</span><br><span class="line">            sID.c_str(),sName.c_str(),</span><br><span class="line">            gender==GenderType::male?&quot;Male&quot;:&quot;Female&quot;,iWeight);</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第2步.</strong> 在项目中新建一个C++类，名为Employee。该类是Person类的子类，由employee.h及employee.cpp两个文件构成。</p>
<p>employee.h包含Employee的类声明，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef EMPLOYEE_H</span><br><span class="line">#define EMPLOYEE_H</span><br><span class="line">#include &quot;person.h&quot;</span><br><span class="line"></span><br><span class="line">class Employee:public Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    string sEmployeeNo;</span><br><span class="line">    string sJobTitle;</span><br><span class="line">    string sDepartment;</span><br><span class="line"></span><br><span class="line">    Employee(const string&amp; emplNo, const string&amp; id, const string&amp; name);</span><br><span class="line">    ~Employee();</span><br><span class="line"></span><br><span class="line">    void work();</span><br><span class="line">    void speak();</span><br><span class="line">    string description();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // EMPLOYEE_H</span><br></pre></td></tr></table></figure>

<p>第5行：class Employee后面的public Person意为Employee类型从Person类型<strong>公有继承</strong>▲，Person是父类，Employee为子类。作为Person类型的子类，Employee类型通过继承从Person类型获得了其全部数据成员和方法。</p>
<p>第7 ~ 10行：除了从Person类型那里继承而得的属 性之外，Employee类型还扩展定义了雇员编号（sEmployeeNo）、岗位名称（sJobTitle）、所属部门（sDepartment）三个新的属性。</p>
<p>第15 ~ 17行：除了从Person类型那里继承而得的方法之外，Employee类型还扩展声明了work( )方法，这个新方法是父类型Person所不具备的。此外，Employee类型还重新声明了speak( )及description( )方法，这两个方法Person类型原本就有，Employee通过重新声明和定义这两个方法来实现雇员对象speak( )和description( )方法区别于人的不同行为。</p>
<p>employee.cpp包含类方法定义，其内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;employee.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">Employee::Employee(const string&amp; emplNo, const string&amp; id,</span><br><span class="line">                   const string&amp; name):Person(id,name) &#123;</span><br><span class="line">    sEmployeeNo = emplNo;</span><br><span class="line">    cout &lt;&lt; &quot;Employee::Employee()&quot; &lt;&lt; endl;</span><br><span class="line">    //iWeight = 60000; //错误：不可以访问父类的私有成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee::~Employee()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Employee::~Employee()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Employee::work()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;I am a &quot; &lt;&lt; sJobTitle &lt;&lt; &quot;, working in department:&quot;</span><br><span class="line">         &lt;&lt; sDepartment &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Employee::speak()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Employee::speak()&quot; &lt;&lt; endl;</span><br><span class="line">    Person::speak();   //可以访问父类的保护成员函数</span><br><span class="line">    cout &lt;&lt; &quot;I am happy to work for you.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string Employee::description()&#123;</span><br><span class="line">    char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">    sprintf(buffer,&quot;ID:     %s\nName:   %s\nGender: %s\nEmployee No: %s\n&quot;</span><br><span class="line">                   &quot;Job Title: %s\nDepartment: %s&quot;,</span><br><span class="line">            sID.c_str(),sName.c_str(),</span><br><span class="line">            gender==GenderType::male?&quot;Male&quot;:&quot;Female&quot;,sEmployeeNo.c_str(),</span><br><span class="line">            sJobTitle.c_str(),sDepartment.c_str());</span><br><span class="line">    //可以访问gender, sID, sName等父类的保护数据成员</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br><span class="line">Employee::Employee(const string&amp; emplNo, const string&amp; id,</span><br><span class="line">                   const string&amp; name):Person(id,name) &#123;</span><br><span class="line">    sEmployeeNo = emplNo;</span><br><span class="line">    cout &lt;&lt; &quot;Employee::Employee()&quot; &lt;&lt; endl;</span><br><span class="line">    //iWeight = 60000; //错误：不可以访问父类的私有成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第5 ~ 10行：既然雇员是人的子类，那个一个雇员对象必然也是人对象。当一个雇员对象被构造时，必然伴随一个人对象的构造。当人类型存在一个零参数的构造函数时，雇员的构造函数会自动调用人的构造函数来初始化作为雇员对象一部分的“人”的对象。</p>
<p>与<strong>成员对象</strong>sEmployeeNo不同，一个雇员对象内部的人对象是通过继承获得的，这种通过继承获得的对象称为<strong>父对象</strong>。</p>
<p>回顾person.h，应注意到Person类型的构造函数需要身份证号及姓名两个形参。基于与成员对象类似的理由，为了确保雇员对象背后的“人”的部分在第7行变得可用，必须在构造函数初始化列表中为父对象提供参数。第6行的Person(id,name)将Employee构造函数的形参id（身份证号）及name（姓名）作为实参提供给父对象的构造函数。与成员对象不同，父对象没有“名字”，在构造函数初始化列表中使用父对象的类型名（Person）来指代。</p>
<p>第9行：iWeight是父类Person的私有成员，不可以在子类Employee中访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Employee::speak()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Employee::speak()&quot; &lt;&lt; endl;</span><br><span class="line">    Person::speak();   //可以访问父类的保护成员函数</span><br><span class="line">    cout &lt;&lt; &quot;I am happy to work for you.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第21 ~ 25行：子类的方法既可以完全重写，也可以调用执行父类的方法。第23行的Person::speak( )即调用执行了父对象的speak( )方法。Employee::speak( )的this指针的类型为Employee<em>，既然Employee就是Person，那么Employee</em>也就是Person<em>。在调用Person::speak( )时，编译器会把当前this指针当成Person</em>类型”秘密 “传递给Person::speak( )。请注意， speak( )是Person类型的保护成员，允许在子类中访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string Employee::description()&#123;</span><br><span class="line">    char buffer[1024];  //注意缓冲区尺寸，当心溢出</span><br><span class="line">    sprintf(buffer,&quot;ID:     %s\nName:   %s\nGender: %s\nEmployee No: %s\n&quot;</span><br><span class="line">                   &quot;Job Title: %s\nDepartment: %s&quot;,</span><br><span class="line">            sID.c_str(),sName.c_str(),</span><br><span class="line">            gender==GenderType::male?&quot;Male&quot;:&quot;Female&quot;,sEmployeeNo.c_str(),</span><br><span class="line">            sJobTitle.c_str(),sDepartment.c_str());</span><br><span class="line">    //可以访问gender, sID, sName等父类的保护数据成员</span><br><span class="line">    return buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第27 ~ 36行：Employee类型的description( )方法也访问了Person父类的保护数据成员gender、sID及sName。</p>
<p><strong>第3步.</strong> 在main.cpp中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//Project - EmployeeClass</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;employee.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;---------------------construct----------------&quot; &lt;&lt; endl;</span><br><span class="line">    Employee dora(&quot;10001&quot;,&quot;36040200001&quot;,&quot;Dora Henry&quot;);</span><br><span class="line">    dora.sDepartment = &quot;Marketing&quot;;</span><br><span class="line">    dora.sJobTitle = &quot;Sales&quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;---------------------memory map---------------&quot; &lt;&lt; endl;</span><br><span class="line">    printf(&quot;sizeof(Employee) = sizeof(Person) + 3 x sizeof(string)&quot;</span><br><span class="line">           &quot;\n=%lld + 3 x %lld\n=%lld\n&quot;,</span><br><span class="line">           sizeof(Person),sizeof(string),sizeof(Employee));</span><br><span class="line"></span><br><span class="line">    Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址</span><br><span class="line">    printf(&quot;&amp;dora = %p\n&amp;(Parent Object) = %p\n&amp;dora.sEmployeeNo = %p&quot;</span><br><span class="line">           &quot;\n&amp;dora.sJobTitle = %p\n&amp;dora.sDepartment = %p\n&quot;,</span><br><span class="line">           &amp;dora, pDora, &amp;dora.sEmployeeNo,&amp;dora.sJobTitle,&amp;dora.sDepartment);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;---------------------work---------------------&quot; &lt;&lt; endl;</span><br><span class="line">    dora.work();</span><br><span class="line">    cout &lt;&lt; &quot;---------------------speak--------------------&quot; &lt;&lt; endl;</span><br><span class="line">    dora.speak();</span><br><span class="line">    cout &lt;&lt; &quot;---------------------eat----------------------&quot; &lt;&lt; endl;</span><br><span class="line">    dora.eat(220);</span><br><span class="line">    cout &lt;&lt; &quot;---------------------description--------------&quot; &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dora.description() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;---------------------destruct-----------------&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">---------------------construct----------------</span><br><span class="line">Person::Person()</span><br><span class="line">Employee::Employee()</span><br><span class="line">---------------------memory map---------------</span><br><span class="line">sizeof(Employee) = sizeof(Person) + 3 x sizeof(string)</span><br><span class="line">=80 + 3 x 32</span><br><span class="line">=176</span><br><span class="line">&amp;dora = 000000000063fca0</span><br><span class="line">&amp;(Parent Object) = 000000000063fca0</span><br><span class="line">&amp;dora.sEmployeeNo = 000000000063fcf0</span><br><span class="line">&amp;dora.sJobTitle = 000000000063fd10</span><br><span class="line">&amp;dora.sDepartment = 000000000063fd30</span><br><span class="line">---------------------work---------------------</span><br><span class="line">I am a Sales, working in department:Marketing</span><br><span class="line">---------------------speak--------------------</span><br><span class="line">Employee::speak()</span><br><span class="line">Person::speak()</span><br><span class="line">I am Dora Henry, Nice to meet you here.</span><br><span class="line">I am happy to work for you.</span><br><span class="line">---------------------eat----------------------</span><br><span class="line">I just ate 220 gram&#x27;s food.</span><br><span class="line">---------------------description--------------</span><br><span class="line">ID:     36040200001</span><br><span class="line">Name:   Dora Henry</span><br><span class="line">Gender: Female</span><br><span class="line">Employee No: 10001</span><br><span class="line">Job Title: Sales</span><br><span class="line">Department: Marketing</span><br><span class="line">---------------------destruct-----------------</span><br><span class="line">Employee::~Employee()</span><br><span class="line">Person::~Person()</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同，执行结果中的对象大小可能与本书有差异。</p>
<p>上述程序创建了一个Employee类型的对象dora，借助于上述执行结果，我们可以画出dora对象的内存地图如下。</p>
<p><img src="http://codelearn.club/images/image-20200318104833220.png" alt="image-20200318104833220"></p>
<p>图15- Employee类型对象dora的内存结构</p>
<p>如图15- 所示，在一个Employee对象的内存空间内，其Person父对象虽然在逻辑上与其它成员对象有区别，但在内存分配上仍然是Employee对象的组成部分。在作者的计算机上，dora对象占据从0x0061fca0开始的连续176个字节的空间，其中，Person父对象占据最开始的80个字节，然后是Employee的其它数据成员，按定义顺序紧排其后。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------construct----------------&quot; &lt;&lt; endl;</span><br><span class="line">Employee dora(&quot;10001&quot;,&quot;36040200001&quot;,&quot;Dora Henry&quot;);</span><br></pre></td></tr></table></figure>

<p>第7 ~ 8行：定义并构造Employee类型的对象dora。执行结果的第1 ~ 3行对应dora的构造函数的输出。由于父对象是在Employee构造函数的函数体代码之前初始化的，因此，输出结果中，Person::Person( )先于Employee::Employee( )。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------memory map---------------&quot; &lt;&lt; endl;</span><br><span class="line">printf(&quot;sizeof(Employee) = sizeof(Person) + 3 x sizeof(string)&quot;</span><br><span class="line">       &quot;\n=%lld + 3 x %lld\n=%lld\n&quot;,</span><br><span class="line">       sizeof(Person),sizeof(string),sizeof(Employee));</span><br><span class="line"></span><br><span class="line">Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址</span><br><span class="line">printf(&quot;&amp;dora = %p\n&amp;(Parent Object) = %p\n&amp;dora.sEmployeeNo = %p&quot;</span><br><span class="line">       &quot;\n&amp;dora.sJobTitle = %p\n&amp;dora.sDepartment = %p\n&quot;,</span><br><span class="line">       &amp;dora, pDora, &amp;dora.sEmployeeNo,&amp;dora.sJobTitle,&amp;dora.sDepartment);</span><br></pre></td></tr></table></figure>

<p>第12 ~ 20行：输出并研究dora对象的内存结构。</p>
<p>第17行：&amp;dora的类型为Employee<em>，pDora的类型为Person</em>，由于Employee就是Person，所以把类型为Employee<em>的地址赋值给Person</em>类型的指针是合法的。这种从子类型转换为上层父类型的类型转换，称为<strong>向上类型转换（upcasting）</strong>。与成员对象不同，父对象没有名字，作者只能通过这种方法来获取dora对象内部的Person父对象的地址。执行结果的第5 ~ 7行证实，Employee对象的尺寸等于其全部父对象、成员对象的尺寸之和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------work---------------------&quot; &lt;&lt; endl;</span><br><span class="line">dora.work();</span><br></pre></td></tr></table></figure>

<p>第22 ~ 23行：执行dora的work( )方法。这个方法是Employee类型引入的，执行时，dora的地址会作为this指针被“秘密”传入。相关输出见执行结果的第13 ~ 14行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------speak--------------------&quot; &lt;&lt; endl;</span><br><span class="line">dora.speak();</span><br></pre></td></tr></table></figure>

<p>第24 ~ 25行：dora对象的类型为Employee，执行Employee类型的speak( )函数，以dora的地址作为this指针。回顾employee.cpp，会发现该函数调用执行了Person::speak( )。相关输出见执行结果的第15 ~ 19行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------eat----------------------&quot; &lt;&lt; endl;</span><br><span class="line">dora.eat(220);</span><br></pre></td></tr></table></figure>

<p>第26 ~ 27行：dora对象的类型为Employee，但Employee类型没有“自己的”eat( )函数；dora对象的类型也是Person，Person类型有“自己的”eat( )函数。此处，编译器会执行Person类型的eat( )函数，以dora的地址作为this指针。由于dora的类型也是Person，所以其地址也可以视为Person*。相关输出见执行结果的第20 ~ 21行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;---------------------description--------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dora.description() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第28 ~ 29行：dora类型为Employee，执行Employee的description( )函数，以dora的地址为this指针。相关输出见执行结果的第22 ~ 28行。</p>
<p>当dora对象超出其作用域时，编译器会在释放其内存前执行其Employee类型的析构函数。该析构函数会在函数的最后阶段“隐式”地调用执行dora的全部成员对象及父对象的析构函数。在执行结果的第29 ~ 31行中可见，Person::<del>Person( )晚于Employee::</del>Employee( )。</p>
<p>本例中，dora的父对象地址与dora自身的地址完全相同。<strong>如果一个对象有父对象，父对象总是被安排在对象内存的起始处</strong>。这种安排有益于简化对象的地址类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person* pDora = &amp;dora; //通过向上类型转换获得dora对象内的父对象地址</span><br></pre></td></tr></table></figure>

<p>第17行：正是因为父对象位于对象内存的起始处，本行代码的执行变得十分容易，直接把dora的地址赋值给pDora即可。多重继承，通常意味着对象拥有多于一个的父对象。多重继承存在时，这种地址转换就没那么容易了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//dora是Employee类型的对象</span><br><span class="line">Person doraPerson = dora;</span><br></pre></td></tr></table></figure>

<p>上述程序的第2行把Employee类型的dora对象赋值给Person类型的doraPerson对象。逻辑上，dora也是Person类型，上述赋值是合法的。物理上，doraPerson只有sizeof(Person)大，装不下整个Employee对象，所以，仅dora对象内部的Person父对象部分被到doraPerson，其余信息丧失。这种情况很像是从一整块的披萨饼里拿出其中一片，形象称之为<strong>对象切片（object slicing）</strong>。</p>
<p>雇员（Employee）是人（Person），这种关系称为<strong>is-a关系</strong>。<strong>表达is-a关系的最佳形式是继承</strong>。类似的is-a关系还有香蕉是一种水果，泰迪是一种狗，鲸鱼是哺乳动物。</p>
<h3 id="15-4-公有私有及保护继承"><a href="#15-4-公有私有及保护继承" class="headerlink" title="15.4 公有私有及保护继承"></a>15.4 公有私有及保护继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Employee:public Person&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前一节中，Employee对Person的继承是公有继承，这意味着：Person类型的公有成员成为Employee类型的公有成员；Person类型的保护成员成为Employee类型的保护成员。换句话说，Person类型的接口成为Employee类型接口的一部分。</p>
<p>除了公有继承外，语法上也允许私有继承和保护继承，三者的区别列表如下。</p>
<p>表15- 继承方式</p>
<table>
<thead>
<tr>
<th></th>
<th>公有继承</th>
<th>保护继承</th>
<th>私有继承</th>
</tr>
</thead>
<tbody><tr>
<td>基类公有成员变成</td>
<td>派生类公有成员</td>
<td>派生类保护成员</td>
<td>派生类私有成员</td>
</tr>
<tr>
<td>基类保护成员变成</td>
<td>派生类保护成员</td>
<td>派生类保护成员</td>
<td>派生生私有成员</td>
</tr>
</tbody></table>
<p>无论采用何种继承方式，基类的私有成员继承到派生类，均为私有，且无法在派生类中直接访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">private:</span><br><span class="line">    int iPrivate = 0;</span><br><span class="line">protected:</span><br><span class="line">    void protectedMethod()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    float fPublic = 2.2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DerivedA:public Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DerivedB:protected Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DerivedC:private Base&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，基类Base有：私有成员iPrivate、保护成员protectedMethod( )以及公有成员fPublic。DerivedA、DerivedB以及DerivedC类分别以不同的方式继承了基类Base。图15- 解释了三种不同继承方式所带来的不同结果。</p>
<p><img src="http://codelearn.club/images/image-20200318174200905.png" alt="image-20200318174200905"></p>
<p>图15- 继承方式</p>
<p>图15- 中，DerivedA、DerivedB以及DerivedC中，源自基类Base的私有成员iPrivate被画上了删除线，意思是：该成员存在于派生类对象的内存中，但即便在派生类内部，也无法直接访问该成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DerivedA a;</span><br><span class="line">Base* b0 = &amp;a;          //公有继承允许隐式向上类型转换</span><br><span class="line">DerivedB b;</span><br><span class="line">Base* b1 = (Base*)&amp;b;   //保护继承只允许在派生类中进行隐式向上类型转换</span><br><span class="line">DerivedC c;</span><br><span class="line">Base* b2 = (Base*)&amp;c;   //私有继承不允许隐式向上类型转换</span><br></pre></td></tr></table></figure>

<p>此外，不同的继承方式还会导致与向上类型转换有关的差异。上述代码中，第2行将a的地址隐式向上类型转换为Base*，是可以的，公有继承允许隐式向上类型转换。但在第4行、第6行中，这种类型转换必须显式地进行。</p>
<h3 id="15-5-多重继承"><a href="#15-5-多重继承" class="headerlink" title="15.5 多重继承**"></a>15.5 多重继承**</h3><p>一个类型可以有多个父类，这种情况，我们称之为多重继承。请看下述类图。</p>
<p><img src="http://codelearn.club/images/image-20200318175114865.png" alt="image-20200318175114865"></p>
<p>图15- 多重继承</p>
<p>类图15- 描述了一个雇员，既是＂人＂类，也是＂纳税人＂类的情况。读者不必对这个结构感到困惑，因为广义的纳税人包括那些不是自然人的机构，比如一个有限责任公司。简明起见，作者对这些类的属性和方法进行了简化。</p>
<p>反应上述多重继承结构的C++示例程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//Project - MultiInheritence</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    string sID;</span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Person::eat(): &quot; &lt;&lt; weight &lt;&lt; &quot; grams of food.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(const string&amp; id, const string&amp; name)&#123;</span><br><span class="line">        sID = id;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Person::Person()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TaxPayer&#123;</span><br><span class="line">public:</span><br><span class="line">    string sTaxNo;</span><br><span class="line">    bool payTax(float fAmount)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;TaxPayer::payTax(): &quot; &lt;&lt; fAmount &lt;&lt; endl;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    TaxPayer()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;TaxPayer::TaxPayer()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Employee: public Person, public TaxPayer &#123;</span><br><span class="line">public:</span><br><span class="line">    string sEmployeeNo;</span><br><span class="line">    int iWeekSalary = 0;</span><br><span class="line">    void work()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Employee::work()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Employee(const string&amp; id, const string&amp; name, const string&amp; emplNo)</span><br><span class="line">        :Person(id,name), sEmployeeNo(emplNo)&#123; //构造函数初始化列表</span><br><span class="line">        cout &lt;&lt; &quot;Employee::Employee()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;------------------construct----------------------\n&quot;;</span><br><span class="line">    Employee dora(&quot;3604020001&quot;,&quot;Dora Henry&quot;, &quot;10000&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;------------------memory map---------------------\n&quot;;</span><br><span class="line">    printf(&quot;sizeof(Employee) = sizeof(Person) + sizeof(TaxPayer)\n&quot;</span><br><span class="line">           &quot;+ sizeof(string) + sizeof(int)\n&quot;</span><br><span class="line">           &quot;= %lld + %lld + %lld + %lld\n= %lld\n&quot;,</span><br><span class="line">           sizeof(Person),sizeof(TaxPayer),sizeof(string),</span><br><span class="line">           sizeof(int),sizeof(Employee));</span><br><span class="line">    Person* p = &amp;dora;</span><br><span class="line">    TaxPayer* t = &amp;dora;</span><br><span class="line">    printf(&quot;&amp;dora = %p, &amp;(Person Object) = %p\n&quot;</span><br><span class="line">           &quot;&amp;(TaxPayer Object) = %p, &amp;dora.sEmployeeNo = %p\n&quot;</span><br><span class="line">           &quot;&amp;dora.iWeekSalary = %p\n&quot;,</span><br><span class="line">           &amp;dora,p,t,&amp;dora.sEmployeeNo,&amp;dora.iWeekSalary);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;------------------eat----------------------------\n&quot;;</span><br><span class="line">    dora.eat(320);</span><br><span class="line">    cout &lt;&lt; &quot;------------------work---------------------------\n&quot;;</span><br><span class="line">    dora.work();</span><br><span class="line">    cout &lt;&lt; &quot;------------------payTax-------------------------\n&quot;;</span><br><span class="line">    dora.payTax(1000.00);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">------------------construct----------------------</span><br><span class="line">Person::Person()</span><br><span class="line">TaxPayer::TaxPayer()</span><br><span class="line">Employee::Employee()</span><br><span class="line">------------------memory map---------------------</span><br><span class="line">sizeof(Employee) = sizeof(Person) + sizeof(TaxPayer)</span><br><span class="line">+ sizeof(string) + sizeof(int)</span><br><span class="line">= 64 + 32 + 32 + 4</span><br><span class="line">= 136</span><br><span class="line">&amp;dora = 000000000062fce0, &amp;(Person Object) = 000000000062fce0</span><br><span class="line">&amp;(TaxPayer Object) = 000000000062fd20, &amp;dora.sEmployeeNo = 000000000062fd40</span><br><span class="line">&amp;dora.iWeekSalary = 000000000062fd60</span><br><span class="line">------------------eat----------------------------</span><br><span class="line">Person::eat(): 320 grams of food.</span><br><span class="line">------------------work---------------------------</span><br><span class="line">Employee::work()</span><br><span class="line">------------------payTax-------------------------</span><br><span class="line">TaxPayer::payTax(): 1000</span><br></pre></td></tr></table></figure>

<p>说明：在读者的计算机上，执行结果中的地址很可能与本书不同；执行结果中的对象大小可能与本书不同。</p>
<p>上述程序创建了一个Employee类型的对象dora，借助于上述执行结果，我们可以画出dora对象的内存地图如下。</p>
<p><img src="http://codelearn.club/images/image-20200318213636843.png" alt="image-20200318213636843"></p>
<p>图15- 多重继承下的子对象内存结构</p>
<p>本例中，dora对象有两个类型分别为Person和TaxPayer的父对象。如图15- 所示，在作者的计算机上，dora对象占据了起始于0x0062fce0的连续136个字节的内存空间。其中，Person父对象及TaxPayer父对象位于最前端，成员对象sEmployeeNo及iWeekSalary排在后面。出于”数据对齐”的原因，作者的编译器还在末尾留出了4个字节的空白区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;------------------construct----------------------\n&quot;;</span><br><span class="line">Employee dora(&quot;3604020001&quot;,&quot;Dora Henry&quot;, &quot;10000&quot;);</span><br></pre></td></tr></table></figure>

<p>第46 ~ 47行：定义并构造dora对象。执行结果的第1 ~ 4行中，可见因dora的构造而导致的Person父对象、TaxPayer父对象的构造的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person* p = &amp;dora;</span><br></pre></td></tr></table></figure>

<p>第55行：&amp;dora的类型为Employee<em>，p的类型为Person</em>，此处的赋值隐含了向上类型转换。由于Person父对象排在dora对象的最开头，因此p的地址与dora的地址完全相同，见执行结果第10行（0x0062fce0）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaxPayer* t = &amp;dora;</span><br></pre></td></tr></table></figure>

<p>第56行：dora是Employee，也是TaxPayer，因此此处的向上类型转换是合法的。回顾图15- 可以发现，dora对象内部的TaxPayer父对象并不是位于dora对象的最开头，因此，上述赋值并不是简单地把&amp;dora的值“传递”给t，<strong>智慧的编译器自动给&amp;dora加上了一个偏移量，再赋值给t，使得t指向dora对象内部的TaxPayer父对象</strong>。执行结果的第11行可见，t值为0x0062fd20，而dora的地址为0x0062fce0。</p>
<p>由于Employee对象的内存布局是由编译器安排的，所以编译器非常清楚TaxPayer父对象在Employee对象内的位置及其相对于对象启始位置的偏移量。</p>
<p>同样，如果把Employee类型的dora赋值给一个TaxPayer类型的对象，也会发生<strong>对象切片</strong>，仅对象内的TaxPayer父对象部分会被。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;------------------eat----------------------------\n&quot;;</span><br><span class="line">dora.eat(320);</span><br><span class="line">cout &lt;&lt; &quot;------------------work---------------------------\n&quot;;</span><br><span class="line">dora.work();</span><br><span class="line">cout &lt;&lt; &quot;------------------payTax-------------------------\n&quot;;</span><br><span class="line">dora.payTax(1000.00);</span><br></pre></td></tr></table></figure>

<p>第63行：dora的eat( )方法继承自Person类型，编译器会把Person父对象的地址作为this指针传入。</p>
<p>第65行：dora的work( )方法来自Employee类型，编译器会把dora的地址作为this指针传入。</p>
<p>第67行：dora的payTax( )方法来自TaxPayer类型，编译器会把TaxPayer父对象的地址作为this指针传入。同样地，TaxPayer父对象的地址由dora的地址再加上偏移量获得，编译器会主动处理好这些细节。</p>
<p>本节仅讨论了多重继承的最简单应用场景，事实上多重继承极其复杂。【？未写完】</p>
<p>【? name hiding】</p>
<h2 id="16-对象"><a href="#16-对象" class="headerlink" title="16. 对象"></a>16. 对象</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure>

<p>根据语义，上述第2行是把a对象的内容到b对象。当对象的类型是原生数据类型（primitive data type）时，只要把a对象的内存内容按比特原封不动地拷贝到b对象的内存即可。当对象是自定义的复合类型时，问题则要复杂得多。</p>
<h3 id="16-1-赋值与传值"><a href="#16-1-赋值与传值" class="headerlink" title="16.1 赋值与传值"></a>16.1 赋值与传值</h3><p>我们通过下述C++程序来研究当复合类型对象被赋值或者<strong>传值（pass by value）</strong>时的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//Project - Copy</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Circle&#123;</span><br><span class="line">public:</span><br><span class="line">    int x = 0;</span><br><span class="line">    int y = 0;</span><br><span class="line">    float fRadius = 3.2F;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Circle::Circle()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Circle() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Circle::~Circle()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void drawCircle(Circle x)&#123;</span><br><span class="line">    printf(&quot;drawCircle: (%d,%d), r = %f\n&quot;, x.x,x.y,x.fRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    Circle c2(c1);</span><br><span class="line">    Circle c3 = c1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------------------\n&quot;;</span><br><span class="line">    drawCircle(c1);</span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------------------\n&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Circle::Circle()</span><br><span class="line">--------------------------------------------------</span><br><span class="line">drawCircle: (0,0), r = 3.200000</span><br><span class="line">Circle::~Circle()</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Circle::~Circle()</span><br><span class="line">Circle::~Circle()</span><br><span class="line">Circle::~Circle()</span><br></pre></td></tr></table></figure>

<p>上述程序中，我们总共创建了4个Circle类型的对象，分别是：c1、c2、c3以及drawCircle( )的形参对象x。在执行结果中，我们观察到4次析构函数的执行， 但却只观察到构造函数的1次执行。这不符合我们一直强调的对象的创建必然经过构造初始化的理论。接下来我们一边解释代码一边分析。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c1;</span><br></pre></td></tr></table></figure>

<p>第24行：定义并构建Circle类型对象c1。按照常规，c1的内存被分配在栈里，然后编译器调用Circle构造函数来初始化c1。对应执行结果的第1行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c2(c1);</span><br></pre></td></tr></table></figure>

<p>第25行：定义并构建Circle类型的对象c2，与第24行不同，这行代码要求c2对象的内容从c1对象。“<strong>聪明</strong>“的编译器通过下述步骤达成目标。</p>
<ul>
<li>为c2对象分配sizeof(Circle)的内存空间；</li>
<li>执行Circle的<strong>拷贝构造函数（copy constructor）</strong>，以c2的地址为this指针，以c1的引用作为参数。</li>
</ul>
<p><strong>拷贝构造函数是一种特殊的构造函数，它通过从其它对象数据的方法来初始化对象</strong>。本例中，c2对象的构造函数并没有执行，c2事实上是通过拷贝构造函数来完成初始化的。所以本行代码没有在执行结果中产生输出。拷贝构造函数我们在下一节中详细讨论。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c3 = c1;</span><br></pre></td></tr></table></figure>

<p>第26行：同理，先构造c3，再从c1内容是不必要且愚蠢的。所以，编译器仍然选择在c3的内存分配好后，通过执行c3的拷贝构造函数来并初始化c3。本行代码在执行结果中没有产生输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawCircle(c1);</span><br></pre></td></tr></table></figure>

<p>第29行：以c1为实参，调用drawCirlce( )函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void drawCircle(Circle x)&#123;</span><br><span class="line">    printf(&quot;drawCircle: (%d,%d), r = %f\n&quot;, x.x,x.y,x.fRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 21行：如代码所示，实参c1到形参x需要<strong>传值（pass by value）</strong>，在分配好形参x的栈内存后，x的拷贝构造函数将被执行，以c1的引用作为参数。第20行的printf( )输出见执行结果的第3行。输出结果可见，从c1到x的拷贝构造是成功的，x的值与c1完全相同。到了drawCircle( )函数的末尾，局部变量x超出作用域，其析构函数被编译器自动调用，析构的输出见执行结果的第4行。</p>
<p>上述程序执行到main( )函数的结尾，c1、c2及c3被析构，析构的输出对应执行结果的第6 ~ 8行。综上所述，程序所创建的4个Circle对象，只有c1是被正常构造的，其余c2、c3以及x都是通过拷贝构造函数构造的，所以执行结果中只可见1次构造，却存在4次析构。</p>
<h3 id="16-2-拷贝构造"><a href="#16-2-拷贝构造" class="headerlink" title="16.2 拷贝构造"></a>16.2 拷贝构造</h3><p>接下来我们给前节中的Circle类型添加拷贝构造函数，来观察拷贝构造的执行过程。C++程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Project - CircleCopy</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Circle&#123;</span><br><span class="line">public:</span><br><span class="line">    int x = 0;</span><br><span class="line">    int y = 0;</span><br><span class="line">    float fRadius = 3.2F;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Circle::Circle()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Circle(const Circle&amp; r):x(r.x),y(r.y)&#123;</span><br><span class="line">        fRadius = r.fRadius;</span><br><span class="line">        cout &lt;&lt; &quot;Circle::Circle(const Circle&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Circle() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Circle::~Circle()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void drawCircle(Circle x)&#123;</span><br><span class="line">    printf(&quot;drawCircle: (%d,%d), r = %f\n&quot;, x.x,x.y,x.fRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Circle c1;</span><br><span class="line">    Circle c2 = c1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------------------\n&quot;;</span><br><span class="line">    c1.fRadius = 999.01F;</span><br><span class="line">    drawCircle(c1);</span><br><span class="line">    cout &lt;&lt; &quot;--------------------------------------------------\n&quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Circle::Circle()</span><br><span class="line">Circle::Circle(const Circle&amp;)</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Circle::Circle(const Circle&amp;)</span><br><span class="line">drawCircle: (0,0), r = 999.010010</span><br><span class="line">Circle::~Circle()</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Circle::~Circle()</span><br><span class="line">Circle::~Circle()</span><br></pre></td></tr></table></figure>

<p>第14 ~ 17行：为Circle类型定义了拷贝构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle(const Circle&amp; r):x(r.x),y(r.y)&#123;</span><br><span class="line">    fRadius = r.fRadius;</span><br><span class="line">    cout &lt;&lt; &quot;Circle::Circle(const Circle&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同构造函数一样，拷贝构造函数的函数名与类名相同，且没有返回值。同构造函数不一样，拷贝构造函数有一个形参，其类型为该类的常量型引用。一般地，拷贝构造函数的任务是：从形参r其全部数据成员至本对象的对应成员。本例中，作者故意通过构造函数初始化列表来拷贝对象的x及y成员，以便提醒读者：拷贝构造函数也有构造函数初始化列表，对象的父对象如果有形参，可以在构造函数初始化列表中提供实参。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c1;</span><br></pre></td></tr></table></figure>

<p>第29行：c1通过构造函数初始化，对应执行结果的第1行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle c2 = c1;</span><br></pre></td></tr></table></figure>

<p>第30行：c2通过拷贝构造函数初始化，其形参r即为c1的引用。相关输出对应执行结果的第2行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1.fRadius = 999.01F;</span><br><span class="line">drawCircle(c1);</span><br></pre></td></tr></table></figure>

<p>第33 ~ 34行：传值调用drawCircle( )函数。如前所述，drawCircle( )的形参对象x通过拷贝构造函数从c1内容。x的拷贝构造对应执行结果的第4行。从执行结果的第5行可见，我们自定义的拷贝构造函数成功了c1的内容（r &#x3D; 999.01）。在drawCircle( )函数的末尾，x被析构，对应执行结果的第6行。</p>
<p>上述事实提醒我们，<strong>对于非原始数据类型，在传参时应尽量传递常量型引用，而不是传值</strong>。因为传值本身会带来至少两次额外的函数调用：拷贝构造以及析构。当对象本身较大时，例如包含一幅图像的对象，传值的代价非常高。</p>
<p>上述程序执行到main( )函数的结尾，c1、c2被析构，析构的输出对应执行结果的第8 ~ 9行。</p>
<h3 id="16-3-默认拷贝构造函数"><a href="#16-3-默认拷贝构造函数" class="headerlink" title="16.3 默认拷贝构造函数"></a>16.3 默认拷贝构造函数</h3><p>在16.1节当中，我们并没有为Circle类型定义拷贝构造函数，但从程序执行结果看，对象仍然获得了正确的。当自定义类型没有定义拷贝构造函数时，编译器会为其生成一个默认的拷贝构造函数，该拷贝构造函数会：<strong>逐一通过拷贝构造来对象的全部成员对象及父对象；当成员对象是原生数据类型时，则按比特</strong>。</p>
<p>我们通过下述C++程序来观察默认拷贝构造函数的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Project - DefaultCopyConstructor</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point &#123;     //点类</span><br><span class="line">public:</span><br><span class="line">    int x = 0;</span><br><span class="line">    int y = 0;</span><br><span class="line">    Point(const Point&amp; r)&#123;</span><br><span class="line">        x = r.x;  y = r.y;</span><br><span class="line">        printf(&quot;Point::Point(const Point&amp;) - (%d,%d)\n&quot;,x,y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point()&#123;&#125;     //显式定义构造函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle &#123; //矩形类</span><br><span class="line">public:</span><br><span class="line">    Point ptTL;   //左上角坐标点</span><br><span class="line">    Point ptBR;   //右下角坐标点</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Rectangle r1;</span><br><span class="line">    r1.ptTL.x = r1.ptTL.y = 100;</span><br><span class="line">    r1.ptBR.x = r1.ptBR.y = 900;</span><br><span class="line"></span><br><span class="line">    Rectangle r2 = r1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point::Point(const Point&amp;) - (100,100)</span><br><span class="line">Point::Point(const Point&amp;) - (900,900)</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们描述了一个矩形类Rectangle，该类包含两个Point类型的成员对象ptTL以及ptBR，分别代表矩形的左上（<strong>T</strong>op <strong>L</strong>eft）角及右下（<strong>B</strong>ottom <strong>R</strong>ight）角坐标。</p>
<p>我们没有为Rectangle类型定义拷贝构造函数，当Rectangle对象被拷贝构造时，默认拷贝构造函数将被执行。</p>
<p>我们为Point类型自定义了拷贝构造函数，以便于观察当Rectangle对象被拷贝构造时，其成员对象的行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point()&#123;&#125;     //显式定义构造函数</span><br></pre></td></tr></table></figure>

<p>第14行：当Point类存在自定义拷贝构造函数时，出乎我们的意料，编译器选择不为Point生成默认构造函数（或者说编译器为Point生成了一个私有的默认构造函数）。与此同时，Rectangle的默认构造函数需要借助于Point的构造函数来初始化ptTL及ptBR。为了保证程序的正确编译，我们不得不为Point手工定义一个零参数公有构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r1;</span><br></pre></td></tr></table></figure>

<p>第24行：通过默认构造函数构建对象r1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r2 = r1;</span><br></pre></td></tr></table></figure>

<p>第28行：通过Rectangle的默认拷贝构造函数从r1拷贝构造r2。执行结果中，我们可以看到：r2的两个成员对象ptTL、ptBR的拷贝构造函数被依次执行。</p>
<p>考虑下述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r1;</span><br><span class="line">Rectangle r2;</span><br><span class="line">r2 = r1;</span><br></pre></td></tr></table></figure>

<p>在第3行执行之前的第2行，r2已经被构造。在第3行，编译器不可能对一个已经存在且初始化完毕的对象r2再次执行拷贝构造函数，从r1到r2的赋值就是普通的对成员对象的逐一赋值。在后续的”操作符重载”章节，我们将深入讨论这种赋值行为。</p>
<h3 id="16-4-深拷贝"><a href="#16-4-深拷贝" class="headerlink" title="16.4 深拷贝"></a>16.4 深拷贝</h3><p>编译器为类型生成的默认拷贝构造函数大多数时候符合我们的需要。但是，当对象内部存在动态成员对象时，默认的拷贝构造函数则十分危险。</p>
<p>如前所述，C++的标准模板库中的string对象仅有32个字节大小（其它编译器下可能是其它值），其包含的字符串事实上存储在动态申请的堆空间内，string对象内部包含一个指针指向申请的堆空间。这种结构使得string类型的对象可以“容纳”几乎无限大的字符串。</p>
<p>下述C++程序中，我们自定义了UserString类型来存储字符串，其结构模仿string类型。</p>
<blockquote>
<p><strong>警告🚩</strong> UserString程序的执行可能会异常中止！读者如果无法得到与本书类似的执行结果，请删除代码的第30 ~ 31行。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//Project - UserString</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void assign(const char* s)&#123;</span><br><span class="line">        unsigned long long sizeNeeded = strlen(s) + 1;</span><br><span class="line">        if (size &gt;= sizeNeeded)   //缓冲区够用，直接</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        else &#123;</span><br><span class="line">            if (buffer!=nullptr)  //缓冲区不够用，重新申请后再</span><br><span class="line">                free(buffer);</span><br><span class="line">            size = sizeNeeded;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const char* content()&#123;</span><br><span class="line">        return buffer;           //返回字符数组的地址</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~UserString()&#123;</span><br><span class="line">        if (buffer!=nullptr)</span><br><span class="line">            free(buffer);       //释放缓冲区,危险！</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    UserString s1;</span><br><span class="line">    s1.assign(&quot;New coronavirus believed to be derived from bats.&quot;);</span><br><span class="line"></span><br><span class="line">    UserString s2 = s1;      //默认拷贝构造</span><br><span class="line">    s2.assign(&quot;Human beings will win!&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1.content() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2.content() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = Human beings will win!</span><br><span class="line">s2 = Human beings will win!</span><br></pre></td></tr></table></figure>

<p>我们先解释UserString类型的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>第6 ~ 9行：私有指针buffer指向申请的堆空间，该空间称为缓冲区，用于存储实际的字符串。该指针为空时，表示对象尚未申请堆空间。<strong>在物理上，存储实际字符串的缓冲区不在对象内部，但逻辑上，我们应认为缓冲区是对象的构成部分</strong>。私有无符号长整数size表示“拥有”的堆空间的字节数，默认值为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    void assign(const char* s)&#123;</span><br><span class="line">        unsigned long long sizeNeeded = strlen(s) + 1;</span><br><span class="line">        if (size &gt;= sizeNeeded)   //缓冲区够用，直接</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        else &#123;</span><br><span class="line">            if (buffer!=nullptr)  //缓冲区不够用，重新申请后再</span><br><span class="line">                free(buffer);</span><br><span class="line">            size = sizeNeeded;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 23行：assign( )成员函数负责把参数字符串赋值给对象。</p>
<p>第13行：通过求参数字符串的长度再加1得到需要的存储空间字节数sizeNeeded。</p>
<p>第14 ~ 22行：如果当前对象拥有的缓冲区尺寸大于等于sizeNeeded，直接参数字符串至缓冲区。否则，释放已有的缓冲区，重新申请后再行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char* content()&#123;</span><br><span class="line">    return buffer;           //返回字符数组的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第25 ~ 27行：content( )成员函数用于获取私有的缓冲区地址。程序的42 ~ 43行利用该函数所返回的缓冲区地址来打印字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~UserString()&#123;</span><br><span class="line">    if (buffer!=nullptr)</span><br><span class="line">        free(buffer);       //释放缓冲区,危险！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第29 ~ 32行：析构函数进行对象清理，如果发现存在缓冲区，进行释放。在本例中，这种释放行为可能会导致程序崩溃，原因稍后解释。</p>
<p>接下来解释main( )函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserString s1;</span><br><span class="line">s1.assign(&quot;New coronavirus believed to be derived from bats.&quot;);</span><br></pre></td></tr></table></figure>

<p>第36 ~ 37行：定义并构建UserString类型的对象s1。执行s1的assign( )成员函数将参数字符串赋值给s1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserString s2 = s1;      //默认拷贝构造</span><br></pre></td></tr></table></figure>

<p>第39行：UserString没有定义拷贝构造函数，本行执行UserString的默认拷贝构造函数完成从s1到s2的。按照期望，完成以后，s2应满足如下要求：</p>
<ul>
<li>内容与s1相同；</li>
<li>与s1相互独立，互不相关。</li>
</ul>
<p><img src="http://codelearn.club/images/image-20200319221257186.png" alt="image-20200319221257186"></p>
<p>图16- 期望的拷贝构造结果</p>
<p>图16- 展示了作者期望的拷贝结果：物理上不属于逻辑上属于s1的缓冲区部分也被完整，拷贝构造完成后，s1和s2相互独立。</p>
<p>但事实上，默认的拷贝构造函数的行为是逐一就对象的每个成员对象（包括父对象）进行拷贝构造。其中，char*类型的buffer就是一个地址，该地址被直接从s1到s2。</p>
<p><img src="http://codelearn.club/images/image-20200319221832667.png" alt="image-20200319221832667"></p>
<p>图16- 事实上的拷贝构造结果</p>
<p>图16- 展示了事实上的拷贝构造结果：s1和s2的buffer指针指向同一块堆内存，两者并不独立。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2.assign(&quot;Human beings will win!&quot;);</span><br></pre></td></tr></table></figure>

<p>第40行：执行s2的assign( )函数将参数字符串赋值给s2。由于新字符串的长度比s2.buffer指向的内存块要小，因此，assign( )函数直接把参数字符串拷贝到s2.buffer指向的内存块。请注意，由于s1.buffer等于s2.buffer，所以上述函数执行后，从s1的角度看，它的缓冲区也被修改了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1.content() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2.content() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第42 ~ 43行：输出s1和s2所包含的“字符串”。执行结果的证实，s2的assign( )同时导致了s1的被修改。这不是我们期望的。</p>
<p>程序更大的危险来自于s1和s2的析构。按照顺序，s2先被析构，其析构函数将会释放s2.buffer。接下来，s1被析构，由于s1的buffer指针与s2相同且不为空，s1的析构函数将释放s1.buffer，这意味着，<strong>我们先后两次释放同一块堆内存，这很可能导致程序崩溃</strong>。</p>
<p>这种由默认拷贝构造函数所主导的对象称之为<strong>浅拷贝（shallow copy）</strong>，对于那些包含动态成员对象的对象，<strong>深拷贝（deep copy）</strong>是必要的。深拷贝的基本方法，就是自定义拷贝构造函数，将对象的动态部分也进行。</p>
<p>下面是修改过后的正确程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Project - DeepCopy</span><br><span class="line">...</span><br><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void assign(const char* s)&#123; ... &#125;</span><br><span class="line">    const char* content()&#123; ... &#125;</span><br><span class="line">    ~UserString()&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    UserString(const UserString&amp; r)&#123;</span><br><span class="line">        size = r.size;</span><br><span class="line">        if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,r.buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //自定义拷贝构造函数导致编译器放弃为类型准备公有的默认构造函数</span><br><span class="line">    UserString()&#123;&#125;             //不可或缺</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    UserString s1;</span><br><span class="line">    s1.assign(&quot;New coronavirus believed to be derived from bats.&quot;);</span><br><span class="line"></span><br><span class="line">    UserString s2 = s1;      //默认拷贝构造</span><br><span class="line">    s2.assign(&quot;Human beings will win!&quot;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1.content() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2.content() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = New coronavirus believed to be derived from bats.</span><br><span class="line">s2 = Human beings will win!</span><br></pre></td></tr></table></figure>

<p>第13 ~ 19行：自定义的拷贝构造函数并没有直接从被拷贝对象buffer指针，而是新申请了一块同等大小的内存，并从被拷贝对象了字符串内容。</p>
<p>s1到s2的拷贝构造完成后，两者完全独立，对s2的修改不再影响s1，执行结果可见：两个对象包含着不一样的字符串。当两个对象各自析构时，也是安全的，因为各自释放各自的buffer，互不相干。</p>
<blockquote>
<p><strong>警告🚩</strong> UserString类型的深拷贝做得并不完美，还缺少一个自定义operator&#x3D;操作符成员函数。相关内容见17.4节。</p>
</blockquote>
<h3 id="16-5-私有拷贝构造函数"><a href="#16-5-私有拷贝构造函数" class="headerlink" title="16.5 私有拷贝构造函数"></a>16.5 私有拷贝构造函数</h3><p>读者可能会问：何时应该给自定义类型设计拷贝构造函数？</p>
<p>如果类型不包含动态成员对象，直接使用默认的拷贝构造函数是安全的。如果包含动态成员对象，则最好为其设计拷贝构造函数。当然，也可以不设计，前提是将拷贝构造函数私有化，以避免对象的传值及其它拷贝构造行为。</p>
<p>C++示例程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Project - PrivateCopyConstructor</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class UserString&#123;</span><br><span class="line">public:</span><br><span class="line">    //...</span><br><span class="line">    UserString()&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    UserString(const UserString&amp; r)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void output(const UserString&amp; s)&#123;</span><br><span class="line">    //...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    UserString s1;</span><br><span class="line">    //UserString s2 = s1; //错误：不可以调用私有的拷贝构造函数</span><br><span class="line">    UserString&amp; s2 = s1;</span><br><span class="line"></span><br><span class="line">    output(s1);           //传引用，不导致拷贝构造</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第10行：设计了一个函数体为空的私有的拷贝构造函数。因其私有不可能被调用，函数体为空是合理的。</p>
<p>第20行：这种行为将导致s2的拷贝构造函数被执行，但私有的拷贝构造函数不可调用，编译器会拒绝。</p>
<p>第21行：对s1进行引用是合法的。</p>
<p>第23行：如果传值给output( )，将导致非法的拷贝构造，但传引用是允许的。</p>
<h2 id="17-操作符重载"><a href="#17-操作符重载" class="headerlink" title="17. 操作符重载"></a>17. 操作符重载</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>终于到了解开cout &lt;&lt; “Hello World”之谜的时间。请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Project - COUT</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;pi = &quot; &lt;&lt; 3.14159 &lt;&lt; endl;</span><br><span class="line">    operator&lt;&lt;(cout,&quot;pi = &quot;).operator&lt;&lt;(3.14159).operator&lt;&lt;(endl);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi = 3.14159</span><br><span class="line">pi = 3.14159</span><br></pre></td></tr></table></figure>

<p>程序的第6行与第7行完全等价。相关代码的执行过程如下：</p>
<ul>
<li>cout &lt;&lt; “pi &#x3D; “的实质是执行了一个名为operator&lt;&lt;( )的函数，其中，第1个参数是cout对象，第2个参数是”pi &#x3D; “。这个函数把第2个参数的字符串输出到第1个参数所代表的控制台中。同时，该函数返回了cout的引用作为函数执行的结果。</li>
<li>… &lt;&lt; 3.141519则以前述函数调用所返回的cout引用作为基础，执行其成员函数operator&lt;&lt;( )。该成员函数存在多个函数名重载的版本，其中一个版本接受一个double作为参数，并将double的值输出到cout。同样地，本次函数调用也返回了cout的引用作为结果。</li>
<li>类似地，… &lt;&lt; endl同样对应cout.operator&lt;&lt;( )函数的一次执行，该成员函数的一个重载版本接受endl作为参数，并向cout所代表的控制台输出一个换行符。</li>
</ul>
<p>&lt;&lt;操作符在C语言里用作左移位操作，C++的标准模板库通过定义与该操作符“同名”的函数，扩展了该操作符的功能：向cout输出对象内容。</p>
<blockquote>
<p><strong>要点🎯</strong> 通过定义操作符函数来扩展操作符功能的方法，称之为<strong>操作符重载（operator overloading）</strong>。</p>
</blockquote>
<h3 id="17-1-复数类"><a href="#17-1-复数类" class="headerlink" title="17.1 复数类"></a>17.1 复数类</h3><p>为讲解方便，我们设计了如下的复数类型。该复数类型包含两个成员对象：dReal（实部）及dImage（虚部）。在数学上，我们知道复数的加法就是实部加实部，虚部加虚部。在C++里，作为代码“介绍”给编译器的新类型，编译器并不知道如何把两个复数相加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexClass</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">    double dReal;</span><br><span class="line">    double dImage;</span><br><span class="line"></span><br><span class="line">    Complex(double real, double image)&#123;</span><br><span class="line">        dReal = real; dImage = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex add(const Complex&amp; r)&#123;</span><br><span class="line">        return Complex(dReal+r.dReal,dImage+r.dImage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(1,3);</span><br><span class="line">    Complex b(2,4);</span><br><span class="line"></span><br><span class="line">    Complex c = a.add(b);</span><br><span class="line">    printf(&quot;a + b = %.2f + %.2fi\n&quot;, c.dReal,c.dImage);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b = 3.00 + 7.00i</span><br></pre></td></tr></table></figure>

<p>为了解决复数间加法运算的问题，上述代码为Complex类型设计了一个add( )成员函数，a.add(b)将复数a与b相加，返回一个结果复数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex add(const Complex&amp; r)&#123;</span><br><span class="line">    return Complex(dReal+r.dReal,dImage+r.dImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 16行：成员函数add( )。第15行生成的Complex对象是一个临时对象，在函数调用完成后， 该临时对象会被销毁。所以add( )函数选择通过传值来返回执行结果，其返回类型为Complex，而不是Complex的引用。</p>
<blockquote>
<p><strong>警告🚩</strong> 永远不要返回函数内局部变量或者临时对象的地址或者引用。</p>
</blockquote>
<h3 id="17-2-操作符"><a href="#17-2-操作符" class="headerlink" title="17.2 +操作符"></a>17.2 +操作符</h3><p>复数类的使用者更喜欢使用下述格式来进行复数的加法运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b;</span><br></pre></td></tr></table></figure>

<p>这可以通过重载+号操作符来实现，其中一种方法就是为Complex类定义一个名为operator+的函数。 相关C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexAdd</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">	...</span><br><span class="line">    Complex operator+(const Complex&amp; r) const&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Complex::operator+()&quot; &lt;&lt; endl;</span><br><span class="line">        return Complex(dReal+r.dReal,dImage+r.dImage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(1,3);</span><br><span class="line">    Complex b(2,4);</span><br><span class="line"></span><br><span class="line">    Complex c = a + b;</span><br><span class="line">    printf(&quot;a + b = %.2f + %.2fi\n&quot;, c.dReal, c.dImage);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex::operator+()</span><br><span class="line">a + b = 3.00 + 7.00i</span><br></pre></td></tr></table></figure>

<p>第8 ~ 11行：为Complex类型定义名为operator+的重载操作符函数。</p>
<p>+号操作符是所谓二元操作符，其典型语法格式为a + b，它应该有两个操作数。作为成员函数的operator+( )的执行，必然是以某个对象的基础的，被执行该函数的对象，被视为左操作数，即典型语法中的a。所以，operator+( )的形参只要定义右操作符即可，考虑到在加法运算过程中，右操作符不应该被修改，所以形参的类型被定义为const Complex&amp;。同样地，该函数的执行预期也不应该修改对象本身（左操作符），故将其定义成常量型成员函数。</p>
<p>第9行：向控制台输出一行文字，提示函数的执行。</p>
<p>第10行：将对象（左操作数）的实部与形参r（右操作数）的实部相加，得结果复数的实部；将对象的虚部与形参r的虚部相加，得结果复数的虚部。然后再构造一个临时的Complex对象并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c = a + b;</span><br></pre></td></tr></table></figure>

<p>第18行：a + b被编译器解释为a.operator+(b)，即把a当成左操作数，执行a的operator+( )成员函数，以b的引用为参数。该函数的返回值通过拷贝构造到c。</p>
<p>执行结果证明，a的operator+( )成员函数被成功执行，结果正确。</p>
<blockquote>
<p><strong>要点🎯</strong> 重载的操作符函数既可以设计为类的成员函数，也可以设计为全局函数。</p>
</blockquote>
<p>全局的重载操作符函数请见下述C++示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Project - GlobalOperatorPlus</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;	... &#125;;</span><br><span class="line"></span><br><span class="line">Complex operator+(const Complex&amp; op1, const Complex&amp; op2)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator+(const Complex&amp;, const Complex&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">    return Complex(op1.dReal+op2.dReal,op1.dImage+op2.dImage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(1,3);</span><br><span class="line">    Complex b(2,4);</span><br><span class="line"></span><br><span class="line">    Complex c = a + b;</span><br><span class="line">    printf(&quot;a + b = %.2f + %.2fi\n&quot;, c.dReal, c.dImage);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator+(const Complex&amp;, const Complex&amp;)</span><br><span class="line">a + b = 3.00 + 7.00i</span><br></pre></td></tr></table></figure>

<p>第7 ~ 10行：定义了一个名为operator+的全局函数，该函数接受两个const Complex&amp;作为参数。在函数体内，将两个参数相加，并返回结果复数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex c = a + b;</span><br></pre></td></tr></table></figure>

<p>第16行：a + b被编译器解释为operator+(a,b)，该函数的执行结果被拷贝构造给c。</p>
<p>执行结果佐证了operator+(a,b)的执行以及结果的正确。</p>
<p>读者可能会问：如果前述例子中作为成员函数的operator+( )与作为全局函数的operator+( )同时存在，编译器会选择哪一个呢？ 作者的建议是，不必关心。一个优秀程序员需要关心的是在程序编写过程中避免这种歧义状况的发生。</p>
<blockquote>
<p><strong>要点🎯</strong> 同加法操作符类似，减法、乘法、除法也是二元操作符，其重载方法与operator+类似，它们对应的操作符重载函数名分别是operator-、operator<em>以及operator&#x2F;。+&#x3D;、-&#x3D;、&#x2F;&#x3D;、</em>&#x3D;也是二元操作符，重载方法大体相同，它们对应的操作符重载函数名分别为operator+&#x3D; 、operator-&#x3D; 、operator&#x2F;&#x3D; 、operator*&#x3D;。</p>
</blockquote>
<h3 id="17-3"><a href="#17-3" class="headerlink" title="17.3 &lt;&lt;操作符"></a>17.3 &lt;&lt;操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;a + b = %.2f + %.2fi\n&quot;, c.dReal, c.dImage);</span><br></pre></td></tr></table></figure>

<p>前两节的示例中， 我们使用printf( )函数来完成复数输出，这不够方便。现在Complex类型的使用者提出了新的要求，他希望下述代码能将复数c输出至控制台：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex c;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>cout对象的类型为ostream，它是由iostream头文件引入的，而iostream是C++标准模板库的组成部分。显然，我们不太可能也不应该去修改标准模板库，为ostream类型增加一个接受Complex对象的operator&lt;&lt;成员函数。所以，我们选择添加一个全局函数operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)。</p>
<p>C++程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexOutput</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)&#123;</span><br><span class="line">    o &lt;&lt; c.dReal &lt;&lt; &quot; + &quot; &lt;&lt; c.dImage &lt;&lt; &quot;i&quot;;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(1,3);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    operator&lt;&lt;(cout,a).operator&lt;&lt;(endl);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 3i</span><br><span class="line">1 + 3i</span><br></pre></td></tr></table></figure>

<p>第7 ~ 10行：除了将形参复数c输出到ostream&amp;类型的形参o之外，全局操作符函数operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)还将形参o作为返回值返回。</p>
<p>第14行：cout并不存在一个接受Complex对象为参数的operator&lt;&lt;成员函数。编译器将cout &lt;&lt; a解释为operator&lt;&lt;(cout, a)。该函数返回cout自身的引用作为返回值，以该返回值为基础，ostream的operator&lt;&lt;成员函数被执行，以endl为参数。</p>
<p>第15行：与第14行完全等价。</p>
<h3 id="17-4-操作符"><a href="#17-4-操作符" class="headerlink" title="17.4 &#x3D;操作符"></a>17.4 &#x3D;操作符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Complex a(1,3);		//构造函数被执行</span><br><span class="line">Complex b(a);		//拷贝构造函数被执行</span><br><span class="line">Complex c = a;		//拷贝构造函数被执行</span><br><span class="line">c = a;				//operator=操作符函数被执行</span><br></pre></td></tr></table></figure>

<p>上述代码的第4行与第2 ~ 3行有一个重大区别：在赋值操作执行前，被赋值对象已经存在了。显然，对一个已经存在的对象再次应用拷贝构造函数进行初始化是不恰当的，编译器会执行c对象的operator&#x3D;操作符函数，以a为参数。</p>
<blockquote>
<p><strong>要点🎯</strong> 当一个对象不存在适用的自定义的operator&#x3D;操作符函数时，编译器会执行默认operator&#x3D;操作符函数。该函数：逐一通过operator&#x3D;操作符函数来对象的全部成员对象及父对象；当成员对象是原生数据类型时，则按比特。</p>
</blockquote>
<blockquote>
<p><strong>要点🎯</strong> 当赋值行为发生时，如果&#x3D;操作符的左值对象已构造完毕（上述代码第4行），编译器会执行operator&#x3D;操作符函数；如果左值对象尚未构造（上述代码第3行），编译器会执行拷贝构造函数。</p>
</blockquote>
<p>下述C++程序演示了Complex类型的自定义operator&#x3D;成员函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexAssignment</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    const Complex&amp; operator=(const Complex&amp; r)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Complex::operator=()&quot; &lt;&lt; endl;</span><br><span class="line">        dReal = r.dReal;  dImage = r.dImage;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex a(1,3), b(2,3), c(1,5);</span><br><span class="line">    c = b = a;</span><br><span class="line">    c.operator=(b.operator=(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Complex::operator=()</span><br><span class="line">Complex::operator=()</span><br><span class="line">Complex::operator=()</span><br><span class="line">Complex::operator=()</span><br></pre></td></tr></table></figure>

<p>第8 ~ 12行：如本书第3章所述，赋值操作符除了赋值外，还会返回一个对象作为赋值表达式的值，该返回对象可以做为另一个赋值操作符的右值对象。Complex的operator&#x3D;成员函数返回值类型被设定为const Complex&amp;，函数体试图返回对象自身作为返回值，但由于this指针的类型是Complex<em>，需要加上</em>操作符以便符合返回值的类型要求。</p>
<p>第17行：c &#x3D; b &#x3D; a的执行过程分为两步。</p>
<ul>
<li>b &#x3D; a部分先被执行，其对应代码为b.operator&#x3D;(a)。按照operator&#x3D;操作符函数的代码，该次执行返回b自身的引用。</li>
<li>上一步返回的引用作为右值赋值给c对象，其对应代码为c.operator&#x3D;(上一步返回值)。</li>
</ul>
<p>两次operator&#x3D;函数的调用输出对应执行结果的第1 ~ 2行。</p>
<p>第18行：与第17行完全等价，对应执行结果的第3 ~ 4行。</p>
<p>上述operator&#x3D;成员函数的返回类型也可以定义为void，即只进行赋值操作，不返回赋值表达式的值。此时，下述代码的第1行合法，第2行非法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = a;          //合法，执行b.operator=(a)</span><br><span class="line">c = b = a;      //非法，b = a没有返回值，c = 部分缺少右值对象</span><br></pre></td></tr></table></figure>

<p>如果期望把一个double对象赋值给一个Complex对象，第1种方法是对operator&#x3D;操作符函数进行函数名重载，见下述C++示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexDouble</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">	...</span><br><span class="line">    const Complex&amp; operator=(const Complex&amp; r)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    const Complex&amp; operator=(const double r)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Complex::operator=(const double)&quot; &lt;&lt; endl;</span><br><span class="line">        dReal = r;  dImage = 0;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex c(1,5);</span><br><span class="line">    c = 3.14;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex::operator=(const double)</span><br></pre></td></tr></table></figure>

<p>可见，Complex类有两个operator&#x3D;成员函数，其中一个接受const Complex&amp;作为参数，另一个接受const double作为参数。</p>
<p>第19行：将double类型的字面量3.14赋值给c，编译器选择执行c.operator&#x3D;(const double)。执行结果做出了佐证。</p>
<p>可以想象，如果第19行改为c &#x3D; 3，3是一个整数字面量，编译器会将3隐式类型转换成double，再执行对应的operator&#x3D;(const double)成员函数。</p>
<h3 id="17-5-构造函数类型转换"><a href="#17-5-构造函数类型转换" class="headerlink" title="17.5 构造函数类型转换"></a>17.5 构造函数类型转换</h3><p>将一个double类型对象赋值给一个Complex类型对象的第2种方法是为Complex类型定义一个参数为double的构造函数，请见下述C++示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Project - ConstructorTypeConversion</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">	...    </span><br><span class="line">    Complex(double real, double image)&#123; ... &#125;</span><br><span class="line">    Complex(const double r)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Complex::Complex(const double)&quot; &lt;&lt; endl;</span><br><span class="line">        dReal = r;  dImage = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Complex&amp; operator=(const Complex&amp; r)&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex c(1,5);</span><br><span class="line">    c = 3.14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Complex::Complex(const double)</span><br><span class="line">Complex::operator=(const Complex&amp;)</span><br></pre></td></tr></table></figure>

<p>第19行：试图把3.14赋值给c，Complex类型并不存在接受double对象的oeprator&#x3D;成员函数，但有一个接受double对象的构造函数以及一个接受Complex对象的operator&#x3D;成员函数。“聪明”的编译器作出了下述安排：</p>
<ul>
<li>先执行Complex(const double)，以3.14为参数，构造一个临时的Complex对象；</li>
<li>将临时Complex对象作为参数，执行c.operator&#x3D;(const Complex&amp;)成员函数，完成赋值；</li>
<li>临时对象析构。</li>
</ul>
<p>执行结果反应了上述执行过程。因为没有为Complex类型自定义析构函数，所以执行结果没有反应临时对象的析构过程。</p>
<h3 id="17-6-UserString的深拷贝"><a href="#17-6-UserString的深拷贝" class="headerlink" title="17.6 UserString的深拷贝"></a>17.6 UserString的深拷贝</h3><p>16.4节中UserString的深拷贝是有缺陷的：</p>
<ul>
<li>没有考虑到operator&#x3D;操作符函数；</li>
<li>将字符串字面量赋值给UserString对象需要借助assign( )成员函数，不够直观。</li>
</ul>
<p>完善后的UserString类型及演示程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">//Project - UserStringDeepCopy</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    const UserString&amp; operator=(const char* s)&#123;</span><br><span class="line">        unsigned long long sizeNeeded = strlen(s) + 1;</span><br><span class="line">        if (size &gt;= sizeNeeded)   //缓冲区够用，直接</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        else &#123;</span><br><span class="line">            if (buffer!=nullptr)  //缓冲区不够用，重新申请后再</span><br><span class="line">                free(buffer);</span><br><span class="line">            size = sizeNeeded;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,s);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const UserString&amp; operator=(const UserString&amp; r)&#123;</span><br><span class="line">        if (buffer!=nullptr)</span><br><span class="line">            free(buffer);</span><br><span class="line">        size = r.size;</span><br><span class="line">        if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,r.buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~UserString()&#123;</span><br><span class="line">        if (buffer!=nullptr)</span><br><span class="line">            free(buffer);       //释放缓冲区,现在安全了</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserString(const UserString&amp; r)&#123;</span><br><span class="line">        size = r.size;</span><br><span class="line">        if (size&gt;0 &amp;&amp; r.buffer!=nullptr)&#123;</span><br><span class="line">            buffer = (char*)calloc(size,1);</span><br><span class="line">            strcpy(buffer,r.buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UserString()&#123;&#125;             //不可或缺</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp;, const UserString&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, const UserString&amp; r)&#123;</span><br><span class="line">    o &lt;&lt; r.buffer;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    UserString s1,s2;</span><br><span class="line">    s1 = &quot;New coronavirus believed to be derived from bats.&quot;;</span><br><span class="line">    s2 = s1;                  //operator=操作符函数</span><br><span class="line">    s2 = &quot;Human beings will win!&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;s1 = &quot; &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;s2 = &quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = New coronavirus believed to be derived from bats.</span><br><span class="line">s2 = Human beings will win!</span><br></pre></td></tr></table></figure>

<p>相较于16.4中的UserString，本例中的UserString做了如下改进。</p>
<p>第12 ~ 24行：将原有的assign(const char*)函数修改为operator&#x3D;(const char*)成员函数。第61行、第63行的赋值实际调用了UserString对象的operator&#x3D;(const char*)成员函数。</p>
<p>第26 ~ 35行：增加了operator&#x3D;(const UserString&amp;)成员函数，修补了UserString对象赋值时的浅拷贝漏洞。第62行的赋值实际调用了s2对象的operator&#x3D;(const UserString&amp;)成员函数，以s1为参数。</p>
<p>第54 ~ 57行：增加了全局函数operator&lt;&lt;(ostream&amp;, const UserString&amp;)，赋予了程序通过&lt;&lt;操作符将UserString输出给cout的能力。第64 ~ 65行可见，程序直接把s1和s2通过&lt;&lt;输出给cout。</p>
<p>执行结果证实，第62行s1到s2的赋值成功进行了s1到s2的深拷贝，后续第63行对s2的修改没有影响到s1。</p>
<h3 id="17-7-操作符"><a href="#17-7-操作符" class="headerlink" title="17.7 ++操作符"></a>17.7 ++操作符</h3><p>如第3章所述，递增操作符完成两件工作：</p>
<ul>
<li>将操作数，例如v，增加1；</li>
<li>返回递增之前的v（v++）或递增之后的v（++v）作为表达式的值。</li>
</ul>
<blockquote>
<p><strong>要点🎯</strong> C++以非常特别的方式来区分v++和++v：</p>
<ul>
<li>operator++( )对应++v，先++，后取值；</li>
<li>operator++(int)对应v++，先取值，后++。</li>
</ul>
</blockquote>
<p>【？缺：需要理由吗？】</p>
<p>请见下述C++示例程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexDoublePlus</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    const Complex&amp; operator++()&#123;    //对应++c，先++，后取值</span><br><span class="line">        dReal += 1.0;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const Complex operator++(int)&#123;  //对应c++，先取值，后++</span><br><span class="line">        Complex t = *this;</span><br><span class="line">        dReal += 1.0;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, const Complex&amp; c)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex c(1,3);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; &quot; --&gt; &quot; &lt;&lt; ++c &lt;&lt; endl;   //先++,后取值</span><br><span class="line">    cout &lt;&lt; c++ &lt;&lt; &quot; --&gt; &quot; &lt;&lt; c &lt;&lt; endl;   //先取值，后++</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 + 3i --&gt; 2 + 3i</span><br><span class="line">2 + 3i --&gt; 3 + 3i</span><br></pre></td></tr></table></figure>

<p>第8 ~ 11行：operator++( )成员函数，对应++c。第24行的++c调用执行了该函数，返回c被递增之后值，对应执行结果的第1行。</p>
<p>第13 ~ 17行：operator++(int)成员函数，对应c++。第25行的c++调用执行了该函数，返回c被递增之前的值，对应执行结果的第2行。</p>
<p>为了返回对象被递增之前的值，第14行先将对象的值保存在临时对象t中，第15行递增对象，第16行返回临时对象t。</p>
<blockquote>
<p><strong>注意📢</strong> 返回临时对象的引用是十分危险的，安全起见，operator++(int)函数的返回类型为const Complex，返回方式为传值（return by value）。</p>
</blockquote>
<p>递减操作符的重载方式与递增类似。</p>
<h3 id="17-8-智能指针"><a href="#17-8-智能指针" class="headerlink" title="17.8 智能指针"></a>17.8 智能指针</h3><p>在C++里，动态对象的创建是通过new操作符进行的，在恰当的时候通过delete操作符释放动态对象的空间并执行其析构函数是程序员的职责。遗憾的是，多数新手程序员都做不好这项工作，相关的疏失导致了巨量的软件缺陷：</p>
<ul>
<li>未能释放动态对象，导致内存泄漏。</li>
<li>在内存释放后再次访问指针所指向的动态对象。在释放指针所指向的智能指针后，及时将指针置为空对避免该问题的发生有帮助。</li>
<li>多次释放同一个动态对象。这种情况多发生在两个以上的指针指向同一个动态对象时。</li>
</ul>
<p>智能指针可以部分解决此问题，以少许效率抽失为代价。本节以shared_ptr为例，简要描述智能指针的使用方法及基本工作原理。请阅读下述C++代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//Project - SharedPointer</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    Fish(const string&amp; name)&#123;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Constructor called: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Aloha: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Fish()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Fish Destructor called:  &quot;  &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void sayHello(shared_ptr&lt;Fish&gt; f)&#123;</span><br><span class="line">    f-&gt;sayHello();      //对智能指针使用指向操作符-&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sayHello(Fish&amp; f)&#123;</span><br><span class="line">    f.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    shared_ptr&lt;Fish&gt; dora1(new Fish(&quot;Dora&quot;));</span><br><span class="line">    shared_ptr&lt;Fish&gt; tom1 = make_shared&lt;Fish&gt;(&quot;Tom&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sayHello(tom1);</span><br><span class="line">    auto tom2 = tom1;   //智能指针对象的</span><br><span class="line">    sayHello(*tom2);    //对智能指针使用解引用操作符*</span><br><span class="line">    cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    dora1-&gt;sayHello();</span><br><span class="line">    Fish* dora2 = dora1.get();   //获取智能指针内的原始指针</span><br><span class="line">    dora2-&gt;sayHello();</span><br><span class="line">    cout &lt;&lt; &quot;-----------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fish Constructor called: Dora</span><br><span class="line">Fish Constructor called: Tom</span><br><span class="line">-----------------------------------------</span><br><span class="line">Aloha: Tom</span><br><span class="line">Aloha: Tom</span><br><span class="line">-----------------------------------------</span><br><span class="line">Aloha: Dora</span><br><span class="line">Aloha: Dora</span><br><span class="line">-----------------------------------------</span><br><span class="line">Fish Destructor called:  Tom</span><br><span class="line">Fish Destructor called:  Dora</span><br></pre></td></tr></table></figure>

<p><memory>头文件引入了共享的智能指针模板类shared_ptr。</p>
<blockquote>
<p><strong>要点🎯</strong> shared_ptr<T> 表明一个指向T类型对象的智能指针对象。智能指针对象不是一个平凡的指针，而是一个包含平凡指针的对象，它通过引用计数来记录指针所指向的对象的被引用次数，当被指向对象的引用计数降到0时（意味着动态对象不再被需要），智能指针对象会通过delete操作符或者指定deleter函数释放动态对象。</p>
</blockquote>
<p>第6 ~ 21行：为了演示智能指针所管理的动态对象的生命周期，我们设计了Fish类。Fish的构造及析构函数都会向控制台报告构造或析构的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void sayHello(shared_ptr&lt;Fish&gt; f)&#123;</span><br><span class="line">    f-&gt;sayHello();      //对智能指针使用指向操作符-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第23 ~ 25行：sayHello( )函数接受一个智能指针对象f为参数，然后对f使用指向操作符访问Fish对象的sayHello( )方法。请注意：f是一个智能指针对象，此处的参数传递为传值；第24行的指向操作符事实上执行的是f对象的重载operator-&gt;( )函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void sayHello(Fish&amp; f)&#123;</span><br><span class="line">    f.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第27 ~ 29行：函数名重载的sayHello( )接受Fish的引用f作为参数，然后执行f的sayHello( )成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Fish&gt; dora1(new Fish(&quot;Dora&quot;));</span><br></pre></td></tr></table></figure>

<p>第32行：定义并构建了指向Fish对象的智能指针对象dora1，以动态Fish对象”Dora”的地址作为参数。该行代码执行过程包含如下几步。</p>
<ul>
<li>dora1是一个自动对象，在栈内为其分配空间；</li>
<li>new Fish(“Dora”)在堆内分配对象空间并构造初始化，返回“Dora鱼”的地址；</li>
<li>以new Fish(“Dora”)返回的地址为参数，执行dora1的构造函数。该构造函数将动态对象的地址保存在dora1内部，并将引用计数置为1 - 表明该动态对象当前被1个智能指针对象所“引用”。</li>
</ul>
<p>执行结果的第1行对应”Dora鱼”的构造输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Fish&gt; tom1 = make_shared&lt;Fish&gt;(&quot;Tom&quot;);</span><br></pre></td></tr></table></figure>

<p>第33行：该行代码的执行包含如下几步。</p>
<ul>
<li>tom1是一个自动对象，在栈内为其分配空间；</li>
<li>make_shared<Fish>(“Tom”)函数创建并构造一个Fish类型的堆对象（以”Tom”为参数），然后构造并返回一个指向该动态对象的shared_ptr<Fish>类型的智能指针；</li>
<li>上述返回的智能指针被拷贝构造给tom1。</li>
</ul>
<blockquote>
<p><strong>注意📢</strong> 由于编译器优化的原因，编译器有可能会省掉先构造智能指针再拷贝构造智能指针的不必要步骤，而直接执行tom1的构造函数，以动态Fish对象的指针作为参数。</p>
</blockquote>
<p>执行结果的第2行对应”Tom鱼”的构造输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello(tom1);</span><br></pre></td></tr></table></figure>

<p>第36行：将智能指针对象tom1传值给sayHello( )函数（第23行）的形参f，该函数对f应用指向操作符，执行”Tom鱼”的sayHello( )方法。可以想象：当f对象被拷贝构造时，“Tom鱼”的引用计数将由1变2，因为此时tom1和f两个智能指针都指向”Tom鱼“；在sayHello( )函数结束执行前，局部对象f被析构，”Tom鱼“的引用计数则会由2变1。本行的输出见执行结果的第4行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto tom2 = tom1;   //智能指针对象的</span><br></pre></td></tr></table></figure>

<p>第37行：从tom1拷贝构造tom2。”Tom鱼”的引用计数将由1变2，因为智能指针tom1和tom2都指向”Tom鱼“。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello(*tom2);    //对智能指针使用解引用操作符*</span><br></pre></td></tr></table></figure>

<p>第38行：第27行的sayHello( )函数接受一个Fish&amp;作为参数，通过对tom2使用解引用操作符<em>，可以获得Fish类型的对象。tom2的类型可以视为Fish</em>，<em>tom2的类型则为Fish。事实上，</em>tom2是通过执行tom2对象的operator*( )操作符函数来实现”解引用“的功能的。本行的输出见执行结果的第5行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dora1-&gt;sayHello();</span><br></pre></td></tr></table></figure>

<p>第41行：对智能指针dora1使用指向操作符，执行”Dora鱼“的sayHello( )方法。如前所述，该指向操作符事实上是通过dora1的operator-&gt;( )操作符函数发挥作用的。本行的输出见执行结果的第7行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish* dora2 = dora1.get();   //获取智能指针内的原始指针</span><br><span class="line">dora2-&gt;sayHello();</span><br></pre></td></tr></table></figure>

<p>第42 ~ 43行：执行dora1对象的get( )成员函数获取智能指针内部的“原始”指针，然后通过原始指针执行”Dora鱼”的sayHello( )方法。成员操作符”.”证实，dora1是一个对象，而不是一个平凡的指针。相关输出见执行结果的第8行。</p>
<p>到了main( )函数的结尾，自动对象tom2的析构导致“Tom鱼”的引用计数由2变1、tom1的析构则进一步导致引用计数由1变0，这表明”Tom鱼“不再被任何智能指针所引用。在tom1的析构函数里，delete操作符被执行，”Tom鱼”动态对象被释放。执行结果的第10行可见”Tom鱼”的析构输出。</p>
<p>同理，dora1的析构导致”Dora鱼”的释放，执行结果的第11行可见”Dora鱼“的析构输出。</p>
<p>智能指针的使用简化了动态对象的生命周期管理，程序员不必再手动释放动态对象。当最后一个指向该动态对象的智能指针对象被析构时，该动态对象会被释放。大多数情况下，由此所导致的性能损失是可以接受的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Fish&gt; p1(new Fish(&quot;1&quot;));  //1号鱼及其指针p1</span><br><span class="line">auto p2 = make_shared&lt;Fish&gt;(&quot;2&quot;);    //2号鱼及其指针p2</span><br><span class="line">p2 = p1;       //p2与原引用对象解绑，改为绑定p1所指向的对象</span><br><span class="line">p1.reset();    //p1与对象解绑</span><br><span class="line">if (p1.get() == nullptr)   //解绑后的p1是空指针</span><br><span class="line">    cout &lt;&lt; &quot;p1 is nullptr.&quot; &lt;&lt; endl;</span><br><span class="line">p1.reset(p2.get());        //p1与原对象解绑，改为绑定p2所指向的对象</span><br></pre></td></tr></table></figure>

<p>上述代码进一步演示了shared_ptr的使用方法。</p>
<p>第3行：将p1赋值给p2，这将导致如下结果。</p>
<ul>
<li>p2与原对象解除绑定，本例中p2是指向原对象的唯一智能指针，原对象即2号鱼被释放；</li>
<li>p2改为指向p1所指向的对象。</li>
</ul>
<p>第4行：p1的reset( )成员函数将解除p1与对象的绑定，解绑后，p1成为“空指针”。</p>
<p>第7行：p1.reset(p2.get( ))的执行导致如下结果。</p>
<ul>
<li>p1与原绑定对象解绑；</li>
<li>p1改为指向p2所指向的对象。</li>
</ul>
<blockquote>
<p><strong>警告🚩</strong></p>
<ul>
<li>智能指针仅适用于动态（堆）对象，不要对栈对象或者静态对象创建智能指针，因为栈对象和静态对象的生命周期是由编译器自动管理的。</li>
<li>不要通过动态对象的原始指针创建多个互不相关的智能指针。</li>
<li>智能指针的get( )方法所返回的原始指针只可使用，不可应用delete进行释放。如果这样做了，当智能指针析构时，会对同一个动态对象进行第2次释放。</li>
</ul>
</blockquote>
<p>下述代码演示了一些常见的智能指针的错误使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fish* f = new Fish(&quot;Peter&quot;);</span><br><span class="line">   shared_ptr&lt;Fish&gt; p1(f);</span><br><span class="line">   auto p2 = p1;	         //正确</span><br><span class="line">   shared_ptr&lt;Fish&gt; p3(f);  //错误</span><br></pre></td></tr></table></figure>

<p>第3行：正确，p2的出现仅会导致动态对象引用计数的增加，当且仅当p2和p1都被析构时，“Peter鱼”才会被释放。</p>
<p>第4行：错误，智能指针p3与p1&#x2F;p2互不相关，它会为”Peter鱼”创建一个新的引用计数。本例中，p1&amp;p2会释放”Peter鱼”，p3也会释放“Peter鱼”，显然，我们不可以杀死同一条鱼两次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fish* p = p3.get();     //p3是个指向Fish对象的智能指针</span><br><span class="line">delete p;				//错误</span><br></pre></td></tr></table></figure>

<p>第2行：错误，释放p指针所指向的对象后，智能指针p3以及他的表兄弟们，还会再释放一次。同理，不能两次杀死同一条鱼。</p>
<p>读者如果对智能指针的工作机制感到疑惑，请仔细阅读下一节 - 智能指针的实现。</p>
<blockquote>
<p><strong>扩展阅读📕</strong> 除了shared_ptr，C++标准模板库还实现了unique_ptr、weak_ptr等其它智能指针类型，详情请扫码阅读。【？unique_ptr、weak_ptr】</p>
</blockquote>
<p>普通的指针可以指向一个使用new [ ]操作符创建的动态数组，智能指针也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;float&gt; a(new float[1024]);</span><br></pre></td></tr></table></figure>

<p>无论是new float，还是new float[1024]，所得到的都是float*，也就是说，上述代码中的智能指针a并不知晓其指向的是一个动态对象，还是由多个动态对象构成的数组。根据第8章的讨论，new [ ]所返回的指针必须通过delete [ ]操作符进行释放，显然，上述智能指针a并不知道它所指向是一个动态数组，它只能使用delete而不是delete [ ]来释放对象，这样做有风险。</p>
<blockquote>
<p><strong>警告🚩</strong> 当使用shared_ptr管理动态对象数组时，要么指定类型为对象数组，要么提供一个删除者（deleter）函数通过delete [ ]释放数组，该函数将在智能指针释放对象时被调用。</p>
</blockquote>
<p>下述C++代码演示了确保智能指针安全释放对象数组的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//Project - SharedPtrArray</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void delete_array(T* p)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;delete_array&quot; &lt;&lt; endl;</span><br><span class="line">    delete[] p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish&#123;</span><br><span class="line">public:</span><br><span class="line">    ~Fish()&#123; cout &lt;&lt; &quot;Fish::Fish~()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    shared_ptr&lt;Fish[]&gt; a(new Fish[4]);</span><br><span class="line">    a = nullptr;   //a指针指向的数组被释放</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Fish&gt; b(new Fish[2],delete_array&lt;Fish&gt;);</span><br><span class="line">    b.reset();     //b指针指向的数组被释放</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;float&gt; c(new float[512],</span><br><span class="line">        [](float*p)&#123;cout &lt;&lt; &quot;lambda function\n&quot;; delete[] p;&#125;);</span><br><span class="line">    *c = 4.4F;</span><br><span class="line">    //c++;           //错误：智能指针不支持指针运算</span><br><span class="line">    //c[1] = 99.2F;  //错误：智能指针不支持[]操作符</span><br><span class="line">    cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fish::Fish~()</span><br><span class="line">Fish::Fish~()</span><br><span class="line">Fish::Fish~()</span><br><span class="line">Fish::Fish~()</span><br><span class="line">delete_array</span><br><span class="line">Fish::Fish~()</span><br><span class="line">Fish::Fish~()</span><br><span class="line">4.4</span><br><span class="line">lambda function</span><br><span class="line">shared_ptr&lt;Fish[]&gt; a(new Fish[4]);</span><br><span class="line">a = nullptr;   //a指针指向的数组被释放</span><br></pre></td></tr></table></figure>

<p>第18 ~ 19行：智能指针a的类型中的模板参数被指定为Fish [ ]，这相当于告知a对象，其所管理的是一个元素类型为Fish的动态数组。第19行给指针a赋值为nullptr，将导致a指针释放对象数组。从执行结果的第1 ~ 4行可见，共有4次Fish对象的析构函数执行，这间接说明，对象数组是通过delete [ ]操作符进行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Fish&gt; b(new Fish[2],delete_array&lt;Fish&gt;);</span><br><span class="line">b.reset();     //b指针指向的数组被释放</span><br></pre></td></tr></table></figure>

<p>第21 ~ 22行：智能指针b的构造函数的第2个参数为自定义的删除者函数。该函数是一个通用的模板函数，其通过delete [ ]操作符释放对象数组。执行结果的第5 ~ 7行显示，该函数成功执行，并析构了两个Fish对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;float&gt; c(new float[512],</span><br><span class="line">    [](float*p)&#123;cout &lt;&lt; &quot;lambda function\n&quot;; delete[] p;&#125;);</span><br></pre></td></tr></table></figure>

<p>第24 ~ 25行：程序为智能指针c提供了一个匿名（lambda）函数作为删除者函数。执行结果的第9行对应该lambda函数的执行输出。自动对象c在main( )函数的结尾被释放并引发了删除者函数的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//c++;           //错误：智能指针不支持指针运算</span><br></pre></td></tr></table></figure>

<p>第27行：如注释所言，智能指针不支持象普通指针那样的指针运算。如果确实需要，只能通过get( )方法获取原始指针后进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//c[1] = 99.2F;  //错误：智能指针不支持[]操作符</span><br></pre></td></tr></table></figure>

<p>第28行：同样地，智能指针也不支持普通指针那样的[ ]操作符。</p>
<h3 id="17-9-智能指针的实现"><a href="#17-9-智能指针的实现" class="headerlink" title="17.9 智能指针的实现"></a>17.9 智能指针的实现</h3><p>本节将实现一个名为SmartPointer的简化版本的shared_ptr模板类。相关C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//Project - SmartPointer</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish &#123; ... &#125;;     //与前节Fish类实现完全相同</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">private:</span><br><span class="line">    T* ptr;             //原始指针</span><br><span class="line">    int* refCount;      //指向引用计数的指针</span><br><span class="line">    void releaseReference()&#123;   //释放引用</span><br><span class="line">        if (!ptr)</span><br><span class="line">            return;</span><br><span class="line">        (*refCount)--;</span><br><span class="line">        if (*refCount==0)&#123;</span><br><span class="line">            delete ptr; ptr = nullptr;</span><br><span class="line">            delete refCount; refCount = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    SmartPointer(T* p=nullptr)&#123;</span><br><span class="line">        ptr = p;</span><br><span class="line">        refCount = new int;</span><br><span class="line">        *refCount = ptr?1:0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SmartPointer()&#123;</span><br><span class="line">        releaseReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拷贝构造函数</span><br><span class="line">    SmartPointer(const SmartPointer&amp; r) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Copy constructor of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">        ptr = r.ptr;</span><br><span class="line">        refCount = r.refCount;</span><br><span class="line">        (*refCount)++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重载=操作符</span><br><span class="line">    SmartPointer&amp; operator=(const SmartPointer&amp; r)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator=(const SmartPointer&amp;).&quot; &lt;&lt; endl;</span><br><span class="line">        if (&amp;r == this)</span><br><span class="line">            return *this;</span><br><span class="line">        releaseReference();</span><br><span class="line">        ptr = r.ptr;</span><br><span class="line">        refCount = r.refCount;</span><br><span class="line">        (*refCount)++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重载*操作符</span><br><span class="line">    T&amp; operator*()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator*() of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">        if (ptr)</span><br><span class="line">            return *ptr;</span><br><span class="line">        throw exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重载-&gt;操作符</span><br><span class="line">    T* operator-&gt;()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator-&gt;() of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">        if (ptr)</span><br><span class="line">            return ptr;</span><br><span class="line">        throw exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //查询引用计数</span><br><span class="line">    int referenceCount()&#123;</span><br><span class="line">        return *refCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    SmartPointer&lt;Fish&gt; f1(new Fish(&quot;Dora&quot;));</span><br><span class="line">    SmartPointer&lt;Fish&gt; f2(new Fish(&quot;Tom&quot;));</span><br><span class="line">    auto f3 = f1;      //调用f3的拷贝构造函数，以f1为实参</span><br><span class="line">    f2 = f1;           //调用f2的operator=()函数，以f1为实参，间接导致Tom鱼被释放</span><br><span class="line">    (*f2).sayHello();  //调用f2的operator*()函数</span><br><span class="line">    f2-&gt;sayHello();    //调用f2的operator-&gt;()函数</span><br><span class="line">    cout &lt;&lt; &quot;Refernce count of Dora fish: &quot; &lt;&lt; f2.referenceCount() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fish Constructor called: Dora</span><br><span class="line">Fish Constructor called: Tom</span><br><span class="line">Copy constructor of SmartPointer.</span><br><span class="line">operator=(const SmartPointer&amp;).</span><br><span class="line">Fish Destructor called:  Tom</span><br><span class="line">operator*() of SmartPointer.</span><br><span class="line">Aloha: Dora</span><br><span class="line">operator-&gt;() of SmartPointer.</span><br><span class="line">Aloha: Dora</span><br><span class="line">Refernce count of Dora fish: 3</span><br><span class="line">Fish Destructor called:  Dora</span><br></pre></td></tr></table></figure>

<p>类似于第7章中介绍的模板函数，SmartPointer被设计为一个模板类，其类型参数T需要在使用该类时于&lt;&gt;内提供。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">private:</span><br><span class="line">    T* ptr;             //原始指针</span><br><span class="line">    int* refCount;      //指向引用计数的指针</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>第7 ~ 11行：SmartPointer对象包含两个私有属性，其中，ptr为指向动态对象的原始指针；refCount则为指向引用计数的指针。如前所述，该引用计数用于记录指向动态对象的存活智能指针对象的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void releaseReference()&#123;   //释放引用</span><br><span class="line">    if (!ptr)</span><br><span class="line">        return;</span><br><span class="line">    (*refCount)--;</span><br><span class="line">    if (*refCount==0)&#123;</span><br><span class="line">        delete ptr; ptr = nullptr;</span><br><span class="line">        delete refCount; refCount = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第12 ~ 20行：下述情况之一，releaseReference( )成员函数将被调用，以释放该指针对动态对象的引用。</p>
<ul>
<li>智能指针对象析构时；</li>
<li>智能指针准备绑定其它动象前。</li>
</ul>
<p>第13 ~ 14行：如果智能指针是空指针，直接返回。</p>
<p>第15行：引用计数递减。</p>
<p>第16 ~ 19行：如果引用计数归零，说明该指针所指向的动态对象已经不被需要，将其释放， 同时释放引用计数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmartPointer(T* p=nullptr)&#123;</span><br><span class="line">    ptr = p;</span><br><span class="line">    refCount = new int;</span><br><span class="line">    *refCount = ptr?1:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第23 ~ 27行：构造函数接受一个动态对象的指针作为参数。函数体内，原始指针得到保存，引用计数被创建。当ptr是一个空指针时，引用计数置0，否则置1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~SmartPointer()&#123;</span><br><span class="line">    releaseReference();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第29 ~ 31行：析构函数内调用releaseReference( )函数释放指针对动态对象的引用。如果该智能指针是指向该动态对象的最后一个存活指针，该函数会释放动态对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SmartPointer(const SmartPointer&amp; r) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;Copy constructor of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">    ptr = r.ptr;</span><br><span class="line">    refCount = r.refCount;</span><br><span class="line">    (*refCount)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第34 ~ 49行：拷贝构造函数。该函数通过来初始化一个新的智能指针对象。函数体完成了下述工作：</p>
<ul>
<li>从源对象原始指针及引用计数指针。</li>
<li>引用计数递增，因为又产生了一个新的指向该动态对象的智能指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SmartPointer&amp; operator=(const SmartPointer&amp; r)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator=(const SmartPointer&amp;).&quot; &lt;&lt; endl;</span><br><span class="line">    if (&amp;r == this)</span><br><span class="line">        return *this;</span><br><span class="line">    releaseReference();</span><br><span class="line">    ptr = r.ptr;</span><br><span class="line">    refCount = r.refCount;</span><br><span class="line">    (*refCount)++;</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第42 ~ 51行：operator&#x3D;( )操作符函数用于对一个已经存在的智能指针对象进行赋值。</p>
<p>第44 ~ 45行：如果智能指针对象自己赋值给自己，什么也不做，直接返回*this做为表达式的值。请读者注意，a &#x3D; a这种表达式在语法上是合法的，虽然多数编译器会给出警告信息。</p>
<p>第46行：在绑定到新的动态对象之前，先释放对原动态对象的引用。</p>
<p>第47 ~ 49行：绑定至新的动态对象，递增引用计数。</p>
<p>第50行：返回*this作为表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T&amp; operator*()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator*() of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">    if (ptr)</span><br><span class="line">        return *ptr;</span><br><span class="line">    throw exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第54 ~ 59行：间接操作符*的重载函数。当对一个智能指针使用间接操作符时，该函数会被调用，以获得其所指向的动态对象的引用。</p>
<p>第56 ~ 57行： 如果原始指针不为空，返回所指向的动态对象的引用。</p>
<p>第58行：对一个空指针使用间接操作符是非法的，抛出<strong>异常（exception）</strong>▲。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T* operator-&gt;()&#123;</span><br><span class="line">    cout &lt;&lt; &quot;operator-&gt;() of SmartPointer.&quot; &lt;&lt; endl;</span><br><span class="line">    if (ptr)</span><br><span class="line">        return ptr;</span><br><span class="line">    throw exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第62 ~ 67行：指向操作符-&gt;的重载函数。当对一个智能指针使用指向操作符时，该函数会被调用。该函数预期返回原始指针。</p>
<p>第64 ~ 65行：如果原始指针非空，返回原始指针。</p>
<p>第66行：对一个空指针应用指向操作符是非法的，抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int referenceCount()&#123;</span><br><span class="line">    return *refCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第70 ~ 72行：查询智能指针所指向的动态对象的引用计数，该引用计数表明当前指向该动态对象的智能指针的数量。</p>
<p>接下来，main( )函数演示了上述SmartPointer类型的使用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPointer&lt;Fish&gt; f1(new Fish(&quot;Dora&quot;));</span><br><span class="line">SmartPointer&lt;Fish&gt; f2(new Fish(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure>

<p>第76 ~ 77行：创建Dora鱼、Tom鱼及相关智能指针。执行结果的第1 ~ 2行对应两条鱼的构造输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f3 = f1;      //调用f3的拷贝构造函数，以f1为实参</span><br></pre></td></tr></table></figure>

<p>第78行：f3的拷贝构造函数被执行，以f1为实参。执行结果的第3行对应拷贝构造函数的输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2 = f1;           //调用f2的operator=()函数，以f1为实参，间接导致Tom鱼被释放</span><br></pre></td></tr></table></figure>

<p>第79行：该行代码执行前f2已存在，故f2的operator&#x3D;( )函数被执行，以f1为实参。执行结果的第4行对应operator&#x3D;( )函数的输出。当前，f2是指向Tom鱼的唯一智能指针，f2的被赋值将间接导致Tom鱼被释放，执行结果的第5行对应Tom鱼的析构输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*f2).sayHello();  //调用f2的operator*()函数</span><br></pre></td></tr></table></figure>

<p>第80行：对智能指针f2应用间接操作符以获取f2所指向的动态对象的引用，本行事实上导致了f2的operator*( )函数的执行，该函数出的输出见执行结果的第6行。以返回的Dora鱼对象的引用为基础，sayHello( )成员函数被执行，执行结果的第7行可以看到来自Dora鱼的问候。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2-&gt;sayHello();    //调用f2的operator-&gt;()函数</span><br></pre></td></tr></table></figure>

<p>第81行：对智能指针f2应用指向操作符，本行事实上导致了f2的operator-&gt;( )函数的执行，其输出对应执行结果的第8行。以该函数返回的Dora鱼的原始指针为基础，sayHello( )成员函数被执行，执行结果的第9行可再次看到来自Dora鱼的问候。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;Refernce count of Dora fish: &quot; &lt;&lt; f2.referenceCount() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第82行：目前为止，共有f1、f2和f3共三个智能指针指向Dora鱼，referenceCount( )返回Dora鱼的引用计数，其值应为3，见执行结果的第10行。</p>
<p>到了main( )函数的结尾，智能指针f1、f2和f3作为栈对象，相继被析构并释放对Dora鱼的引用。其中，最后一个被析构的智能指针发现Dora鱼的引用计数归零，将其释放。执行结果的第11行，对应Dora鱼的析构输出。</p>
<h3 id="17-10-操作符"><a href="#17-10-操作符" class="headerlink" title="17.10 [ ]操作符"></a>17.10 [ ]操作符</h3><p>我们借助于16.4节中的UserString类型来说明[ ]操作符的重载方法。UserString既然是个字符串，那么通过下标按位置访问字符串中的字符符合类使用者的期望。这可以通过重载[ ]操作符来实现，相关C++程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//Project - Subscript</span><br><span class="line">...</span><br><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line">public:</span><br><span class="line">    const UserString&amp; operator=(const char* s)&#123; ...  &#125;</span><br><span class="line">    ~UserString()&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    char&amp; operator[](size_t idx)&#123;</span><br><span class="line">        return buffer[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t getSize()&#123;</span><br><span class="line">        return buffer?strlen(buffer):0;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; o, const UserString&amp; r)&#123;</span><br><span class="line">    o &lt;&lt; r.buffer;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    UserString s;</span><br><span class="line">    s = &quot;Aloha&quot;;</span><br><span class="line">    cout &lt;&lt; &quot;before: &quot; &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    for (size_t i=0;i&lt;s.getSize();i++)&#123;</span><br><span class="line">        char&amp; c = s[i];           //s[i] 等价于 s.operator[](i)</span><br><span class="line">        if (c &lt;= &#x27;z&#x27; &amp;&amp; c &gt;= &#x27;a&#x27;)</span><br><span class="line">            c += &#x27;A&#x27; - &#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;after: &quot; &lt;&lt; s &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: Aloha</span><br><span class="line">after: ALOHA</span><br></pre></td></tr></table></figure>

<p>本例中，我们为UserString类型定义了两个新的成员函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_t getSize()&#123;</span><br><span class="line">    return buffer?strlen(buffer):0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第15 ~ 17行：getSize( )函数用于获取UserString对象包含的字符串的长度，当buffer为空时，长度为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[](size_t idx)&#123;</span><br><span class="line">    return buffer[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 13行：重载的operator[ ]操作符函数，形参idx对应[ ]中的下标。该函数返回指定下标的字符的引用。char&amp;的返回类型使用通过[ ]操作符修改字符串内容成为可能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (size_t i=0;i&lt;s.getSize();i++)&#123;</span><br><span class="line">    char&amp; c = s[i];           //s[i] 等价于 s.operator[](i)</span><br><span class="line">    if (c &lt;= &#x27;z&#x27; &amp;&amp; c &gt;= &#x27;a&#x27;)</span><br><span class="line">        c += &#x27;A&#x27; - &#x27;a&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第30 ~ 34行：通过[ ]操作符逐一访问s字符串内的每一个字符，如果是小写字母，将其修改成大写。</p>
<p>第31行：s[i]对s对象应用[ ]操作符，编译器将其解释为s.operator<a href="i"> </a>。由于s[i]返回的是字符的引用，后续对c的修改就是对s[i]的修改。</p>
<p>执行结果证实，上述操作是成功的。</p>
<blockquote>
<p><strong>总结🍵</strong> 操作符重载并不能给我们带来新的能力，所有通过操作符重载能够完成的工作，都可以通过普通函数来完成。操作符重载能够带给我们的是：更好的代码可读性；更直接的类接口。</p>
</blockquote>
<blockquote>
<p><strong>要点🎯</strong> 操作符重载并不能改变操作符使用的优先级及其基本语法。比如，无论如何重载，+操作符都需要两个操作数，其优先级总是低于乘法操作符。</p>
</blockquote>
<h3 id="17-11-类型转换操作符函数"><a href="#17-11-类型转换操作符函数" class="headerlink" title="17.11 类型转换操作符函数"></a>17.11 类型转换操作符函数</h3><p>事实上，不通过重载&lt;&lt;操作符，也可以将前述UserString对象输出给cout，方法是：为UserString定义一个类型转换操作符函数，允许编译器隐式将其转换成char<em>类型。而char</em>类型，正好可以被cout的某个operator&lt;&lt;( )成员函数所接受。示例C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - TypeConversionOperator</span><br><span class="line">...</span><br><span class="line">class UserString &#123;</span><br><span class="line">private:</span><br><span class="line">    char* buffer = nullptr;       //缓冲区指针</span><br><span class="line">    unsigned long long size = 0;  //缓冲区大小</span><br><span class="line">public:</span><br><span class="line">    const UserString&amp; operator=(const char* s)&#123; ... &#125;</span><br><span class="line">    ~UserString() &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    //将对象转换成char*的操作符函数</span><br><span class="line">    operator char*()&#123;</span><br><span class="line">        return buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    UserString s;</span><br><span class="line">    s = &quot;Aloha&quot;;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.operator char *() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aloha</span><br><span class="line">Aloha</span><br></pre></td></tr></table></figure>

<p>第12 ~ 14行：定义了一个类型换转操作符函数，该函数可以将UserString对象转换成char*类型。</p>
<p>第20行：编译器没有发现cout存在接受一个UserString类型参数的operator&lt;&lt;( )函数，但是发现：</p>
<ul>
<li>cout存在一个operator&lt;&lt;(char *)成员函数；</li>
<li>s存在一个operator char *( )函数，可以把s转换成char *。</li>
</ul>
<p>最终，“聪明”的编译器对s进行隐式类型转换，将第20行代码解释成了第21行的样子，这两行代码完全等价，执行结果相同。</p>
<p>一般地， 类型转换操作符函数的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operator 类型名()&#123;</span><br><span class="line">	...</span><br><span class="line">	return v;     //v必须是要求的类型或者可以隐式类型转换至要求的类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下述C++示例为Complex类型增加了一个double类型转换操作符函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//Project - ComplexToDouble</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">    double dReal;</span><br><span class="line">    double dImage;</span><br><span class="line"></span><br><span class="line">    Complex(double real, double image)&#123;</span><br><span class="line">        dReal = real; dImage = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator double()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;operator double()&quot; &lt;&lt; endl;</span><br><span class="line">        return sqrt(dReal*dReal + dImage*dImage);  //返回复数的模</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Complex c(1,5);</span><br><span class="line">    double r = 3 + c; //3 + c等价于3 + c.operator double()</span><br><span class="line">    cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">operator double()</span><br><span class="line">8.09902</span><br></pre></td></tr></table></figure>

<p>第23行：3 + c试图把一个整数与复数c相加。几乎波折，编译器通过下述方式实现了目标：</p>
<ul>
<li>将整数3转换成double类型；</li>
<li>通过c的operator double( )类型转换函数，将c隐式转换成double；</li>
<li>两个double对象相加，结果赋值给r。</li>
</ul>
<p>执行结果证实了operator double( )函数的“隐式”执行。</p>
<h2 id="18-多态"><a href="#18-多态" class="headerlink" title="18. 多态"></a>18. 多态</h2><p><strong>本讲义系重庆大学C&#x2F;C++课程的教学笔记。</strong></p>
<p>作者： 陈波 <a href="mailto:chenbo@cqu.edu.cn">chenbo@cqu.edu.cn</a>， All rights reserved.</p>
<p>未经作者许可，不允许经由互联网展示或提供下载。</p>
<p>不允许以纸质出版为目的进行摘抄或改编。</p>
<p>工厂里，生产计划员审核并公布了次月的生产计划（消息）。工厂不同类型的部门和雇员（对象）作出了不同的响应（执行方法）：</p>
<ul>
<li>采购部门的同事会将生产计划展开成具体的物料清单，并根据物料库存制定并执行物料采购计划；</li>
<li>生产部门的管理者以生产计划为依据，调配设备及人员，作生产做出具体安排；</li>
<li>财务部门的同事会评估完成生产计划所需要耗用的资金，作相应的资金规划；</li>
<li>仓库及物流部门的同事则需要对相应的物料&#x2F;成品的存储及运输作出规划。</li>
</ul>
<p>小学校里，上课预备铃响（消息）后，不同类型的参与者（对象）作出了不同的响应（执行方法）：</p>
<ul>
<li>学生结束游戏，回到教室座位上，等待老师的到来；</li>
<li>教师带上教学资料，走向教室做课前准备；</li>
<li>校长则可能四处巡视，检查纪律及出勤状况。</li>
</ul>
<blockquote>
<p><strong>要点🎯</strong> 不同类型的对象在接受到相同消息后，产生不同行为（执行不同方法）的过程，就是<strong>多态（polymorphism）</strong>。</p>
</blockquote>
<h3 id="18-1-早绑定"><a href="#18-1-早绑定" class="headerlink" title="18.1 早绑定"></a>18.1 早绑定</h3><p><img src="http://codelearn.club/images/image-20200403094715015.png" alt="image-20200403094715015"></p>
<p>图18- 宠物继承结构</p>
<p>下述C++代码实现了图18- 所示的继承结构，我们通过对该程序的分析来解释对象成员函数调用的<strong>早绑定（early binding）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//Project - EarlyBinding</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    void sayHello() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Pet &quot; &lt;&lt; sName &lt;&lt; &quot; : hello&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pet(const string&amp; name):sName(name)&#123;&#125;</span><br><span class="line">    ~Pet()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Pet destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rabbit:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit &quot; &lt;&lt; sName &lt;&lt; &quot; : carrot&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rabbit(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    ~Rabbit()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat &quot; &lt;&lt; sName &lt;&lt; &quot; : meow &quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cat(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    ~Cat()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   Rabbit r(&quot;Charlie&quot;);       //查理兔</span><br><span class="line">   Pet&amp;  r2 = r;</span><br><span class="line">   r2.sayHello();</span><br><span class="line"></span><br><span class="line">   Pet* c = new Cat(&quot;Lucy&quot;);  //露西猫</span><br><span class="line">   c-&gt;sayHello();</span><br><span class="line">   delete c;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pet Charlie : hello</span><br><span class="line">Pet Lucy : hello</span><br><span class="line">Pet destructor: Lucy</span><br><span class="line">Rabbit destructor: Charlie</span><br><span class="line">Pet destructor: Charlie</span><br><span class="line">Rabbit r(&quot;Charlie&quot;);       //查理兔</span><br></pre></td></tr></table></figure>

<p>第44行：定义并构建一只名为查理的兔子。毫无疑问，这里将执行Rabbit的构造函数，以”Charlie”为参数，因为自动变量r的类型为Rabbit。由于Rabbit是Pet的子类，所以，r的构造函数会调用执行Pet的构造函数以初始化r内部的Pet父对象，详见第25行的构造函数初始化列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pet&amp;  r2 = r;</span><br></pre></td></tr></table></figure>

<p>第45行：定义Pet类型的引用r2，并将其与查理兔r相关联。这在逻辑上是合理的，因为查理兔确实是一只宠物；在语法上，这也是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2.sayHello();</span><br></pre></td></tr></table></figure>

<p>第46行：执行Pet&amp;类型的变量r2的sayHello( )成员函数。</p>
<p>我们的期望是：r2的类型的Pet&amp;，但它事实上是一只兔子，应该执行Rabbit::sayHello( )函数，以r2的地址为this指针。事实是：Pet::sayHello( )函数被执行，以r2的地址为this指针，请见执行结果的第1行。显然，编译器依据r2的类型Pet&amp;作出了上述决定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pet* c = new Cat(&quot;Lucy&quot;);  //露西猫</span><br></pre></td></tr></table></figure>

<p>第48行：创建并构造一个Cat类型的堆对象（名为露西的猫），将其指针赋值给Pet<em>类型的自动对象c。这在逻辑上是合理的，因为露西确实是一只宠物，其地址既是Cat</em>，也是Pet*；在语法上，这也是合法的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;sayHello();</span><br></pre></td></tr></table></figure>

<p>第49行：执行c指针所指向的对象的sayHello( )函数。</p>
<p>我们的期望是：c的类型虽是Pet<em>，但它事实上指向的是露西猫，应执行Cat::sayHello( )函数，以c值为this指针。事实是：Pet::sayHello( )函数被执行，以c值为this指针，请见执行结果的第2行。显然，编译器依据c的类型Pet</em>作出了上述决定。理论上，编译器并不知道c指针所指向对象的真正类型，它只知道c指向一只Pet，到底是Rabbit还是Cat，不得而知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete c;</span><br></pre></td></tr></table></figure>

<p>第50行：释放指针c所指向的对象。</p>
<p>我们的期望是：c的类型虽为Pet<em>，但它事实上指向的是露西猫，应该执行Cat::<del>Cat( )析构函数，以c值为this指针。事实是：Pet::</del>Pet( )析构函数被执行，以c值为this指针，请见执行结果的第3行。同样地，编译器依据c的类型Pet</em>作出了上述决定。显然，用Pet的析构函数来析构一只猫，很可能意味着错误。</p>
<p>到了main( )函数的结尾，自动对象r被析构，查理兔的析构函数被执行，并引发了查理兔内部的Pet父对象的析构。相关输出见执行结果的第4 ~ 5行。</p>
<blockquote>
<p><strong>要点🎯</strong> 调用对象的成员函数时，编译器默认执行<strong>早绑定（early binding）</strong>：在编译时刻，根据变量&#x2F;常量、指针或者引用的类型直接确定被执行的函数。</p>
</blockquote>
<p>具体到本例中的c-&gt;sayHello( )，c的类型为Pet<em>，其所指向的对象可能是Pet，也可能是Rabbit或者Cat。但编译器仅知道c的类型为Pet</em>，早绑定的结果就是：选择执行Pet::sayHello( )函数，以c值为this指针。</p>
<p>显然，早绑定没能实现我们期望的多态，虽然c指向的是露西猫，但Cat::sayHello( )没有被执行，我们也没有”听”到喵喵（meow）叫。</p>
<p>对于上述程序，有读者可以会认为：编译器有能力根据上下文”猜”出r2的实际类型为Rabbit&amp;，c的实际类型为Cat*，编译器早绑定函数调用至Pet::sayHello( )不合理。请看下述程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - RabbitOrCat</span><br><span class="line">...</span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;What do you need ?  rabbit or cat ?&quot;;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    Pet* p = nullptr;</span><br><span class="line">    if (s==&quot;rabbit&quot;)</span><br><span class="line">        p = new Rabbit(&quot;Charlie&quot;);</span><br><span class="line">    else</span><br><span class="line">        p = new Cat(&quot;Lucy&quot;);</span><br><span class="line"></span><br><span class="line">    p-&gt;sayHello();</span><br><span class="line">    delete p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，指针p所指向的对象的真正类型（兔或猫）取决于运行时的用户输入。在编译时刻，编译器只知道p指向的是一只宠物（Pet）！</p>
<h3 id="18-2-虚函数及晚绑定"><a href="#18-2-虚函数及晚绑定" class="headerlink" title="18.2 虚函数及晚绑定"></a>18.2 虚函数及晚绑定</h3><blockquote>
<p><strong>要点🎯</strong> 在成员函数声明中增加virtual关键字，可以将其声明为<strong>虚函数</strong>。编译器会对虚函数执行<strong>晚绑定（late binding）</strong>，以实现多态。</p>
</blockquote>
<p>请阅读下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Project - VirtualFunction</span><br><span class="line">...</span><br><span class="line">class Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    virtual void sayHello() &#123; ... &#125;</span><br><span class="line">    Pet(const string&amp; name):sName(name)&#123;&#125;</span><br><span class="line">    virtual ~Pet()&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rabbit:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void sayHello()&#123; ... &#125;   //virtual可省略</span><br><span class="line">    Rabbit(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    virtual ~Rabbit()&#123; ... &#125;         //virtual可省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void sayHello()&#123; ... &#125;  //virtual可省略</span><br><span class="line">    Cat(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    virtual ~Cat()&#123; ... &#125;           //virtual可省略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   Rabbit r(&quot;Charlie&quot;);       //查理兔</span><br><span class="line">   Pet&amp;  r2 = r;</span><br><span class="line">   r2.sayHello();</span><br><span class="line"></span><br><span class="line">   Pet* c = new Cat(&quot;Lucy&quot;);  //露西猫</span><br><span class="line">   c-&gt;sayHello();</span><br><span class="line">   delete c;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rabbit Charlie : carrot</span><br><span class="line">Cat Lucy : meow</span><br><span class="line">Cat destructor: Lucy</span><br><span class="line">Pet destructor: Lucy</span><br><span class="line">Rabbit destructor: Charlie</span><br><span class="line">Pet destructor: Charlie</span><br></pre></td></tr></table></figure>

<p>相较于前节中的程序，上述程序的唯一不同：通过在函数声明前添加virtual，把Pet、Rabbit以及Cat三个类的sayHello( )成员函数及析构函数设置为虚函数。</p>
<blockquote>
<p><strong>要点🎯</strong> 调用对象的成员函数时，如果该成员函数是虚函数，编译器执行<strong>晚绑定（late binding）</strong>：生成额外的机器指令，在运行时刻确定对象的真正类型，并执行对应类型的对应函数。依赖于晚绑定，不同类型的对象在接受到相同的消息（形式上执行的是同一个方法）后，会表现出不同的行为（执行不同的方法），这就是C++里的多态。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r2.sayHello();</span><br></pre></td></tr></table></figure>

<p>第28行：r2的类型为Pet&amp;，Pet的sayHello函数为虚函数，函数调用执行晚绑定。在程序运行时，晚绑定机制发现r2所引用的对象为Rabbit类型，执行Rabbit::sayHello( )函数，以r2的地址为this指针。执行结果的第1行可见来自查理兔的问候。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;sayHello();</span><br></pre></td></tr></table></figure>

<p>第31行：同理，函数调用执行晚绑定。程序运行时，晚绑定机制发现c所指向的对象为Cat类型，执行Cat::sayHello( )函数，以c值为this指针。执行结果的第2行可见来自露西猫的问候。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete c;</span><br></pre></td></tr></table></figure>

<p>第32行：释放指针c所指向的对象隐含了对相应析构函数的调用。同样，晚绑定机制在运行时发现c所指向的对象是Cat类型，执行Cat::~Cat( )析构函数，以c值为this指针。执行结果的第3 ~ 4行来自于露西猫的析构。其中，第4行对应露西猫对象内部的Pet父对象的析构输出。</p>
<blockquote>
<p><strong>要点🎯</strong> 当父类（Pet）的某个成员函数是虚函数时，其子类（Rabbit、Cat）的对应函数自动成为虚函数。</p>
</blockquote>
<p>本例中，Rabbit、Cat类声明中的两个virtual关键字可以省略，不影响结果。</p>
<p>大多数其它语言都是默认执行晚绑定，也就是默认多态，C++是个例外。原因在于，C++视执行效率为生命，通过晚绑定在运行时确定具体执行函数需要花费<strong>额外的一丁点儿</strong>CPU时间。</p>
<h3 id="18-3-晚绑定原理"><a href="#18-3-晚绑定原理" class="headerlink" title="18.3 晚绑定原理*"></a>18.3 晚绑定原理*</h3><p>多态的实现，依赖于在运行时“确定”对象的实际类型。</p>
<blockquote>
<p><strong>要点🎯</strong> 当类型拥有至少一个虚函数时：</p>
<ul>
<li>编译器为每个类型生成一个<strong>虚函数表（VTABLE）</strong>，该表存储了该类全部虚函数的地址；</li>
<li>为每个对象增加一个<strong>虚函数表指针（vptr）</strong>，该指针存储在对象内存的最初8个字节，并指向该对象对应类型的虚函数表。</li>
</ul>
</blockquote>
<p>下述C++程序及其执行结果提供了部分证据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//Project - VPTR</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class NoVirtual &#123;</span><br><span class="line">public:</span><br><span class="line">    long long iDummy;    //占8个字节</span><br><span class="line">    ~NoVirtual()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;~NoVirtual&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class WithVirtual&#123;</span><br><span class="line">public:</span><br><span class="line">    long long iDummy;    //占8个字节</span><br><span class="line">    virtual ~WithVirtual()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;~WithVirtual&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(NoVirtual) = &quot; &lt;&lt; sizeof(NoVirtual) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;sizeof(WithVirtual) = &quot; &lt;&lt; sizeof(WithVirtual) &lt;&lt; endl;</span><br><span class="line">    WithVirtual a,b;</span><br><span class="line">    printf(&quot;&amp;a = %p, &amp;a.iDummy = %p\n&quot;, &amp;a, &amp;a.iDummy);</span><br><span class="line">    printf(&quot;vptr of a = %p, vptr of b = %p\n&quot;, *(long long*)&amp;a, *(long long*)&amp;b);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在作者的计算机上，上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizeof(NoVirtual) = 8</span><br><span class="line">sizeof(WithVirtual) = 16</span><br><span class="line">&amp;a = 000000000061fe00, &amp;a.iDummy = 000000000061fe08</span><br><span class="line">vptr of a = 0000000000409960, vptr of b = 0000000000409960</span><br><span class="line">~WithVirtual</span><br><span class="line">~WithVirtual</span><br></pre></td></tr></table></figure>

<p>说明：在读者计算机上，执行结果中的地址很可能与本书不同；如果读者的编译器是32位的，则vptr应为4个字节，而不是8个字节，上述程序需要通过修改（第26行的long long改成int）才能正确执行。</p>
<p>上述代码中的WithVirtual类相对于NoVirtual类的唯一区别是：WithVirtual的析构函数是虚函数。从执行结果的第1 ~ 2行可见，一个WithVirtual对象比一个NoVirtual对象大8个字节。这8个字节存储了指向WithVirtual虚函数表的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WithVirtual a,b;</span><br><span class="line">printf(&quot;&amp;a = %p, &amp;a.iDummy = %p\n&quot;, &amp;a, &amp;a.iDummy);</span><br></pre></td></tr></table></figure>

<p>第24 ~ 25行：执行结果的第3行证实，a对象内唯一的数据成员iDummy的存储地址相对于a对象的首地址要靠后8个字节。这说明：虚函数表指针（vptr）存储在对象内存空间的起始处。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;vptr of a = %p, vptr of b = %p\n&quot;, *(long long*)&amp;a, *(long long*)&amp;b);</span><br></pre></td></tr></table></figure>

<p>第26行：将a，b对象的前8个字节，即vptr，当成long long对象，并按地址格式输出。</p>
<p>执行结果的第4行证实，WithVirtual类型的两个对象a和b的vptr的值相同，它们都指向同一个VTABLE，因为它们属于同一个类型。每个对象的vptr，是由编译器生成的隐含代码在构造函数中完成初始化的。</p>
<p>执行结果的第5 ~ 6行对应自动对象a、b的析构输出。</p>
<p>为了进一步解释晚绑定是如何借助于对象的vptr以及类型的VTABLE来实现的，我们编写了下述C++程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//Project - LateBinding</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    string sName;</span><br><span class="line">    virtual void sayHello() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Pet &quot; &lt;&lt; sName &lt;&lt; &quot; : hello&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Pet: I ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pet(const string&amp; name):sName(name)&#123;&#125;</span><br><span class="line">    virtual ~Pet()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Pet destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rabbit:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit &quot; &lt;&lt; sName &lt;&lt; &quot; : woof&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit: &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food is not enough!\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rabbit(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    ~Rabbit()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat &quot; &lt;&lt; sName &lt;&lt; &quot; : meow &quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cat(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">    ~Cat()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat destructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">   Pet* pets[3] = &#123;nullptr&#125;;</span><br><span class="line">   pets[0] = new Pet(&quot;Emily&quot;);</span><br><span class="line">   pets[1] = new Cat(&quot;Lucy&quot;);</span><br><span class="line">   pets[2] = new Rabbit(&quot;Charlie&quot;);</span><br><span class="line"></span><br><span class="line">   for (auto x:pets)&#123;</span><br><span class="line">       x-&gt;sayHello();</span><br><span class="line">       x-&gt;eat(100);</span><br><span class="line">       delete x;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pet Emily : hello</span><br><span class="line">Pet: I ate 100 gram&#x27;s food.</span><br><span class="line">Pet destructor: Emily</span><br><span class="line">Cat Lucy : meow</span><br><span class="line">Pet: I ate 100 gram&#x27;s food.</span><br><span class="line">Cat destructor: Lucy</span><br><span class="line">Pet destructor: Lucy</span><br><span class="line">Rabbit Charlie : woof</span><br><span class="line">Rabbit: 100 gram&#x27;s food is not enough!</span><br><span class="line">Rabbit destructor: Charlie</span><br><span class="line">Pet destructor: Charlie</span><br></pre></td></tr></table></figure>

<p><img src="http://codelearn.club/images/image-20200607223707478.png" alt="image-20200607223707478"></p>
<p>图18- pets数组的结构</p>
<p>图18- 描绘了pets数组内的指针所提向的对象的结构，我们对照该图来解释代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets[0] = new Pet(&quot;Emily&quot;);</span><br></pre></td></tr></table></figure>

<p>第52行：创建名为Emily的Pet对象，并将其指针赋值给pets[0]。</p>
<ul>
<li>由于Pet类型包含虚函数，所以编译器为Pet类型准备了虚函数表（VTABLE），其中依次存储了Pet类型的三个虚函数的地址。</li>
<li>对象Pet Emily内部包含的虚函数表指针（vptr）指向VTABLE - Pet。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets[1] = new Cat(&quot;Lucy&quot;);</span><br></pre></td></tr></table></figure>

<p>第53行：创建名为Lucy的Cat对象，并将其地址向上类型转换为Pet*，赋值给pets[1]。</p>
<ul>
<li>由于Pet类型的sayHello( )、eat( )、<del>Pet( )函数为虚函数，其子类Cat的sayHello( )、</del>Cat( )自动成为虚函数。再加上从Pet继承的虚函数eat( )，VTABLE - Cat依次存储了三个虚函数地址。</li>
<li>对象Cat Lucy内部包含的虚函数表指针（vptr）指向VTABLE - Cat。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pets[2] = new Rabbit(&quot;Charlie&quot;);</span><br></pre></td></tr></table></figure>

<p>第54行：创建名为Charlie的Rabbit对象，并将其地址向上类型转换为Pet*，赋值给pets[2]。</p>
<ul>
<li>同理，Rabbit类型的sayHello( )、eat( )、~Rabbit( )自动成为虚函数，VTABLE - Rabbit依次存储了三个虚函数地址。</li>
<li>对象Rabbit Charlie内部包含的虚函数表指针（vptr）指向VTABLE - Rabbit。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (auto x:pets)&#123;</span><br><span class="line">    x-&gt;sayHello();</span><br><span class="line">    x-&gt;eat(100);</span><br><span class="line">    delete x;         //隐含调用析构函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第56 ~ 60行：遍历pets数组，依次执行其所指向的三个对象的sayHello( )、eat( )、及析构函数。</p>
<p>于编译器而言，pets数组的元素类型为Pet<em>，其所指向的对象到底是Pet、Rabbit或Cat已经不得而知。我们以x-&gt;eat(100)为例（当x为pets[2]时）来说明执行过程。x的类型为Pet</em>，Pet的eat( )函数为虚函数，编译器生成额外指令执行晚绑定：</p>
<ul>
<li>通过x指针找到x所指向的对象，即查理兔（Rabbit Charlie），并在其中找到vptr（位于前8个字节）。</li>
<li>通过vptr找到VTABLE - Rabbit。</li>
<li>在VTABLE - Rabbit中找到Rabbit::eat( )函数的地址，并跳转执行。</li>
</ul>
<p>在虚函数表中，虚函数的地址是按照虚函数的声明顺序依次存储的，所以无论是VTABLE - Pet，VTABLE - Cat或是VTABLE - Rabbit，eat( )函数的地址都位于该表的第1项（从0开始计数）。如果把虚函数表指针视为一个函数指针数组，那么eat( )函数的地址就是vptr[1]。实际上，上述晚绑定过程即是通过此种方式来确定函数跳转地址的。</p>
<p>执行结果证实，借助于虚函数和晚绑定，多态得以实现。编译时刻，x-&gt;sayHello( )被调用时，虽然并不清楚x的具体类型，但到了运行时，借助于对象内部的虚函数表指针及对应类型的虚函数的表，正确的方法得以执行。不同类型的对象在收到相同消息时表现了不同的行为，露西猫说“喵”（meow），查理兔就知道要胡萝卜（carrot）。</p>
<h3 id="18-4-运行时类型识别"><a href="#18-4-运行时类型识别" class="headerlink" title="18.4 运行时类型识别*"></a>18.4 运行时类型识别*</h3><p>当类型包含虚函数时，对象内部的虚函数表指针（vptr）使得运行时对象类型识别（<strong>r</strong>un<strong>t</strong>ime <strong>t</strong>ype <strong>i</strong>dentification，简写为<strong>RTTI</strong>）成为可能。在包含虚函数的情况下，同一个类型的所有对象都包含相同vptr，指向同一个虚函数表。</p>
<blockquote>
<p><strong>要点🎯</strong> 可以通过操作符typeid( )在运行时判断对象的实际类型。typeid(x)中的操作数（operand）x既可以是类名，也可以是对象，它返回一个type_info类型的对象，表明操作数的类型。当操作数是对象时，如果对象的编译时类型包含虚函数，typeid( )操作符通过对象的vptr判断对象的运行时类型；如果对象的编译时类型不包含虚函数，对象内并不存在vptr，无法进行运行时类型识别，typeid( )直接返回对象的编译时类型作为结果。</p>
</blockquote>
<p>其中，type_info类型由头文件typeinfo引入。</p>
<p>C++示例程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - RTTI</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Shape&#123;public: ~Shape()&#123;&#125;&#125;;</span><br><span class="line">class Circle:public Shape&#123;&#125;;</span><br><span class="line"></span><br><span class="line">class Pet&#123;public: virtual ~Pet()&#123;&#125;&#125;;</span><br><span class="line">class Rabbit:public Pet&#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Shape *s = new Circle();</span><br><span class="line">    if (typeid(*s) == typeid(Shape))</span><br><span class="line">        cout &lt;&lt; &quot;s points to a shape.&quot; &lt;&lt; endl;</span><br><span class="line">    if (typeid(*s) == typeid(Circle))</span><br><span class="line">        cout &lt;&lt; &quot;s points to a circle.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Pet *p = new Rabbit();</span><br><span class="line">    if (typeid(*p)==typeid(Pet))</span><br><span class="line">        cout &lt;&lt; &quot;p points to a pet.&quot; &lt;&lt; endl;</span><br><span class="line">    if (typeid(*p)==typeid(Rabbit))</span><br><span class="line">        cout &lt;&lt; &quot;p points to a rabbit.&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s points to a shape.</span><br><span class="line">p points to a rabbit.</span><br></pre></td></tr></table></figure>

<p><img src="http://codelearn.club/images/image-20200403114045112.png" alt="image-20200403114045112"></p>
<p>图18- RTTI的继承结构</p>
<p>我们结合图18- 来解释上述程序的执行过程及结果。在两个继承结构里，Shape - Circle类型不存在析构函数，Pet - Rabbit类型存在析构函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape *s = new Circle();</span><br></pre></td></tr></table></figure>

<p>第13行：创建一个Circle类型的对象，并将其地址向上类型转换为Shape*，赋值给s。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (typeid(*s) == typeid(Shape))</span><br><span class="line">    cout &lt;&lt; &quot;s points to a shape.&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 15行：s的编译时类型为Shape<em>，</em>s的编译时类型为Shape。对于typeid( )操作符而言，Shape类型不包含虚函数，对象*s内没有vptr可以利用，故typeid( )直接返回其编译时类型Shape，逻辑判断成立，第15行被执行，其输出对应执行结果第1行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (typeid(*s) == typeid(Circle))</span><br><span class="line">    cout &lt;&lt; &quot;s points to a circle.&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第16 ~ 17行：如上所述，typeid(<em>s)返回的是</em>s的编译时类型Shape，逻辑判断不成立，第17行没有执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pet *p = new Rabbit();</span><br></pre></td></tr></table></figure>

<p>第19行：创建一个Rabbit类型的对象，并将其地址向上类型转换为Pet*，赋值给p。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (typeid(*p)==typeid(Pet))</span><br><span class="line">    cout &lt;&lt; &quot;p points to a pet.&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第20 ~ 21行：对象<em>p的编译时类型为包含虚函数的Pet，typeid( )通过对象</em>p内部的vptr进行运行时类型识别，得到其真实的类型Rabbit。虽然Rabbit是Pet的子类，但Rabbit不等于Pet，上述逻辑判断不成立，第21行未执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (typeid(*p)==typeid(Rabbit))</span><br><span class="line">    cout &lt;&lt; &quot;p points to a rabbit.&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第22 ~ 23行：如上所述，借助于过行时类型识别（RTTI），typeid(<em>p)返回了</em>p的运行时类型（即事实类型）Rabbit。上述逻辑判断成立，第23行被执行，其输出对应执行结果的第2行。</p>
<h3 id="18-5-类型转换"><a href="#18-5-类型转换" class="headerlink" title="18.5 类型转换"></a>18.5 类型转换</h3><p>C语言风格的显式类型转换是有风险的，相当于程序员直接告诉编译器：忘掉你的类型检查，把这个对象当成另外一个类型来处理。无论这种转换是不是合理的，编译器都会照单全收。不恰当的类型转换的后果需要到运行时才“可能”体现出来。</p>
<p>为尽量避免上述问题，<strong>【C++】</strong>提供了4种显式类型转换语法，本节逐一进行介绍。</p>
<h4 id="18-5-1-static-cast"><a href="#18-5-1-static-cast" class="headerlink" title="18.5.1 static_cast"></a>18.5.1 static_cast</h4><p>按照下述语法，static_cast可以完成那些”合理“的类型转换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static_cast&lt;目标类型&gt;(对象)</span><br></pre></td></tr></table></figure>

<p>所谓”合理“的类型转换包括基本C&#x2F;C++数据类型的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int v = 77;</span><br><span class="line">long long ll = static_cast&lt;long long&gt;(v);//int --&gt; long long</span><br><span class="line">float f = static_cast&lt;float&gt;(v);         //int --&gt; float</span><br><span class="line">unsigned char uc = static_cast&lt;unsigned char&gt;(v); //允许但有风险</span><br><span class="line">//float* p = static_cast&lt;float*&gt;(&amp;v);    //错误:int* --&gt; float*</span><br></pre></td></tr></table></figure>

<p>第4行：从int转换成unsigned char，可以由static_cast完成，但因为类型收窄（narrowing）的原理，有极大的数据失真的风险。</p>
<p>第5行：不允许基本数据类型指针之间的static_cast类型转换，这种转换只能通过reinterpret_cast进行。本例中，将int<em>转换成float</em>，涉及到彻底的数据的重新解释，<strong>强制程序员使用reinterpret_cast，相当于强制程序员重新审视这种转换的合理性与必要性</strong>。</p>
<p>此外，static_cast也可以在具有继承关系的类型之间进行转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Pet&#123;&#125;;</span><br><span class="line">class Cat:public Pet&#123;&#125;;</span><br><span class="line">class Dog:public Pet&#123;&#125;;</span><br><span class="line">...</span><br><span class="line">    Cat c;</span><br><span class="line">    Pet p = static_cast&lt;Pet&gt;(c);	   //Cat --&gt; Pet</span><br><span class="line">    Pet&amp; p1 = static_cast&lt;Pet&amp;&gt;(c);    //Cat --&gt; Pet&amp;</span><br><span class="line">    Pet* p2 = static_cast&lt;Pet*&gt;(&amp;c);   //Cat* --&gt; Pet*</span><br><span class="line">    Cat* c1 = static_cast&lt;Cat*&gt;(p2);   //Pet* --&gt; Cat*, 允许但不安全</span><br><span class="line">    //Cat c2 = static_cast&lt;Cat&gt;(p);    //错误:Pet --&gt; Cat</span><br></pre></td></tr></table></figure>

<p>第8行：Cat<em><strong>向上类型转换（upcasting）</strong>为Pet</em>，是安全的，因为Cat是Pet的子类。</p>
<p>第9行：Pet<em><strong>向下类型转换（downcasting）</strong>为Cat</em>，static_cast允许这种向下类型转换，并不意味着这是安全的。因为p2所指向的对象，可能是Dog，不是Cat。安全的向下类型转换，建议使用dynamic_cast。</p>
<p>第10行：不支持Pet至Cat类型的转换。在本例中，p虽然来自Cat c，但因为对象切片（object slicing）的原因，p只包含了对象c内的Pet部分，static_cast不支持这种转换具有合理性。</p>
<h4 id="18-5-2-const-cast"><a href="#18-5-2-const-cast" class="headerlink" title="18.5.2 const_cast"></a>18.5.2 const_cast</h4><p>按照下述语法，const_cast可以将常量型转换成对应的非常量型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const_cast&lt;非常量目标类型&gt;(对象)</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;&#125;;</span><br><span class="line">...</span><br><span class="line">    const Cat cat;</span><br><span class="line">    Cat&amp; c = const_cast&lt;Cat&amp;&gt;(cat); //const Cast --&gt; Cat&amp;</span><br><span class="line"></span><br><span class="line">    const int v = 777;</span><br><span class="line">    int v1 = v;                     //const int --&gt; int,无转换必要</span><br><span class="line">    int&amp; r = const_cast&lt;int&amp;&gt;(v);   //const int --&gt; int&amp;</span><br><span class="line">    int* p = const_cast&lt;int*&gt;(&amp;v);  //const int* --&gt; int*</span><br></pre></td></tr></table></figure>

<p>第7行：将一个常量型对象转换成一个同类型的非常量对象，直接赋值即可办到，没有进行显示类型转换的必要。</p>
<p>第8行：为const int类型的对象v创建非常量型引用r，这事实上破坏了v的常量性，因为通过引用r，可以达到修改v的目的。</p>
<p>第9行：v的类型为const int， &amp;v的类型为const int<em>，即指向const int的指针。本行代码将&amp;v转换成int</em>并赋值给p，同样破坏了v的常量性：可以通过指针p来修改v值。</p>
<blockquote>
<p><strong>警告🚩</strong> 没有十分特别的站得住脚的理由时，不要使用const_cast！ 将对象声明为常量型，相当于给程序的阅读者、编译器以及与你一起工作的同事许下了一个诺言：我不会修改这个对象。而通过const_cast去除其常量性，相当于偷偷地违背了自己许下的诺言。这很可能成为bug（软件缺陷）之源。</p>
<p>在重用他人代码的前提下，如果不得不使用，一定要给以特别的注释，并在注释及软件文档中说明理由。</p>
</blockquote>
<h4 id="18-5-3-reinterpret-cast"><a href="#18-5-3-reinterpret-cast" class="headerlink" title="18.5.3 reinterpret_cast"></a>18.5.3 reinterpret_cast</h4><p>按照下述语法，可以将一个类型的对象重新解释成另一个类型的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reinterpret_cast&lt;目标类型&gt;(对象)</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Project - ReinterpretCast</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    unsigned int v = 0x11223344;</span><br><span class="line">    unsigned char* rawBytes = reinterpret_cast&lt;unsigned char*&gt;(&amp;v);</span><br><span class="line">    printf(&quot;bytes of v: %x - %x - %x - %x&quot;,</span><br><span class="line">           rawBytes[0],rawBytes[1],rawBytes[2],rawBytes[3]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes of v: 44 - 33 - 22 - 11</span><br></pre></td></tr></table></figure>

<p>第7行：将4字节的整数v的地址重新解释转换成char*。</p>
<p>第8行：逐一将变量v的四个字节的值按十六进制输出。可以看到，在作者的x86计算机上，低字节（0x44）在低地址。</p>
<p>由于reinterpret_cast会导致程序以完全不同的方式来解释对象的原有内存，所以使用时应十分谨慎。</p>
<h4 id="18-5-4-dynamic-cast"><a href="#18-5-4-dynamic-cast" class="headerlink" title="18.5.4 dynamic_cast*"></a>18.5.4 dynamic_cast*</h4><p>在一个继承关系中，如果将子类对象的地址或者引用转换为父类对象的指针或引用，称之为向上类型转换（upcasting）。这种转换是安全的。</p>
<p>但如果反过来，把一个父类对象的指针或者引用转换成子类对象的指针或引用，则称之为向下类型转换（downcasting）。这种转换有风险，应通过dynamic_cast进行。</p>
<p>按照下述语法，可以将父类对象的指针或者引用转换为子类对象的指针或引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dynamic_cast&lt;目标类型&gt;(对象指针/引用)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意📢</strong> dynamic_cast依赖于RTTI在运行时识别对象的实际类型，而RTTI的实现，又依赖于对象内部的虚函数表指针vptr。因此，上述“对象”的编译时类型必须包含虚函数，否则，编译器会报错。</p>
</blockquote>
<p>C++示例程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - DynamicCast</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Pet&#123;public: virtual ~Pet()&#123;&#125;&#125;;   //Pet父类有虚函数</span><br><span class="line">class Cat:public Pet&#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;meow&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Dog:public Pet&#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Pet* p = new Cat();</span><br><span class="line">    Cat* c = dynamic_cast&lt;Cat*&gt;(p);	   //指针转换失败会返回一个nullptr</span><br><span class="line">    if (c)&#123;</span><br><span class="line">        c-&gt;sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cat&amp; c1 = dynamic_cast&lt;Cat&amp;&gt;(*p);  //类型转换失败会抛出一个std::bad_cast异常</span><br><span class="line">    c1.sayHello();</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meow</span><br><span class="line">meow</span><br></pre></td></tr></table></figure>

<p>第16行：将Pet<em>类型的指针p转换成Cat</em>类型的指针c。dynamic_cast会检查p所指向的对象内部的vptr进行运行行类型识别，如果对象的实际类型是Cat或者是Cat的子类型，则转换成功。否则，dynamic_cast会返回空指针nullptr。本例中，p指向的事实上是个Cat对象，转换成功。</p>
<p>第17行：如果指针c非空，则说明转换成功，c可以被使用。</p>
<p>第21行：同理，dynamic_cast通过检查*p对象内部的vptr进行运行行类型识别。如果转换失败，则一个类型为std::bad_cast的异常▲会被抛出。</p>
<h3 id="18-6-纯虚函数及抽象类"><a href="#18-6-纯虚函数及抽象类" class="headerlink" title="18.6 纯虚函数及抽象类*"></a>18.6 纯虚函数及抽象类*</h3><p><img src="http://codelearn.club/images/image-20200404152603920.png" alt="image-20200404152603920"></p>
<p>图18- 抽象类继承结构</p>
<p>在上述继承结构中，为Pet类型的speak( )方法提供函数体可能毫无用处：① 你养的宠物，要么是狗、要么是猫、或者其他动物，不存在不是狗、不是猫、不是蛇或者其他动物的纯粹的宠物；② 狗、猫、兔子的叫声各不相同，即Pet的各个子类，会实现各自独立的speak( )虚函数。</p>
<p>基于以上考量，可以将Pet类的部分虚函数定义<strong>纯虚函数（pure virtual function）</strong>，从而使得Pet类型成为<strong>抽象类（abstract class）</strong>。纯虚函数的定义方法是在成员函数声明中用添加”&#x3D; 0”，并省略其函数体定义。</p>
<blockquote>
<p><strong>要点🎯</strong> 将成员函数定义为纯虚函数可以获得两方面的收益：</p>
<p>① 避免为不必要地为函数提供函数体。</p>
<p>② 使得类成为不可实例化的抽象类。所谓不可实例化，即是指你不可以直接创建这个类的对象。</p>
</blockquote>
<p>下述C++代码定义了图18- 所示的Pet抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Project - AbstractClass</span><br><span class="line">...</span><br><span class="line">class Pet &#123;</span><br><span class="line">protected:</span><br><span class="line">    string sName;</span><br><span class="line">public:</span><br><span class="line">    void virtual speak() = 0;   //=0表示该函数为纯虚函数</span><br><span class="line">    void virtual eat(int weight) = 0;</span><br><span class="line">    Pet(const string&amp; name):sName(name)&#123;&#125;</span><br><span class="line">    virtual ~Pet()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    //Pet p(&quot;Emily&quot;);</span><br><span class="line">    //Pet* p = new Pet(&quot;Emily&quot;);    //错误：抽象类不可以实例化</span><br></pre></td></tr></table></figure>

<p>上述Pet类有两个纯虚函数，分别为第7行的speak( )以及第8行的eat( )。作为包含纯虚函数的抽象类，Pet类型不可以被实例化，上述代码的第13行、第14行都会被编译器拒绝。</p>
<blockquote>
<p><strong>要点🎯</strong> 抽象基类的纯虚函数需要在其扩展类中被实现&#x2F;定义。当且仅当所有基类的纯虚函数都被实现后，扩展类才可能被实例化。</p>
</blockquote>
<p>下述C++代码实现了图18- 中所示的Rabbit类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Project - AbstractClass</span><br><span class="line">...</span><br><span class="line">class Pet &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">class Rabbit:public Pet &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Hello from rabbit &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Rabbit &quot; &lt;&lt; sName &lt;&lt; &quot; ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rabbit(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    Pet* r = new Rabbit(&quot;Eddie&quot;);</span><br><span class="line">    r-&gt;eat(100);</span><br><span class="line">    r-&gt;speak();</span><br><span class="line">    delete r;</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果（局部）为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rabbit Eddie ate 100 gram&#x27;s food.</span><br><span class="line">Hello from rabbit Eddie</span><br></pre></td></tr></table></figure>

<p>第7 ~ 13行：Rabbit类型为Pet父类的两个纯虚函数speak( )以及eat( )提供了函数体，也称为实现了这两个纯虚函数。</p>
<p>由于不存在未实现的纯虚函数，Rabbit类不是抽象类，可以直接创建Rabbit类型的对象。</p>
<p>第18行：创建名为Eddie的Rabbit对象，并将其地址向上类型转换为Pet*，赋值给r。</p>
<p>第19 ~ 20行：通过Pet*类型的指针r，通过晚绑定调用执行Eddie兔的eat( )及speak( )函数。执行结果证实，Eddie兔的相关代码被执行。</p>
<p>下述C++代码实现了图18- 所示的Cat类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - AbstractClass</span><br><span class="line">...</span><br><span class="line">class Pet &#123;&#125;</span><br><span class="line">...</span><br><span class="line">class Cat:public Pet&#123;</span><br><span class="line">public:</span><br><span class="line">    void eat(int weight)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat &quot; &lt;&lt; sName &lt;&lt; &quot; ate &quot; &lt;&lt; weight &lt;&lt; &quot; gram&#x27;s food.\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cat(const string&amp; name):Pet(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    //Cat c(&quot;Lucy&quot;);</span><br><span class="line">    //Pet* c = new Cat(&quot;Lucy&quot;);     //错误：抽象类Cat不可以实例化</span><br></pre></td></tr></table></figure>

<p>上述代码中的Cat类仅实现了基类Pet的一个纯虚函数eat( )，未实现另一个纯虚函数speak( )，因此Cat类型仍为抽象类，不可以被实例化。第14行、第15行代码会被编译器拒绝。</p>
<p>下述C++代码实现了图18- 所示的DragonLi（狸花猫）及Persian（波斯猫）类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//Project - AbstractClass</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">...</span><br><span class="line">class Pet &#123;...&#125;;</span><br><span class="line">class Cat:public Pet&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">class DragonLi:public Cat&#123;</span><br><span class="line">public:</span><br><span class="line">    void speak()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Hello from dragonli cat &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DragonLi(const string&amp; name):Cat(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Persian:public Cat&#123;</span><br><span class="line">public:</span><br><span class="line">    void speak()&#123;</span><br><span class="line">        cout &lt;&lt; &quot;Hello from persian cat &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Persian(const string&amp; name):Cat(name)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">    shared_ptr&lt;Pet&gt; c1(new DragonLi(&quot;Happy&quot;));</span><br><span class="line">    unique_ptr&lt;Cat&gt; c2(new Persian(&quot;Socks&quot;));</span><br><span class="line">    c1-&gt;eat(100);</span><br><span class="line">    c1-&gt;speak();</span><br><span class="line">    c2-&gt;eat(100);</span><br><span class="line">    c2-&gt;speak();</span><br></pre></td></tr></table></figure>

<p>上述代码执行结果（局部）为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat Happy ate 100 gram&#x27;s food.</span><br><span class="line">Hello from dragonli cat Happy</span><br><span class="line">Cat Socks ate 100 gram&#x27;s food.</span><br><span class="line">Hello from persian cat Socks</span><br></pre></td></tr></table></figure>

<p>DragonLi及Persian各自实现了纯虚函数speak( )，其基类Cat实现了纯虚函数eat( )。因此，DargonLi及Persian的基类的纯虚函数全部得以实现，它们不是抽象类，可以实例化。</p>
<p>第25 ~ 26行：创建名为Happy的狸花猫及名为Socks的波斯猫动态对象，并将其地址交给智能指针管理。本例中，c1为指向Pet对象的shared_ptr类型智能指针，c2为指向Cat对象的unique_ptr类型智能指针。</p>
<p>第27 ~ 30行：通过智能使用分别执行两只猫的eat( )及speak( )方法，由于晚绑定的关系，“正确”的方法被调用执行。在执行结果中可以看到相关输出。</p>
<p>当作为自动变量的智能指针对象c1和c2超过作用域时，其析构函数会释放两个猫对象，手工delete不再被需要。</p>
<h3 id="18-7-多态应用举例"><a href="#18-7-多态应用举例" class="headerlink" title="18.7 多态应用举例*"></a>18.7 多态应用举例*</h3><blockquote>
<p><strong>要点🎯</strong> 抽象类的最大用途在于为所有的扩展类定义一个统一的<strong>接口（interface）</strong>。</p>
</blockquote>
<p>想象一个Word类软件，WPS或者Open Office之类，在文档中，用户会加入非常多的界面元素，包括但不限于：三角形、箭头、段落、圆形、矩形、艺术字、图片。在面向对象程序设计中，这些元素都会使用类来描述，并且，设计者一定会为这些界面元素提供一个统一的父类。作者把这个类结构简化成图18- 的模样，读者要明白真实的情况比这个要复杂得多，但基本结构大体如此。</p>
<p><img src="http://codelearn.club/images/ShapesCpp.png" alt="img"></p>
<p>图18- Shape继承结构</p>
<p>可以看到，所有的界面元素，三角形、圆形、… 、 文本段落（paragraph），被描述成拥有一个共同的祖先类（Shape）。这个祖先类可以是抽象类，这意味着系统不允许你创建Shape类的对象。抽象类什么具体的工作也不做，只是描述了他的全部后代的模样：至少实现描绘自身的draw( ）以及获取元素在页面中的空间尺寸的getSize( )这两个方法。这种描述是强制性的，它的后代必须实现这两个方法或函数。</p>
<p>Triangle类用三个点坐标来描述自己的属性，除了实现必须的draw()和getSize()方法外，还实现了一个getArea()方法以计算自身所占面积。</p>
<p>Circle类则用一个圆点坐标以及一个半径来描述自己，也实现了额外的getArea()函数。</p>
<p>文本段落（Paragraph）类则用一个字符串sContent来存储其文本内容，另外，还额外实现了setFont()函数来设置文本的字体和字号。</p>
<p>下述C++代码给出了上述继承结构的极简版实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Project - Word</span><br><span class="line">...</span><br><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    //virtual Size getSize() = 0;</span><br><span class="line">    virtual void draw() = 0;</span><br><span class="line">    virtual ~Shape()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Triangle:public Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    //point0, point1, point2</span><br><span class="line">    //Size getSize(...)</span><br><span class="line">    //float getArea(...)</span><br><span class="line">    void draw()&#123; cout &lt;&lt; &quot;Triangle::draw()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle:public Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    //ptCenter, iRadius</span><br><span class="line">    //Size getSize(...)</span><br><span class="line">    //float getArea(...)</span><br><span class="line">    void draw() &#123; cout &lt;&lt; &quot;Circle::draw()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Paragraph:public Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    string sContent;</span><br><span class="line">    //Size getSize(...)</span><br><span class="line">    //void setFont(...)</span><br><span class="line">    void draw()&#123; cout &lt;&lt; &quot;Paragraph::draw()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>让我们把关注点放在这三个类的draw()函数上。Office类软件会用文档来组织这些界面元素，在这里我们把文档想像成一个数组，在这个数组包含了很多个三角形、矩形、段落、图片、艺术字、公式、图表对象，这些对象都是Shape类的子对象，都实现了draw()方法。</p>
<p>当一个页面被显示出来时，软件会遍历这个数组，然后逐一调用数组内Shape子对象的draw()方法，以便把每个界面元素画出来。对，你听得没错，就是每个对象自己画自己。因为三角形类了解三角形的数据表达形式，掌握描绘一个三角形的全部信息，由这个类的draw()来承担这个职责再合适不过了。圆形、段落这些类也是类似情况。我们设想一下，假设在页面上描绘三角形的任务不是由三角形类来完成，而是由外部代码来完成，那么外部代码就必须清楚并访问三角形对象内部的全部细节，如果这件事情真的发生的话，对于软件工程而言是灾难性的：外部代码知道太多关于三角形内部实现的细节！ 内部实现的细节变成了接口的一部分！ 三角形类接口不再简洁明了！ 以后你如果想修改三角形的内部数据结构，这几乎不可能，因为外部代码也要跟着改，涉及的外部程序和修改点可能太多 。这种复杂的情况，我们称之为<strong>紧耦合（tight coupling）</strong>。而程序的<strong>松散耦合（loose coupling）</strong>，才是我们的目标。</p>
<p>我们通过下述C++程序来模拟一个文档内的全部界面元素被逐一绘制的场景：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - Word</span><br><span class="line">...</span><br><span class="line">void renderDocument(Shape* shapes[], int n)&#123;</span><br><span class="line">    for (auto i=0; i&lt;n;i++)</span><br><span class="line">        shapes[i]-&gt;draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Shape* shapes[] = &#123;new Triangle(),new Triangle(),new Circle(),</span><br><span class="line">                      new Circle(), new Paragraph()&#125;;</span><br><span class="line"></span><br><span class="line">    renderDocument(shapes,5);</span><br><span class="line"></span><br><span class="line">    for (auto x:shapes)</span><br><span class="line">        delete x;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Triangle::draw()</span><br><span class="line">Triangle::draw()</span><br><span class="line">Circle::draw()</span><br><span class="line">Circle::draw()</span><br><span class="line">Paragraph::draw()</span><br></pre></td></tr></table></figure>

<p>在这段代码里，我们创建了两个三角形，两个圆形，一个段落 ，然后把它们放入一个数组中，这个数组就是一个文档的简化表达形式。renderDocument( )函数遍历这个数组，逐一执行其元素的draw( )方法。我们看到，renderDocument()函数并不清楚数组元素shapes[i]的具体类型，它只认为它是指向Shape对象的指针，而Shape对象实现了draw()方法，至于该对象到底是三角形、圆形或者别的什么界面元素，完全不关心。但是，我们发现，shapes[i]指向什么类型，就会执行对应类型的draw()函数，并打印出对应的文字。这就是多态，这些变量类型未知，但自动展现出与类型对应的恰当行为。</p>
<p>本节展示的类结构为程序的扩展提供了无限的可能及便利。如果Office软件试图建立一种全新的界面元素，比如某种直方图图表，软件设计者所要做的，就是继承Shape类并设计一个新的类，然后在新的类里实现全部虚函数。然后，上述renderDocument( )函数一个字符都不用修改，即可以拥抱新的界面元素的加入所带来的变化，以不变应万变！</p>
<p>想想一下没有多态时的可怕场景，上述renderDocument( )函数可能需要修改成下述伪代码所描述的模样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void renderDocument(Shape* shapes[], int n)&#123;</span><br><span class="line">    for (auto i=0; i&lt;n;i++)&#123;</span><br><span class="line">        x = shapes[i];</span><br><span class="line">        if x 指向的是三角形</span><br><span class="line">            执行三角形的draw函数</span><br><span class="line">        else if x 指向的是圆形</span><br><span class="line">            执行圆形的draw函数</span><br><span class="line">        else if x 指向的是矩形</span><br><span class="line">            执行矩形的draw函数</span><br><span class="line">            ...</span><br><span class="line">        else if x 指向的是艺术字</span><br><span class="line">            执行艺术字的draw函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就Word而言，其界面元素类型多达数百种甚至更多，上述第10行的省略号的背后，可能是上千行效率极其低下的难以维护的多分支代码。</p>
<h2 id="19-容器与模板"><a href="#19-容器与模板" class="headerlink" title="19. 容器与模板"></a>19. 容器与模板</h2><p>用数组，即便是动态数组，来保存对象有一个很大的局限：难以准确估计需要的数组空间。如果将数组定义得过大，可能浪费内存，如果定义得过小，又存在容量不足的可能。</p>
<blockquote>
<p><strong>要点🎯</strong> 容器（container）类对象可以像数组那样容纳其它对象。数组的容量是固定的，而容器类对象（模板数组▲除外）的容量可以需要自动伸缩。</p>
</blockquote>
<p>表19-1列出了标准模板库中的容器类型及其特点，本章将介绍主常用的几种。</p>
<p>表19-1 容器类型</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>vector&#x2F;向量</td>
<td>尺寸可伸缩的“数组”，可以快速地随机存取元素值。当在特定位置（尾部除外）删除或插入无素时，速度较慢。</td>
</tr>
<tr>
<td>array&#x2F;数组</td>
<td>固定元素个数的数组，可以快速随机存取元素值。不支持插入或者删除元素。</td>
</tr>
<tr>
<td>string&#x2F;字符串</td>
<td>用于包含字符的特殊向量，可以快速地随机存取元素值。当在特定位置（尾部除外）删除或插入无素时，速度较慢。</td>
</tr>
<tr>
<td>deque&#x2F;双端队列▲</td>
<td>可以快速随机存取元素值。在头部&#x2F;尾部插入、删除元素速度较快。</td>
</tr>
<tr>
<td>list&#x2F;双向链表▲</td>
<td>不可以随机存取元素，仅支持双向的顺序元素存取。可以快速地在任意位置插入、删除元素。</td>
</tr>
<tr>
<td>forward list&#x2F;前向链表▲</td>
<td>不可以随机存取元素，仅支持前向的顺序元素存取。可以快速地在任意位置插入、删除元素。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="19-1-向量"><a href="#19-1-向量" class="headerlink" title="19.1 向量"></a>19.1 向量</h3><p>向量（vector）类型来自于标准模板库（standard template library），由vector头文件引入。其工作方式与数组类似，主要区别有二：元素类型由模板参数指定；容量根据使用需要自动伸缩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;  v1;     //元素类型为string的向量</span><br><span class="line">vector&lt;int&gt; v2;         //元素类型为int的向量</span><br><span class="line">vector&lt;Fish*&gt; v3;       //向量，其元素类型为Fish*，即指向Fish对象的指针</span><br></pre></td></tr></table></figure>

<p>上述代码定义了三个向量，其存储的元素类型各不相同。当向量刚被创建时，默认为空，即不包含任何元素。</p>
<p>我们通过下述C++示例程序来简单解释向量的用法。在本章随书代码的WordsCount项目目录下，有一个名为title.txt的文本文件，其内容是一首美丽的诗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">When you are old</span><br><span class="line">--- William Butler Yeats</span><br><span class="line">When you are old and grey and full of sleep,</span><br><span class="line">And nodding by the fire, take down this book,</span><br><span class="line">And slowly read, and dream of the soft look</span><br><span class="line">Your eyes had once, and of their shadows deep;</span><br><span class="line"></span><br><span class="line">How many loved your moments of glad grace,</span><br><span class="line">And loved your beauty with love false or true,</span><br><span class="line">But one man loved the pilgrim soul in you,</span><br><span class="line">And loved the sorrows of your changing face;</span><br><span class="line"></span><br><span class="line">And bending down beside the glowing bars,</span><br><span class="line">Murmur, a little sadly, how Love fled</span><br><span class="line">And paced upon the mountains overhead</span><br><span class="line">And hid his face amid a crowd of stars.</span><br></pre></td></tr></table></figure>

<p>我们通过程序来对这首诗进行词频统计：找出这首诗中的全部单词并统计该单词在诗中出现的次数。程序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Project - WordsCount</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ifstream in(&quot;C:/C2Cpp/C19_Container/WordsCount/title.txt&quot;);</span><br><span class="line">    vector&lt;string&gt; words;   //words[i]存放发现的第i个单词</span><br><span class="line">    vector&lt;int&gt; counts;     //counts[i]存放words[i]在诗中的出现次数</span><br><span class="line"></span><br><span class="line">    string sWord;</span><br><span class="line">    while (in &gt;&gt; sWord)&#123;    //operator&gt;&gt;(in,sWord)</span><br><span class="line">        for (size_t i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">            if (words[i]==sWord)&#123;</span><br><span class="line">                counts[i]++;</span><br><span class="line">                sWord = &quot;&quot;;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sWord!=&quot;&quot;)&#123;</span><br><span class="line">            words.push_back(sWord);</span><br><span class="line">            counts.push_back(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(words.size()==counts.size());//断言向量words及counts长度相等</span><br><span class="line">    for (size_t i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">        cout &lt;&lt; words[i] &lt;&lt; &quot;:&quot; &lt;&lt; counts[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When:2, you:2, are:2, old:2, ---:1, William:1, Butler:1, Yeats:1, and:4, grey:1, full:1, of:6, sleep,:1, And:7, nodding:1, by:1, the:6, fire,:1, take:1, down:2, this:1, book,:1, slowly:1, read,:1, dream:1, soft:1, look:1, Your:1, eyes:1, had:1, once,:1, their:1, shadows:1, deep;:1, How:1, many:1, loved:4, your:3, moments:1, glad:1, grace,:1, beauty:1, with:1, love:1, false:1, or:1, true,:1, But:1, one:1, man:1, pilgrim:1, soul:1, in:1, you,:1, sorrows:1, changing:1, face;:1, bending:1, beside:1, glowing:1, bars,:1, Murmur,:1, a:2, little:1, sadly,:1, how:1, Love:1, fled:1, paced:1, upon:1, mountains:1, overhead:1, hid:1, his:1, face:1, amid:1, crowd:1, stars.:1,</span><br></pre></td></tr></table></figure>

<p>说明：第9行中的”C:&#x2F;C2Cpp&#x2F;C19_Container&#x2F;WordsCount&#x2F;title.txt”是title.txt在作者计算机上的完整路径，读者运行上述程序时，可能需要根据实际情况作出修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br></pre></td></tr></table></figure>

<p>第3行：vector头文件引入向量类型，其属于标准模板库（standard template library）的构成部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br></pre></td></tr></table></figure>

<p>第4行：fstream是文件流（file stream）头文件，本例中，其引入的ifstream类型用于读入文本文件的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br></pre></td></tr></table></figure>

<p>第5行：引入<strong>断言（assertion）宏（macro）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(&quot;C:/C2Cpp/C19_Container/WordsCount/title.txt&quot;);</span><br></pre></td></tr></table></figure>

<p>第9行：定义一个输入文件流（<strong>i</strong>nput <strong>f</strong>ile <strong>s</strong>tream）对象in，该对象会打开参数字符串所指明的文本文件。在后续代码中，可以从该输入文件流读取内容，就像从控制台输入流（cin，即console input stream）读取内容一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; words;   //words[i]存放发现的第i个单词</span><br><span class="line">vector&lt;int&gt; counts;     //counts[i]存放words[i]在诗中的出现次数</span><br></pre></td></tr></table></figure>

<p>第10 ~ 11行：定义了向量words及counts，其含义见代码注释。向量的逻辑上与数组非常相似，words[i]代表向量内存储的第i个元素。在程序运行过程中，words和counts的元素个数应是相等的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (in &gt;&gt; sWord)&#123;    //operator&gt;&gt;(in,sWord)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14 ~ 26行：循环从输入文件流读入一个字符串（以空格作为分隔符），并进行处理。其中，in &gt;&gt; sWord等价于operator&gt;&gt;(in, sWord)，当in中的全部内容都被读取完毕后，该操作符函数将返回False并导致循环结束。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (size_t i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">    if (words[i]==sWord)&#123;</span><br><span class="line">        counts[i]++;</span><br><span class="line">        sWord = &quot;&quot;;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第15 ~ 21行：读取到一个单词（字符串）sWord后，先在向量对象words中进行查找。</p>
<ul>
<li>成员函数<strong>size( )返回向量内保存的元素个数</strong>，其返回类型为size_t，在作者的计算机上，size_t即为unsigned long long。使用无符号长整数来表示向量的元素个数具有一定的合理性，因为元素数量不可能为负。</li>
<li><strong>words[i]表示向量words内下标为i的元素</strong>。 这意味着同数组一样，向量内的元素是有先后顺序的。words[i]事实上执行的是words.operator<a href="i"> </a>，该重载操符符函数将返回元素的引用，本例中，其类型为string&amp;。</li>
<li>如果在words向量内找到字符串sWord（第16行），则将其计数counts[i]加1（第17行），并将sWord置为空串（18行）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (sWord!=&quot;&quot;)&#123;</span><br><span class="line">    words.push_back(sWord);</span><br><span class="line">    counts.push_back(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第22 ~ 25行：如果sWord不为空，则说明未在words中找到sWord，它是一个新发现的单词。将sWord加入向量words，并在向量counts尾部增加元素1。向量的push_back( )成员函数将参数对象添加到向量的末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(words.size()==counts.size());//断言向量words及counts长度相等</span><br></pre></td></tr></table></figure>

<p>第28行：如果程序逻辑完全正确，向量words及counts的元素个数应当相等。本例中，<strong>assert宏将会在运行时对“参数”表达式进行检查，如果为假，程序将会报错</strong>。通常，断言（assertion）失败的报错信息包含具体的源代码文件名及断言失败的行号，这对程序员查找程序缺陷非常有用。当断言成功时，它什么都不会做。</p>
<blockquote>
<p><strong>建议🔔</strong> 人都会犯错，在程序的恰当位置适当地通过断言来帮助发现错误，是有益的实践。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (size_t i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">    cout &lt;&lt; words[i] &lt;&lt; &quot;:&quot; &lt;&lt; counts[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第29 ~ 31行：将诗中出现的单词以及词频（次数）配对打印。</p>
<p>可以在向量定义时通过列表初始化<strong>【C++ 11】</strong>语法来为向量指定初始成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Project - VectorInit</span><br><span class="line">	vector&lt;string&gt; v0 &#123;&quot;good&quot;, &quot;better&quot;, &quot;best&quot;&#125;;</span><br><span class="line">    vector&lt;string&gt; v1 = &#123;&quot;good&quot;, &quot;better&quot;, &quot;best&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>上述程序中的v0，v1都是包含三个字符串元素的向量，其值分别为”good”、”better”以及”best”。</p>
<p>此外，也可以通过指定构造函数参数来初始化向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v2(5,&quot;hi&quot;);</span><br><span class="line">vector&lt;int&gt; v3(6);</span><br></pre></td></tr></table></figure>

<p>上述程序中的v2包含5个字符串元素，每个字符串均为”hi”；v3则包含6个元素，其值全部为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v4 &#123;6&#125;;      //vs.  v4(6)</span><br><span class="line">vector&lt;int&gt; v5 &#123;6,1&#125;;    //vs.  v5(6,1)</span><br></pre></td></tr></table></figure>

<p>实践中，应注意区分初始化列表的{ }与构造函数的( )号。上述程序中的v4仅包含一个值为6的元素，而不是6个值为0的元素；v5仅包含值为6和1的两个元素，而不是6个值为1的元素。</p>
<h3 id="19-2-向量的生长"><a href="#19-2-向量的生长" class="headerlink" title="19.2 向量的生长"></a>19.2 向量的生长</h3><p>向量的存储空间根据需要而自动伸缩。当现有的存储空间不足以容纳新增元素时，向量会自动申请新的存储空间，并将旧的元素进行迁移。我们通过分析下述C++程序来理解向量的内存管理行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//Project - FishVector</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish&#123;</span><br><span class="line">    string sNumber;</span><br><span class="line">public:</span><br><span class="line">    Fish()&#123;</span><br><span class="line">        static int i = 0;</span><br><span class="line">        sNumber = std::to_string(i++);</span><br><span class="line">        cout &lt;&lt; &quot;Fish constructor: &quot; &lt;&lt; sNumber &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fish(const Fish&amp; r)&#123;</span><br><span class="line">        sNumber = r.sNumber + &quot;[Copy]&quot;;</span><br><span class="line">        cout &lt;&lt; &quot;Fish copy constructor: &quot; &lt;&lt; sNumber &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Fish()&#123; cout &lt;&lt; &quot;Fish destructor: &quot; &lt;&lt; sNumber &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;Fish&gt; f(2);    //0,1号鱼</span><br><span class="line">    printf(&quot;f.capacity = %d, f.size = %d\n&quot;,f.capacity(),f.size());</span><br><span class="line">    Fish f2;              //2号鱼</span><br><span class="line">    cout &lt;&lt; &quot;-------------f.push_back(f2)----------&quot; &lt;&lt; endl;</span><br><span class="line">    f.push_back(f2);</span><br><span class="line">    printf(&quot;f.capacity = %d, f.size = %d\n&quot;,f.capacity(),f.size());</span><br><span class="line">    cout &lt;&lt; &quot;vector f is &quot; &lt;&lt; (f.empty()?&quot;empty.\n&quot;:&quot;not empty.\n&quot;);</span><br><span class="line">    cout &lt;&lt; &quot;-------------f.pop_back()-------------&quot; &lt;&lt; endl;</span><br><span class="line">    f.pop_back();</span><br><span class="line">    cout &lt;&lt; &quot;-------------f.resize(1)--------------&quot; &lt;&lt; endl;</span><br><span class="line">    f.resize(1);</span><br><span class="line">    cout &lt;&lt; &quot;-------------f.clear()----------------&quot; &lt;&lt; endl;</span><br><span class="line">    f.clear();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Fish constructor: 0</span><br><span class="line">Fish constructor: 1</span><br><span class="line">f.capacity = 2, f.size = 2</span><br><span class="line">Fish constructor: 2</span><br><span class="line">-------------f.push_back(f2)----------</span><br><span class="line">Fish copy constructor: 2[Copy]</span><br><span class="line">Fish copy constructor: 0[Copy]</span><br><span class="line">Fish copy constructor: 1[Copy]</span><br><span class="line">Fish destructor: 0</span><br><span class="line">Fish destructor: 1</span><br><span class="line">f.capacity = 4, f.size = 3</span><br><span class="line">vector f is not empty.</span><br><span class="line">-------------f.pop_back()-------------</span><br><span class="line">Fish destructor: 2[Copy]</span><br><span class="line">-------------f.resize(1)--------------</span><br><span class="line">Fish destructor: 1[Copy]</span><br><span class="line">-------------f.clear()----------------</span><br><span class="line">Fish destructor: 0[Copy]</span><br><span class="line">Fish destructor: 2</span><br></pre></td></tr></table></figure>

<p>说明：不同版本的标准模板库在算法策略上会有差异，在读者的计算机上，上述执行结果很可能与本书存在差异。</p>
<p>第6 ~ 21行：Fish类型的构造函数通过局部静态变量i为每个新对象提供一个唯一的序号（sNumber）。当Fish对象被拷贝构造时，sNumber序号会增加”[Copy]“字样，以表明拷贝生成的新对象是由哪一个旧对象拷贝而得的。无论是构造函数，拷贝构造函数，还是析构函数，都会向控制台打印包括序号的报告信息，以便于我们观察向量元素增减时的内存管理行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Fish&gt; f(2);    //0,1号鱼</span><br></pre></td></tr></table></figure>

<p>第24行：f向量的构造参数2导致向量自动创建了0号鱼及1号鱼。0，1号鱼的构造函数输出见执行结果的第1 ~ 2行。可以想象，该行代码事实上要求Fish类型必须具备一个“零参数”的构造函数，否则编译器会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;f.capacity = %d, f.size = %d\n&quot;,f.capacity(),f.size());</span><br></pre></td></tr></table></figure>

<p>第25行：capacity( )成员函数返回向量对象的容量，即向量对象能够容纳的元素个数；size( )成员函数返回向量对象当前实际包含的元素个数。执行结果的第3行显示，当前容量（capacity）及尺寸（size）均为2。这提示，如果试图往向量中增加一个元素，将存在向量内存空间不足的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fish f2;              //2号鱼</span><br></pre></td></tr></table></figure>

<p>第26行：定义并构建了2号鱼对象。其构造函数的输出见执行结果的第4行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;-------------f.push_back(f2)----------&quot; &lt;&lt; endl;</span><br><span class="line">f.push_back(f2);</span><br></pre></td></tr></table></figure>

<p>第27 ~ 28行：push_back(f2)将2号鱼加入向量f的末尾。C++并不能把2号鱼从外部变量f2“移入“向量，它只能将外部对象f2””至向量内。但当前向量f的容量和尺寸都为2，没有剩余空间，为了将f2加入向量，push_back( )函数做了如下工作。</p>
<p>① 在堆中申请并分配新的足够的存储空间；</p>
<p>② 将2号鱼，即f2对象拷贝构造至新空间内的2号位置（从下标0开始数）。相关拷贝构造函数的输出见执行结果的第6行。请注意，向量内的2号鱼的序号已变为2[Copy]。</p>
<p>③ 将向量内原有的0，1号鱼由旧空间拷贝至新空间的对应位置。相关拷贝构造函数的输出见执行结果的第7 ~ 8行。请注意，向量内的0，1号鱼的序号变为0[Copy]及1[Copy]。</p>
<p>④ 释放旧空间，旧空间内的原0，1号鱼的析构函数被执行。相关析构函数的输出见执行结果的第9 ~ 10行。</p>
<p>可以相象，push_back( )函数的这种”“行为要求元素类型具有公开的拷贝构造函数（可以是默认的），否则，编译器会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;f.capacity = %d, f.size = %d\n&quot;,f.capacity(),f.size());</span><br></pre></td></tr></table></figure>

<p>第29行：再次打印向量f的容量及尺寸。执行结果的第11行可见，容量为4，尺寸为3。这提示，向量f”认为“使用者有可能会再次往向量内增加元素，push_back( )函数在分配新空间时作了适当的预留。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;vector f is &quot; &lt;&lt; (f.empty()?&quot;empty.\n&quot;:&quot;not empty.\n&quot;);</span><br></pre></td></tr></table></figure>

<p>第30行：当向量内容纳的元素个数为0时，empty( )成员函数返回真，否则为假。执行结果的第12行显示，向量f非空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;-------------f.pop_back()-------------&quot; &lt;&lt; endl;</span><br><span class="line">f.pop_back();</span><br></pre></td></tr></table></figure>

<p>第31 ~ 32行：pop_back( )成员函数将向量的最后一个元素弹出。执行结果的第14行可见，向量内的2号鱼被析构，其序号为2[Copy]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;-------------f.resize(1)--------------&quot; &lt;&lt; endl;</span><br><span class="line">f.resize(1);</span><br></pre></td></tr></table></figure>

<p>第33 ~ 34行：resize( n )成员函数将向量内的元素个数修改为n。如果n大于向量内的当前元素个数，向量将自动新增元素来实现目标；如果n小于向量内的当前元素个数，则末尾方向的多余元素会被移除。第34行执行前，向量f内有2个元素，resize(1)导致1号鱼被移除，相关析构函数输出见执行结果第16行，其序号为1[Copy]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;-------------f.clear()----------------&quot; &lt;&lt; endl;</span><br><span class="line">f.clear();</span><br></pre></td></tr></table></figure>

<p>第35 ~ 36行：clear( )成员函数清空向量内的全部元素。执行结果第18行显示，向量内的最后一个元素，序号为0[Copy]的0号鱼被析构。</p>
<p>在执行结果的最后一行，我们还看到了局部变量f2的析构输出。</p>
<blockquote>
<p><strong>要点🎯</strong> 当往向量内加入元素时，向量会”酌情“申请新空间，并将旧空间的原有元素及拟加入元素以拷贝构造的形式到新空间内。同时，旧空间的原有元素会被释放。如果期望降低这种因内存不足而导致的“搬家开销”，可以通过reserve( n )函数预分配向量的元素存储空间。</p>
</blockquote>
<p>reserve(n)成员函数会导致向量预分配n个元素的存储空间。请注意，该函数的执行只会导致向量的容量（capacity）发生变化，其实际存储的元素个数（size）不变。</p>
<p>向量等容器还提供emplace_back( )函数<strong>【C++ 11】</strong>，它们的功能与push_back( )类似，但实现机制略有差别。我们结合下述程序进行解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//Project - EmplaceFish</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Fish&#123;</span><br><span class="line">    string sName;</span><br><span class="line">public:</span><br><span class="line">    Fish(const char* name)&#123;</span><br><span class="line">        sName = name;</span><br><span class="line">        cout &lt;&lt; &quot;Fish constructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fish(const Fish&amp; r)&#123;</span><br><span class="line">        sName = r.sName;</span><br><span class="line">        cout &lt;&lt; &quot;Fish copy constructor: &quot; &lt;&lt; sName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;Fish&gt; v;</span><br><span class="line">    v.reserve(10);  //提前分配10个元素的空间</span><br><span class="line">    v.push_back(Fish(&quot;Tom&quot;));</span><br><span class="line">    v.push_back(&quot;Dora&quot;);</span><br><span class="line">    v.emplace_back(&quot;Charlie&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Fish constructor: Tom</span><br><span class="line">Fish copy constructor: Tom</span><br><span class="line">Fish constructor: Dora</span><br><span class="line">Fish copy constructor: Dora</span><br><span class="line">Fish constructor: Charlie</span><br></pre></td></tr></table></figure>

<p>第22行：执行reserve( )函数提前为向量分配10个元素的空间，以避免通过push_back( )、emplace_back( )函数添加新元素时重新分配内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(Fish(&quot;Tom&quot;));</span><br></pre></td></tr></table></figure>

<p>第23行：程序先执行Fish的构造函数，构造一个临时对象，其输出见执行结果的第1行。push_back( )函数则把临时对象Tom鱼通过拷贝构造函数到向量内部，相关拷贝构造函数的输出见执行结果的第2行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(&quot;Dora&quot;);</span><br></pre></td></tr></table></figure>

<p>第24行：push_back( )函数的参数为一个C风格的字符数组，其类型为const char<em>。显然，向量v预期存储Fish对象，而不是const char</em>类型的对象，但这行代码会通过编译并正确执行：</p>
<p>① 编译器“聪明”地执行Fish的构造函数，以”Dora”为参数，构建了一个用完即弃的临时对象。相关构造输出对应执行结果的第3行。</p>
<p>② push_back( )函数将临时Fish对象拷贝到向量内。相关拷贝构造输出对应执行结果的第4行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.emplace_back(&quot;Charlie&quot;);</span><br></pre></td></tr></table></figure>

<p>第25行：emplace_back( )函数与push_back( )函数有如下区别。</p>
<p>① emplace_back( )函数的预期参数并不是Fish对象（结合本例），而是Fish类型的构造参数。其参数的个数及类型取决于Fish的构造函数定义。</p>
<p>② emplace_back( )向向量增加元素的方法并不是先构造、后，而是直接在分配好的元素空间上执行Fish类型的构造函数，以”Charlie”为参数（结合本例）。相关构造函数输出对应执行结果第5行。</p>
<p>理论上，如果待添加的元素不是一个已经存在的Fish对象，emplace_back( )函数的执行效率比push_back( )高。</p>
<p>如果需要在向量的特定位置插入或者删除元素，则需要使用到<strong>迭代器（iterator）</strong>，请见本章后续部分。</p>
<h3 id="19-3-模板数组"><a href="#19-3-模板数组" class="headerlink" title="19.3 模板数组"></a>19.3 模板数组</h3><p>相较于原生的数组类型，向量可以很好地适应元素数量的不确定性：以一定的执行效率损失为代价。<strong>【C++ 11】</strong>提供的array模板类可以提供固定尺寸的数组容器，相较于向量，它执行效率更高，相较于原生数组，它更安全、更便利。本书中，我们称由array模板类提供的数组容器为<strong>模板数组</strong>，以区别于原生数组。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//Project - StringArray</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    array&lt;string,3&gt; a1 &#123;&quot;Tom&quot;,&quot;Dora&quot;,&quot;Eddie&quot;&#125;;</span><br><span class="line">    auto a2 = a1;</span><br><span class="line">    a1[1] = &quot;Charlie&quot;;   //a1.at(1) = &quot;Charlie&quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;a1: &quot;;</span><br><span class="line">    for (auto x:a1)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot;, &quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;\na2: &quot;;</span><br><span class="line">    for (auto x:a2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; &quot;, &quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;\na1 == a2: &quot; &lt;&lt; (a1==a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;   &quot;a1 != a2: &quot; &lt;&lt; (a1!=a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;   &quot;a1 &gt;  a2: &quot; &lt;&lt; (a1&gt; a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt;   &quot;a1 &lt;  a2: &quot; &lt;&lt; (a1&lt; a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a1: Tom, Charlie, Eddie,</span><br><span class="line">a2: Tom, Dora, Eddie,</span><br><span class="line">a1 == a2: False</span><br><span class="line">a1 != a2: True</span><br><span class="line">a1 &gt;  a2: False</span><br><span class="line">a1 &lt;  a2: True</span><br></pre></td></tr></table></figure>

<p>第3 ~ 4行：array类型由array头文件引入，且处于std名字空间之下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;string,3&gt; a1 &#123;&quot;Tom&quot;,&quot;Dora&quot;,&quot;Eddie&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>第7行：array&lt;ElemType, size&gt;有两个模板参数，其中，ElemType表示元素类型，size预期为一个size_t类型的整数，它指定了模板数组的固定尺寸。模板数组一旦建立，其尺寸（元素个数）恒定。本例中，a1数组的元素类型为string，尺寸为3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto a2 = a1;</span><br></pre></td></tr></table></figure>

<p>第8行：模板数组对象可以整体赋值给相同类型（元素类型和尺寸均需相同）的另一个数组对象。本例中，a2通过类型推断获得与a1相同的类型，模板数组对象赋值时，右值对象中的元素通过拷贝构造或者operator&#x3D;操作符函数给左值对象中的对应元素。此操作同样适用于向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1[1] = &quot;Charlie&quot;;   //a1.at(1) = &quot;Charlie&quot;;</span><br></pre></td></tr></table></figure>

<p>第9行：通过下标可以访问模板数组元素。同原生数组一样，当通过下标访问数组元素时，不会进行越界检查。通过使用at( idx )函数，也可以访问数组元素，但会进行越界检查，这显然会带来一点点执行效率的损失。当at( idx )函数收到越界的下标时，会抛出一个异常（exception）▲。异常处理机制有机会通过捕获这一异常来修复错误。at(idx)函数也适用于向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   cout &lt;&lt; &quot;a1: &quot;;</span><br><span class="line">for (auto x:a1)</span><br><span class="line">       cout &lt;&lt; x &lt;&lt; &quot;, &quot;;</span><br></pre></td></tr></table></figure>

<p>第11 ~ 13行：通过基于范围的for循环来遍历并打印a1数组的全部元素，这种语法同样适用于向量。需要注意的是，在本例的语法下，循环变量x只是容器元素的品。如果期望通过这种循环修改容器元素，应通过下述语法获取容器元素的引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; x:a1):</span><br><span class="line">	... //对x的修改，即是对容器元素的修改</span><br></pre></td></tr></table></figure>

<p>此外，当容器元素对象较大时，即便没有通过循环修改容器元素的需要，也应尽量使用容器元素的引用。这样做可以避免在循环过程中的多次大对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;\na1 == a2: &quot; &lt;&lt; (a1==a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;   &quot;a1 != a2: &quot; &lt;&lt; (a1!=a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;   &quot;a1 &gt;  a2: &quot; &lt;&lt; (a1&gt; a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;   &quot;a1 &lt;  a2: &quot; &lt;&lt; (a1&lt; a2?&quot;True&quot;:&quot;False&quot;) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第19 ~ 22行：通过&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;等重载操作符函数，可对模板数组对象进行整体比较，这是原生数组无法完成的任务。当且仅当两个模板数组内的元素完全相同时，两个模板数组相等。当两个模板数组比较大小时，则会从第0个元素开始比较，如果第0个元素相等，则比较第1个 … 请读者结合程序执行结果进行理解。上述逻辑比较运算同样适用于向量。</p>
<h3 id="19-4-数组与链表"><a href="#19-4-数组与链表" class="headerlink" title="19.4 数组与链表"></a>19.4 数组与链表</h3><p>array、vector以及string，都可视为数组类型，其元素均存储在一片连续的内存空间之内。这一特性使得通过下标存取容器元素（即随机存取）成为可能：元素地址可以通过首元素地址加上元素大小与下标的乘积得到。array、vector、string类型都有一个名为data( )的成员函数，通过该成员函数，可以获取其数据存储空间的指针。</p>
<p>如图19- 所示，数组的这种内存结构也使得在特定位置插入或者删除元素变得困难。比如，如果我们期望在下标k的位置插入一个新元素，就需要先从后往前把从下标k开始的所有元素依次后移，然后才能把新元素存入下标k。当删除指定下标元素时，情况与此类似，需要把后续无素逐一前移，以填补元素删除后的空缺。</p>
<p><img src="http://codelearn.club/images/image-20200509105608179.png" alt="image-20200509105608179"></p>
<p>图19- 数组类容器的结构</p>
<p>与数组不同，链表（包括双向链表list以及单向链表forward_list<strong>【C++ 11】</strong>）中的元素是分散存储的，元素之间通过节点指针来串接。图19- 展示了一个典型的双向链表的结构：</p>
<ul>
<li>链表由多个节点串接而成，每个节点包括：前向（prev）指针、数据及后向（next）指针三个部分。其中，数据即为链表容器的元素，每个节点存储一个元素。</li>
<li>前向指针指向本节点的前一个节点，容器的第0个节点的前向指针为空。</li>
<li>后向指针指向节点节的后一个节点，容器的最后一个节点的后向指针为空。</li>
<li>头指针指向链表第0个节点；尾指针指向链表的最后一个节点。</li>
</ul>
<p><img src="http://codelearn.club/images/image-20200510102043641.png" alt="image-20200510102043641"></p>
<p>图19- 双向链表的结构</p>
<p>链表中每个节点的存储在内存中是<strong>散布非连续</strong>的，这使得程序无法通过下标计算得到节点&#x2F;元素的存储位置。要访问链表元素，必须从头指针或者尾指针出发，后向或前向顺序访问。但链表的这种结构也有好处，那就是可以快速地在指向位置删除或者插入元素。如图19- 所示，当我们在data1和data2元素之间插入新元素new时，并不需要象数组那样把data2及后续元素依次后移，只需要新建一个包含元素new的节点，然后修改data1、data2以及new节点的部分指针的指向即可。</p>
<p><img src="http://codelearn.club/images/image-20200510102113471.png" alt="image-20200510102113471"></p>
<p>图19- 双向链表中的元素插入</p>
<p>与双向链表（list）不同，单向链表（forward_list）的节点中没有前向指针，这使得单向链表的元素访问，只能从头指针出发，从前向往单向进行。</p>
<p>下述C++程序是一个非常简单的双向链表的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - StringList</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    list&lt;string&gt; girls &#123;&quot;Dora&quot;, &quot;Emily&quot;, &quot;Cinderella&quot;&#125;;</span><br><span class="line">    girls.pop_back();</span><br><span class="line">    girls.push_back(&quot;Angela&quot;);</span><br><span class="line">    girls.emplace_front(&quot;Iris&quot;);</span><br><span class="line">    girls.sort();</span><br><span class="line"></span><br><span class="line">    for (auto&amp; x:girls)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Angela</span><br><span class="line">Dora</span><br><span class="line">Emily</span><br><span class="line">Iris</span><br></pre></td></tr></table></figure>

<p>第3 ~ 4行：list类型由list头文件引入，且处于std名字空间之下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; girls &#123;&quot;Dora&quot;, &quot;Emily&quot;, &quot;Cinderella&quot;&#125;;</span><br></pre></td></tr></table></figure>

<p>第7行：定义了一个元素类型为string的双向链表对象girls，并使用初始化列表进行了初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">girls.pop_back();</span><br></pre></td></tr></table></figure>

<p>第8行：弹出&#x2F;移除链表中的最后一个元素。具体到本例，”Cinderella”被移除。与此对应的成员函数还有pop_front( )，它用于弹出&#x2F;移出链表的第一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">girls.push_back(&quot;Angela&quot;);</span><br></pre></td></tr></table></figure>

<p>第9行：在链表的尾部添加一个元素。与此对应的成员函数还有push_front( )，它用于在链表头部添加一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">girls.emplace_front(&quot;Iris&quot;);</span><br></pre></td></tr></table></figure>

<p>第10行：在链表的起始处添加一个元素。如本章稍早所述，emplace_front(…)、emplace_back(…)会避免使用拷贝构造的方式来元素，而是直接通过构造函数来初始化元素。此处的…指元素的构造函数参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">girls.sort();</span><br></pre></td></tr></table></figure>

<p>第11行：对链表内的元素进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (auto&amp; x:girls)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>第13 ~ 14行：使用基于范围的for循环遍历打印链表元素。注意，此处通过获取链表元素的引用来避免循环过程中的链表元素的不必要。</p>
<p>执行结果可见，经过排序后的链表按照非递减有序。</p>
<p>向量（vector）内的全部元素是存储在一块连续内存之内的，这使得元素的随机访问速度很快。双端队列（deque）的元素则存储在多块连续内存上，其每一个内存块通常存储相同数量的元素。这使得双端队列也可以支持快速的元素随机访问（比向量稍慢）。同时，当向双端队列队首或队尾添加元素时，双端队列可以通过申请新的内存块来实现快速的队首&#x2F;队尾元素添加。</p>
<blockquote>
<p><strong>扩展阅读📕</strong> 上述链表、队列的具体工作原理通常属于《数据结构》课程的内容；对数组、链表等插入、删除中间元素，添加、移除头部&#x2F;尾部元素的计算代价，称之为计算复杂性，通常属于《算法分析》研究的内容。</p>
</blockquote>
<h3 id="19-5-迭代器"><a href="#19-5-迭代器" class="headerlink" title="19.5 迭代器"></a>19.5 迭代器</h3><p>如前所述，不同容量，比如向量和链表，其内部数据结构差异很大。不同的内部数据结构导致的不同的容器特性：向量、模板数组、双端队列可以通过下标随机访问元素，而链表、单向链表则只能顺序访问。这种容器间的接口差异，为代码复用（code reuse）带来困难。而<strong>迭代器（iterator）</strong>的设计目的之一，就是为了消除不同容器间的访问接口差异，使得<strong>泛型程序设计（generic programming）</strong>成为可能。广义地，迭代器属于<strong>设计模式（design patterns）</strong>的范畴。</p>
<h4 id="19-5-1-获取迭代器"><a href="#19-5-1-获取迭代器" class="headerlink" title="19.5.1 获取迭代器"></a>19.5.1 获取迭代器</h4><p>大多数容器，都有begin( )和end( )两个成员函数，其中，begin( )函数返回指向首元素的迭代器。与读者的预期不同，end( )函数所返回的迭代器并非指向末尾元素（容器的最后一个元素），而是指向末尾元素的后面一个”元素”，它被称为<strong>尾后迭代器（off-the-end iterator）</strong>。当然，末尾元素的后面不会再有其它元素，end( )函数所返回的迭代器用于表示：所有元素都已遍历完成，程序已到达容器尾部的“出口”。我们结合下述程序及图19- 来解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Project - StringIterator</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s = &quot;Run, Forrest&quot;;</span><br><span class="line"></span><br><span class="line">    auto it = s.begin();</span><br><span class="line">    while (it!=s.end())&#123;</span><br><span class="line">        *it = toupper(*it);</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN, FORREST</span><br></pre></td></tr></table></figure>

<p><img src="http://codelearn.club/images/image-20200518224244863.png" alt="image-20200518224244863"></p>
<p>图19- 首元素及尾后迭代器</p>
<p>可以将string类型的对象视为一种类似于向量的容器，其元素类型为字符。图19- 展示了s对象内部的元素排列状况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto it = s.begin();</span><br></pre></td></tr></table></figure>

<p>第8行：通过begin( )成员函数获取s的首元素迭代器并赋值给变量it。如图19- 所示，此时的it应指向s的首元素’R’。根据类型推断，本例中对象it的类型为string::iterator。</p>
<blockquote>
<p><strong>要点🎯</strong> 迭代器对象可以视为指向容器内元素的智能指针，借助于其重载的操作符函数，可以使用迭代器遍历容器，并插入、删除元素。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (it!=s.end())&#123;</span><br><span class="line">    *it = toupper(*it);</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9 ~ 12行：借助于循环及迭代器的移动，将s字符串的所有字符改为大写。</p>
<p>① s.end( )返回尾后迭代器，它指向尾元素的后面一个“元素”，如图19- 所示。</p>
<p>② !&#x3D;是迭代器对象的一个重载操作符函数，两个迭代器如果不相等，就意味着它们指向不同的容器元素。本例中，it迭代器会在循环过程中逐渐后移，it与尾后迭代器相等即意味着容器元素已遍历完毕。</p>
<p>③ 间接操作符<em>也被迭代器对象重载了，</em>it返回it所指向的元素的引用。</p>
<p>④ toupper( )函数将字符转换成大写形式，该函数位于std名字空间之下。</p>
<p>⑤ it++对应it.operator++(int)，其执行使得it迭代器后移一个元素。</p>
<p>从执行结果可见，上述循环成功地达成了目标，s内的小写字母全部变成了大写字母。</p>
<blockquote>
<p><strong>建议🔔</strong> 上述while循环条件中的it!&#x3D;s.end( )也可以写成it &lt; s.end( )。对于两个迭代器a和b而言，如果a &lt; b，说明a所指向的元素在b所指向的元素的前面。但是，作者更建议使用it !&#x3D; s.end( )，这是因为部分容器的迭代器不支持&lt;操作符，使用!&#x3D;使得上述程序兼容性更佳。</p>
</blockquote>
<p>如前所述，迭代器的用途之一是消除不同容器的访问接口的差异。借助于迭代器，遍历链表的方法与遍历向量或者字符串基本相同。见下述示例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Project - ListIterator</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    list&lt;double&gt; a &#123;1,10,100,1000&#125;;</span><br><span class="line">    auto it = a.rbegin();</span><br><span class="line">    while (it!=a.rend())&#123;</span><br><span class="line">        *it = (*it)*1.2;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot;,&quot;;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1200,120,12,1.2,</span><br></pre></td></tr></table></figure>

<p><img src="http://codelearn.club/images/image-20200519095350783.png" alt="image-20200519095350783"></p>
<p>图19- 尾元素及首前迭代器</p>
<p>在上述程序中，我们使用了<strong>反向迭代器（reverse iterator）</strong>，链表容器的遍历顺序为由后往前，即尾元素1000最先被迭代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto it = a.rbegin();</span><br></pre></td></tr></table></figure>

<p>第8行：a.rbegin( )返回的迭代器是个反向迭代器，本例中， 它指向尾元素1000。其中，迭代器it的类型被推断为list<double>::reverse_iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (it!=a.rend())&#123;</span><br><span class="line">    *it = (*it)*1.2;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; &quot;,&quot;;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9 ~ 13行：借助于循环及迭代器的移动，将a数组内的元素全部乘以1.2，并输出其值。</p>
<p>① s.rend( )返回反向首前迭代器，它指向首元素的前面一个“元素”，如图19- 所示。</p>
<p>② !&#x3D;是迭代器对象的一个重载操作符函数，两个迭代器如果不相等，就意味着它们指向不同的容器元素。本例中，it迭代器会在循环过程中逐渐前移，it与首前迭代器相等即意味着容器元素已遍历完毕。</p>
<p>③ 间接操作符<em>也被迭代器对象重载了，</em>it返回it所指向的元素的引用。</p>
<p>④ it++对应it.operator++(int)，由于it是反向迭代器，所以it++事实上导致it移至前一个元素。相应地，it–则意味着，it移至后一个元素。请读者注意图19- 中it++及it–所对应的箭头方向。</p>
<p>从执行结果可见，上述循环成功地达成了目标，a内的全部元素向后向前被遍历并修改。</p>
<p>表19- 标准的迭代器获取函数（对象c为一个容器）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>c.begin( ), c.end( )</td>
<td>正向迭代器。其中，begin( )返回的迭代器指向首元素，end( )返回<strong>尾后迭代器</strong>，它指向尾元素的后面一个“元素”。如果c是常量型容器对象，begin( )及end( )返回的迭代器也是常量型。</td>
<td>&lt;容器类型&gt;::iterator</td>
</tr>
<tr>
<td>c.rbegin( ),c.rend( )</td>
<td>反向迭代器。其中，rbegin( )返回的迭代器指向尾元素，rend( )返回<strong>首前迭代器</strong>，它指向首元素的前面一个“元素”。如果c是常量型容器对象，rbegin( )及rend( )返回的迭代器也是常量型。</td>
<td>&lt;容器类型&gt;::reverse_iterator</td>
</tr>
<tr>
<td>c.cbegin( ), c.cend( )</td>
<td>常量型正向迭代器，对常量型迭代器使用间接操作符将得到元素的常量型引用。对于只读，不修改的容器遍历，应尽可能使用常量型迭代器。</td>
<td>&lt;容器类型&gt;::const_iterator</td>
</tr>
<tr>
<td>c.crbegin( ), c.rcend( )</td>
<td>常量型反向迭代器。</td>
<td>&lt;容器类型&gt;::const_reverse_iterator</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意📢</strong> 当容器c为空时，c.begin( )与c.end( )相等，它们都返回尾后迭代器。同理，当容器c为空时，c.rbegin( )也等于c.rend( )。</p>
</blockquote>
<h4 id="19-5-2-迭代器算术"><a href="#19-5-2-迭代器算术" class="headerlink" title="19.5.2 迭代器算术"></a>19.5.2 迭代器算术</h4><p>迭代器本质是对象，但使用方法类似于指针。表19- 总结了标准的迭代器操作符。</p>
<p>表19- 标准迭代器操作符（it指迭代器）</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>*it</td>
<td>间接操作符，*it返回迭代器it所指向的元素的引用，当迭代器是常量型时，返回的引用也是常量型。</td>
</tr>
<tr>
<td>it-&gt;member</td>
<td>指向操作符，返回迭代器it所指向的元素的成员的引用，其等价于(*it).member。</td>
</tr>
<tr>
<td>it++</td>
<td>当it是正向迭代器时，移至后一个元素；当it是反向迭代器时，移至前一个元素。</td>
</tr>
<tr>
<td>it–</td>
<td>当it是正向迭代器时，移至前一个元素；当it是反向迭代器时，移到后一个元素。</td>
</tr>
<tr>
<td>it1 &#x3D;&#x3D; it2</td>
<td>迭代器it1与it2相等，</td>
</tr>
<tr>
<td>it1 !&#x3D; it2</td>
<td>判断迭代器it1和it2是否不相等。</td>
</tr>
<tr>
<td>it + n</td>
<td>迭代器it与整数n相加将返回一个新的迭代器，结果迭代器预期指向it所指向的元素＂后＂面的第n个元素。</td>
</tr>
<tr>
<td>it - n</td>
<td>迭代器it与整数n相加将返回一个新的迭代器，结果迭代器预期指向it所指向的元素＂前＂面的第n个元素。</td>
</tr>
<tr>
<td>it +&#x3D; n</td>
<td>将迭代器it”后“移n个位置，指向原指向元素的”后“面第n个元素。</td>
</tr>
<tr>
<td>it -&#x3D; n</td>
<td>将迭代器it”前“移n个位置，指向原指向元素的”前“面第n个元素。</td>
</tr>
<tr>
<td>it1 - it2</td>
<td>将两个迭代器相减将得到一个整数n，这个整数n等于两个迭代器所指向的元素的”下标“差值。如果将it2加上整数n，预期应得到it1。</td>
</tr>
<tr>
<td>&gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</td>
<td>对迭代器进行逻辑比较。对于迭代器it1和it2，如果it1所指向的元素在it2所指向元素的”前“面，it1小于it2。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意📢</strong> 表19- 所述的”前“、”后“与迭代器的方向有关， 当迭代器为反向迭代器时，所谓的”后“，事实上是靠近首元素的方向。</p>
</blockquote>
<blockquote>
<p><strong>警告🚩</strong> 使用迭代器时，程序员需要小心避免”不合逻辑“的访问行为。比如：尾后迭代器事实上不指向任何元素，对其使用间接操作符*会导致程序异常；同样地，对于个迭代器加上整数n，程序员也应小心确保其结果迭代器要么指向一个容器元素，要么是“尾后”或“首前”迭代器。</p>
</blockquote>
<p>把同一个容器的两个迭代器配合使用，可以表示容器元素的一个连续子集。在数学上，迭代器it1和it2所示表示的元素范围可以表示成 <strong>[ it1, it2 )<strong>，这是一个左闭右开的区间，它表示结果子集中的元素从it1所指向的元素</strong>（包含，左闭）</strong>开始，到it2所指向的元素结束，且<strong>不包含（右开）</strong>it2所指向的元素。对于图19- 所示的容器c而言：</p>
<ul>
<li><strong>[ it1, it2 )</strong> 表示从A到L的全部元素，请注意it2是尾后迭代器，它指向L的后面一个”元素”。</li>
<li><strong>[ it3, it4 )</strong> 表示从D到H的元素，即D、E、F、G、H共5个元素。请注意，it4所指向的元素I并未包含。</li>
<li><strong>[ it5, it6 )</strong> 则表示从L到A的全部元素，请注意，it5和it6都是反向迭代器，且it6指向“首前元素”。</li>
</ul>
<p><img src="http://codelearn.club/images/image-20200521115854778.png" alt="image-20200521115854778"></p>
<p>图19- 双迭代器所表示的元素范围</p>
<p>当使用两个迭代器，如it1和it2表示元素范围时，必须保证it1在迭代方向上较it2靠前，即it2可以通过递增it1得到，否则，结果子集合为空。对于图19- ，**[ it2, it1 )**的结果的一个空集合。此外，两个相等的迭代器所表示的元素子集也为空。</p>
<blockquote>
<p><strong>注意📢</strong> <strong>[ it1, it2 )</strong> 只是一种数学表达，C++并不支持直接在代码中使用这种格式来获取或表达容器的元素子集。结合两个迭代器来表达容器的元素子集的方法，请见19.6节。</p>
</blockquote>
<h4 id="19-5-3-折半查找示例"><a href="#19-5-3-折半查找示例" class="headerlink" title="19.5.3 折半查找示例"></a>19.5.3 折半查找示例</h4><p>我们使用迭代器重写了第5章中讨论过的折半查找算法，来帮助读者理解迭代器的算术运算。其核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - BinarySearch</span><br><span class="line">...</span><br><span class="line">template &lt;typename T, typename V&gt;</span><br><span class="line">T binarySearch(T begin, T end, const V v)&#123;</span><br><span class="line">    auto endOriginal = end;</span><br><span class="line">    while (begin != end) &#123;</span><br><span class="line">        auto mid = begin + (end-begin)/2;</span><br><span class="line">        if (*mid==v)</span><br><span class="line">            return mid;</span><br><span class="line">        else if (v &lt; *mid)</span><br><span class="line">            end = mid;</span><br><span class="line">        else</span><br><span class="line">            begin = mid+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return endOriginal;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>binarySearch( )是一个模板函数，其接口描述如下。</p>
<ul>
<li>输入： 迭代器 <strong>[ begin, end )</strong> 代表了搜索的元素范围，如上一小节所述，end所指向的元素不在搜索范围内； 搜索值v。注意，无论是迭代器类型还是搜索值类型都为模板参数，这意味着该函数具备泛型编程的特征，它不对输入的容器&#x2F;迭代器类型、元素类型作出限定。理论上，该折半查找函数适用于向量、模板数组、双端队列等不同容器。</li>
<li>输出：如果在指定的元素范围内找到了搜索值，返回指向该元素的迭代器；如未找到，返回end迭代器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto endOriginal = end;</span><br></pre></td></tr></table></figure>

<p>第5行：将end迭代器存入endOriginal备用，未找到搜索值时，返回endOriginal，即原始的end迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (begin != end) &#123;</span><br></pre></td></tr></table></figure>

<p>第6行：在整个折半查找的过程中，**[begin, end)** 代表了当前搜索的元素范围。只要begin不等于end，即意味着在该范围内至少存在一个元素，搜索应继续进行，否则应结束循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto mid = begin + (end-begin)/2;</span><br></pre></td></tr></table></figure>

<p>第7行：通过迭代器算术求指向当前搜索范围 <strong>[begin, end)</strong> 的中位元素的迭代器。其中，end - begin返回待搜索的元素个数，将该值除以2，再加上begin，即得指向中位元素的迭代器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (*mid==v)</span><br><span class="line">    return mid;</span><br></pre></td></tr></table></figure>

<p>第8 ~ 9行：将中位元素与搜索值v进行比较，如相同，说明找到搜索值，直接返回中位元素的迭代器mid。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if (v &lt; *mid)</span><br><span class="line">    end = mid;</span><br></pre></td></tr></table></figure>

<p>第10 ~ 11行：否则，如果搜索值小于中位元素，这说明搜索值位于中位元素的左边，将中位元素迭代器赋值给end。赋值之后的**[begin, end)<strong>相较于之前的</strong>[begin,end)**，其范围大概缩小了一半，且不包含之前的中位元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else</span><br><span class="line">    begin = mid+1;</span><br></pre></td></tr></table></figure>

<p>第12 ~ 13行：如果上述两种情况都不成立，说明搜索值大于中位元素，其应位于中位元素的右方，将mid + 1赋值给begin。赋值之后的**[begin, end) *<em>相较于之前的</em>*[begin, end)**，其范围大概缩小了一半。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return endOriginal;</span><br></pre></td></tr></table></figure>

<p>第15行：在前述循环过程中，如果一直没有找到搜索值，每经过一轮循环，**[begin, end)** 的范围就缩小一半，最终会导致begin与end相等，满足循环中止条件，循环结束并返回endOriginal。</p>
<p>下述代码则展示了使用binarySearch( )函数进行折半查找的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Project - BinarySearch</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a &#123;1,3,5,7,9,11&#125;;</span><br><span class="line">    auto r = binarySearch(a.cbegin(),a.cend(), 7);</span><br><span class="line">    if (r==a.cend())</span><br><span class="line">        cout &lt;&lt; &quot;Not found.&quot; &lt;&lt; endl;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found: 7</span><br></pre></td></tr></table></figure>

<p>第6行：… 表示被省略的binarySearch( )函数的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto r = binarySearch(a.cbegin(),a.cend(), 7);</span><br></pre></td></tr></table></figure>

<p>第7行：a.cbegin( )， a.cend( )返回向量a的首元素只读迭代器以及只读尾后迭代器，这说明折半查找的搜索范围包括a的全部元素。binarySearch( )模板参数T的类型被确定为vector<int>::const_iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (r==a.cend())</span><br></pre></td></tr></table></figure>

<p>第11行：如果返回迭代器等于a.cend( )，说明在向量a内未找到搜索值。</p>
<blockquote>
<p><strong>要点🎯</strong> 第5章中所描述的折半查找函数，仅适用于指定类型的数组，不具体通用性。借助于迭代器及模板参数，本节中的binarySearch( )理论上可以支持不同的容器类型及元素类型，具备泛型编程的特征。事实上，本节的binarySearch( )函数不支持对链表的折半查找，因为链表的迭代器不支持减法操作符。</p>
</blockquote>
<h4 id="19-5-4-容器元素的修改"><a href="#19-5-4-容器元素的修改" class="headerlink" title="19.5.4 容器元素的修改"></a>19.5.4 容器元素的修改</h4><p>下述程序展示了通过迭代器对容器元素进行修改的一般方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//Project - ModifyElement</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void output(T begin, T end, const string&amp; sTitle)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;----------&quot; &lt;&lt; sTitle &lt;&lt; &quot;------------\n&quot;;</span><br><span class="line">    while (begin!=end)</span><br><span class="line">        cout &lt;&lt; *begin++ &lt;&lt; &quot;,&quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    a.assign(&#123;0,1,2,3,4,5,6,7,8,9&#125;);</span><br><span class="line">    *(a.begin()+3) = 99;</span><br><span class="line">    output(a.cbegin(),a.cend(),&quot;vector&lt;int&gt; a&quot;);</span><br><span class="line"></span><br><span class="line">    list&lt;int&gt; b;</span><br><span class="line">    b.assign(a.crbegin()+2,a.crend()-3);</span><br><span class="line">    output(b.cbegin(),b.cend(), &quot;list&lt;int&gt; b&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------vector&lt;int&gt; a------------</span><br><span class="line">0,1,2,99,4,5,6,7,8,9,</span><br><span class="line">----------list&lt;int&gt; b------------</span><br><span class="line">7,6,5,4,99,</span><br></pre></td></tr></table></figure>

<p>第7 ~ 13行：定义了一个“通用”的容器元素输出函数output( )，因为模板参数及迭代器的使用，该函数理论上可以输出任意<strong>序列容器（sequential container）</strong>的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.assign(&#123;0,1,2,3,4,5,6,7,8,9&#125;);</span><br></pre></td></tr></table></figure>

<p>第17行：用初始化列表中的元素替换向量a中的全部元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(a.begin()+3) = 99;</span><br></pre></td></tr></table></figure>

<p>第18行：将向量a的第3个元素（从0开始计数）修改为99。这里使用到了迭代器算术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output(a.cbegin(),a.cend(),&quot;vector&lt;int&gt; a&quot;);</span><br></pre></td></tr></table></figure>

<p>第19行：使用output( )函数输出向量a的全部元素。由于输出过程并不期望改变容器元素的值，所以我们使用了常量型迭代器。其输出对应执行结果的第1 ~ 2行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.assign(a.crbegin()+2,a.crend()-3);</span><br></pre></td></tr></table></figure>

<p>第22行：用向量a中的部分元素替换链表b中的全部元素。源自向量a的元素集由两个迭代器来表示，形式上可表示为 **[ a.crbegin()+2, a.crend()-3 ) **。</p>
<ul>
<li>a.crbegin( ) + 2: 反向只读迭代器，指向尾元素之”后”的第2个元素，即向量a倒数第3个元素，其值为7。</li>
<li>a.crend( ) - 3: 反向只读迭代器，指向”首前元素”之“前”的第3个元素，即向量a正数第3个元素，其值为2。</li>
<li>由于两个迭代器都是反向迭代器，且按照左闭右开的规则，a.crend( )-3所指向的元素（即2）不包含在范围内，所以，**[ a.crbegin()+2, a.crend()-3 ) **所表示的元素序列为7， 6， 5， 4， 99。</li>
</ul>
<p>第22行的assign( )与第17行的assign( )参数不同，显然，这些容器通过函数名重载定义了多个名为assign( )的成员函数。请读者对照图19- 理解第22行代码所涉及的元素范围。</p>
<p><img src="http://codelearn.club/images/image-20200521215647132.png" alt="image-20200521215647132"></p>
<p>图19- 反向迭代器元素范围示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output(b.cbegin(),b.cend(), &quot;list&lt;int&gt; b&quot;);</span><br></pre></td></tr></table></figure>

<p>第23行：打印链表b的全部元素，其输出对应执行结果的第3 ~ 4行。</p>
<h4 id="19-5-5-容器元素的增加"><a href="#19-5-5-容器元素的增加" class="headerlink" title="19.5.5 容器元素的增加"></a>19.5.5 容器元素的增加</h4><p>表19- 序列容器的元素增加函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>c.push_back(e)</td>
<td>将元素e通过的方式添加到容器的尾部。</td>
</tr>
<tr>
<td>c.emplace_back(args)</td>
<td>在容器尾部添加一个元素，新元素通过参数args构造。</td>
</tr>
<tr>
<td>c.push_front(e)</td>
<td>将元素e通过的方式添加到容器的头部。前向链表不支持该函数。</td>
</tr>
<tr>
<td>c.emplace_front(args)</td>
<td>在容器头部添加一个元素，新元素通过参数args构造。前向链表不支持该函数。</td>
</tr>
<tr>
<td>c.insert(it,e)</td>
<td>在迭代器it所指向的元素前，通过的方式添加一个新元素，其值为e。函数返回指向新增元素的迭代器。</td>
</tr>
<tr>
<td>c.emplace(it,args)</td>
<td>在迭代器it所指向的元素前，新增一个元素，新元素通过参数args构造。函数返回指向新增元素的迭代器。</td>
</tr>
<tr>
<td>c.insert(it,initialize_list)</td>
<td>initialize_list是包含一系列元素值的初始化列表。该函数将这些元素值插入it所指向的元素之前。函数返回指向第1个新增元素的迭代器，如果initialize_list为空，则返回参数it。</td>
</tr>
<tr>
<td>c.insert(it,n,e)</td>
<td>在迭代器it所指向的元素前，新增n个值为e的元素。函数返回指向第1个新增元素的迭代器，如果n等于0，则返回参数it。</td>
</tr>
<tr>
<td>c.insert(it,begin,end)</td>
<td>在迭代器it所指向的元素前，插入**[begin,end)<strong>元素范围中的全部元素。函数返回指向第1个新增元素的迭代器，如果元素范围</strong>[begin,end)**为空，则返回参数it。注意：迭代器begin, end不可以来自容器c。</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>警告🚩</strong> 往vector、string、deque等容器添加元素，可能会使得相关的迭代器、引用、地址等全部失效，因为元素的添加过程可能会导致原有元素的内存地址变生变化。这也是表19- 中，c.insert(it,begin,end)中的begin,end不可以源自容器c的原因。</p>
</blockquote>
<p>下述程序主要讨论表19- 中，几个insert( )函数的使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Project - AddElements</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void output(T begin, T end, const string&amp; sTitle)&#123; ... &#125;  //代码有省略</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; a &#123;0,1,2,3,4,5&#125;;</span><br><span class="line">    a.insert(a.cbegin()+4,10);</span><br><span class="line">    a.insert(a.cbegin()+2,3,100);</span><br><span class="line">    a.insert(a.cbegin()+3,&#123;97,98,99&#125;);</span><br><span class="line">    a.emplace(a.cbegin()+5, 999);</span><br><span class="line">    output(a.cbegin(),a.cend(),&quot;vector&lt;int&gt; a&quot;);</span><br><span class="line"></span><br><span class="line">    list&lt;int&gt; b &#123;0,0,0,0,0&#125;;</span><br><span class="line">    auto it = b.cbegin();</span><br><span class="line">    it++;</span><br><span class="line">    b.insert(it, a.cbegin()+2, a.cbegin()+7);</span><br><span class="line">    output(b.cbegin(),b.cend(),&quot;list&lt;int&gt; b&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------vector&lt;int&gt; a------------</span><br><span class="line">0,1,100,97,98,999,99,100,100,2,3,10,4,5,</span><br><span class="line">----------list&lt;int&gt; b------------</span><br><span class="line">0,100,97,98,999,99,0,0,0,0,</span><br></pre></td></tr></table></figure>

<p>第7行代码有省略，该output( )函数与前节中的output( )函数完全相同，用于输出容器内容。</p>
<p><img src="http://codelearn.club/images/image-20200522140945002.png" alt="image-20200522140945002"></p>
<p>图19- AddElements示例执行过程（第一部分）</p>
<p>第11 ~ 14行：图19- 展示了相关执行过程。</p>
<ul>
<li>第11行在第4个元素（从0开始计数，即元素4）之前插入元素10。</li>
<li>第12行在第2个元素（从0开始计数，即元素2）之前插入3个值为100的元素。</li>
<li>第13行在第3个元素（从0开始计数，即如图所示的值为100的元素）之前插入三个元素，其值依次为97、98和99。</li>
<li>第14行在第5个元素（从0开始计数，即元素99）之前新增一个元素，其值为999。理论上，emplace( )函数会通过从参数构造而不是来初始化新元素，但对于原生数据类型int来讲，两者并无区别。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output(a.cbegin(),a.cend(),&quot;vector&lt;int&gt; a&quot;);</span><br></pre></td></tr></table></figure>

<p>第15行：输出向量a的全部元素，从执行结果的第2行可见，a内的元素内容与图19- 完全一致。</p>
<p><img src="http://codelearn.club/images/image-20200522142956372.png" alt="image-20200522142956372"></p>
<p>图19- AddElements示例执行过程（第二部分）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto it = b.cbegin();</span><br><span class="line">it++;</span><br><span class="line">b.insert(it, a.cbegin()+2, a.cbegin()+7);</span><br></pre></td></tr></table></figure>

<p>第18 ~ 20行：图19- 展示了相关执行过程。</p>
<ul>
<li>第18行先取得容器b的首元素只读迭代器it， 经过++操作符，it指向第1个元素（从0开始计数），如图19- 所示。</li>
<li>第20行则把两个迭代器所表示的范围内的元素，对应图19- 中底色为灰的单元格，并插入到it迭代器所指向的元素之前。如前所述，迭代器**[it1, it2)**所指的元素范围是不包括it2所指向的元素的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output(b.cbegin(),b.cend(),&quot;list&lt;int&gt; b&quot;);</span><br></pre></td></tr></table></figure>

<p>第21行：输出容器b的全部内容，从执行结果的第4行可见，相关输出与图19- 的描述相符。</p>
<blockquote>
<p><strong>要点🎯</strong> 可以看出，迭代器的使用部分消除了不同类型容器之间的鸿沟。在上述示例中，通过迭代器，我们很容易地把向量中的元素批量到链表内。反之亦然。</p>
</blockquote>
<h4 id="19-5-6-容器元素的删除"><a href="#19-5-6-容器元素的删除" class="headerlink" title="19.5.6 容器元素的删除"></a>19.5.6 容器元素的删除</h4><p>表19- 序列容器的元素移除函数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>c.pop_back( )</td>
<td>删除容器c的最后一个元素。如果c为空，函数行为不确定。前向链表不支持该函数。</td>
</tr>
<tr>
<td>c.pop_front( )</td>
<td>删除容器c的第一个元素。如果c为空，函数行为不确定。向量及字符串不支持该函数。</td>
</tr>
<tr>
<td>c.erase(it)</td>
<td>删除迭代器it所指向的元素。返回一个迭代器，指向被删除元素的后一个元素。如果被删除元素是最后一个元素，则返回尾后迭代器。如果参数it是尾后迭代器，函数行为不确定。</td>
</tr>
<tr>
<td>c.erase(begin, end)</td>
<td>从容器中删除由迭代器**[begin,end)**所表示的全部元素。返回一个迭代器，指向最后一个被删除元素的后一个元素。如果参数end是尾后迭代器，函数返回尾后迭代器。</td>
</tr>
<tr>
<td>c.clear( )</td>
<td>清空容器，即删除容器内的全部元素。</td>
</tr>
</tbody></table>
<p><strong>警告🚩</strong> 从开端队列的中间位置（开始和结尾除外）删除元素将使得该容器的全部迭代器、元素引用及指针失效。当从向量或者字符串容器删除元素时，删除点之后的迭代器、元素引用及指针将会失效，因为在删除元素的过程中，删除点之后的元素位置会发生变化，而删除点之前的元素则不受影响。</p>
<p>下述程序中的evenRemover( )函数，通过迭代器，来移除不同容器中的偶数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Project - EvenRemover</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void output(T begin, T end, const string&amp; sTitle)&#123; ... &#125;  //代码有省略</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void evenRemover(T&amp; c)&#123;</span><br><span class="line">    auto it = c.begin();</span><br><span class="line">    while (it!=c.end())&#123;       //检查it是否等于尾后迭代器</span><br><span class="line">        if (*it % 2 == 0)</span><br><span class="line">            it = c.erase(it);  //发现偶数，删除并移至下一个元素</span><br><span class="line">        else</span><br><span class="line">            ++it;              //不是偶然，移至下一个元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    list&lt;int&gt; a &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">    evenRemover(a);</span><br><span class="line">    output(a.cbegin(),a.cend(),&quot;list&lt;int&gt; a&quot;);</span><br><span class="line"></span><br><span class="line">    deque&lt;int&gt; b &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">    evenRemover(b);</span><br><span class="line">    output(b.cbegin(),b.cend(),&quot;deque&lt;int&gt; b&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">----------list&lt;int&gt; a------------</span><br><span class="line">1,3,5,7,9,</span><br><span class="line">----------deque&lt;int&gt; b------------</span><br><span class="line">1,3,5,7,9,</span><br></pre></td></tr></table></figure>

<p>第7行代码有省略，该output( )函数与前节中的output( )函数完全相同，用于输出容器内容。</p>
<p>第9 ~ 18行：evenRemover( )函数接受一个容器的引用作为参数，删除该容器内的全部偶数。由于类型T为模板参数，理论上，该函数适用于向量、链表、双端队表等各种容器类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto it = c.begin();</span><br></pre></td></tr></table></figure>

<p>第11行：获取容器c的首元素迭代器并赋值给it。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (it!=c.end())&#123;       //检查it是否等于尾后迭代器</span><br></pre></td></tr></table></figure>

<p>第12行：while循环以it !&#x3D; c.end( )作为循环条件，当it等于c.end( )&#x2F;尾后迭代器时，即意味着容器c的全部元素已遍历完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (*it % 2 == 0)</span><br><span class="line">    it = c.erase(it);  //发现偶数，删除并移至下一个元素</span><br></pre></td></tr></table></figure>

<p>第13 ~ 14行：如果迭代器it所指向的元素为偶数，通过c.erase( )函数将其删除。根据erase( )函数的定义，其将返回指向被删除元素的后一个元素的迭代器。该返回迭代器被赋值给it。理论上，从容器中删除元素可能使得该容器的全部迭代器失效，但在第12行的while循环条件中，每次都是重新调用c.end( )函数来获取“最新”的尾后迭代器，这使得程序逻辑不会受到迭代器失效的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else</span><br><span class="line">    ++it;              //不是偶然，移至下一个元素</span><br></pre></td></tr></table></figure>

<p>第15 ~ 16行：不是偶数，通过++it将迭代器移至下一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;int&gt; a &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">evenRemover(a);</span><br><span class="line">output(a.cbegin(),a.cend(),&quot;list&lt;int&gt; a&quot;);</span><br></pre></td></tr></table></figure>

<p>第21 ~ 23行：将一个整数链表传递给evenRemover( )函数，执行结果的第1 ~ 2行证实，容器内的全部偶数被删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; b &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">evenRemover(b);</span><br><span class="line">output(b.cbegin(),b.cend(),&quot;deque&lt;int&gt; b&quot;);</span><br></pre></td></tr></table></figure>

<p>第25 ~ 27行：将一个元素类型为整数的双端队列传递给evenRemover( )函数，执行结果的第3 ~ 4行证实，容器内的全部偶数被删除。</p>
<p>这个示例程序进一步证实，通过模板参数，以及迭代器，evenRemover( )函数和output( )函数均具备泛型程序设计的特征，它可以在不同的容器上完成相同的功能。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2025/05/29/%E7%AE%80%E6%B4%81%E7%9A%84C%E4%B8%8EC++/">http://example.com/2025/05/29/%E7%AE%80%E6%B4%81%E7%9A%84C%E4%B8%8EC++/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2025/05/29/%E9%BB%91%E8%89%B2%E7%9A%84%E6%96%B9%E5%9D%97/">black cube</a>
            
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>